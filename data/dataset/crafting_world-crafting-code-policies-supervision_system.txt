;; You will be a software engineer who will be writing a plan for a robot acting in a video game environment based on Minecraft. Your plan will be written as a sequence of imperative functions, each which defines a single action in this environment to achieve a natural language goal. These functions should be written in Python, with respect to the following code API.

;; Underlying PDDL predicates for querying the environment state.
(:predicates
   (tile-up ?t1 - tile ?t2 - tile)     ;; t2 is up of t1
   (tile-down ?t1 - tile ?t2 - tile)   ;; t2 is down of t1
   (tile-left ?t1 - tile ?t2 - tile)   ;; t2 is left of t1
   (tile-right ?t1 - tile ?t2 - tile)  ;; t2 is right of t1

   (agent-at ?t - tile)
   (object-at ?x - object ?t - tile)
   (inventory-holding ?i - inventory ?x - object)
   (inventory-empty ?i - inventory)

   (object-of-type ?x - object ?ot - object-type)
 )

 ;; Underlying objects in the environment state.
 (:constants
  Key - object-type
  WorkStation - object-type
  Pickaxe - object-type
  IronOreVein - object-type
  IronOre - object-type
  IronIngot - object-type
  CoalOreVein - object-type
  Coal - object-type
  GoldOreVein - object-type
  GoldOre - object-type
  GoldIngot - object-type
  CobblestoneStash - object-type
  Cobblestone - object-type
  Axe - object-type
  Tree - object-type
  Wood - object-type
  WoodPlank - object-type
  Stick - object-type
  WeaponStation - object-type
  Sword - object-type
  Chicken - object-type
  Feather - object-type
  Arrow - object-type
  ToolStation - object-type
  Shears - object-type
  Sheep - object-type
  Wool - object-type
  Bed - object-type
  BedStation - object-type
  BoatStation - object-type
  Boat - object-type
  SugarCanePlant - object-type
  SugarCane - object-type
  Paper - object-type
  Furnace - object-type
  FoodStation - object-type
  Bowl - object-type
  PotatoPlant - object-type
  Potato - object-type
  CookedPotato - object-type
  BeetrootCrop - object-type
  Beetroot - object-type
  BeetrootSoup - object-type

  Hypothetical - object-type
  Trash - object-type
 )

;; Actions that can be taken in the environment state.
def move_to_resource(s: CraftingWorld20230204Simulator, resource_name: str):
    """Move to the nearest resource."""

    for o, (t, x) in s.objects.items():
        if t == resource_name:
            s.move_to(x)
            return o


def find_object(s: CraftingWorld20230204Simulator, object_type_name: str):
    """Find the nearest object of the target type"""

    for o, (t, x) in s.objects.items():
        if t == object_type_name:
            return o


def pickup_object(s: CraftingWorld20230204Simulator, inventory: int, object_name: str):
    """Pick up the object."""
    assert object_name in s.objects
    rv = s.move_to(s.objects[object_name][1])
    if not rv:
        return False
    rv = s.pick_up(inventory, object_name)
    if not rv:
        return False
    return True


def find_empty_inventory(s: CraftingWorld20230204Simulator, other_than: set[int]):
    """Find a empty inventory."""
    for i, content in s.inventory.items():
        if content is None:
            if i not in other_than:
                return i


def find_hypothetical_object(s: CraftingWorld20230204Simulator, other_than: set[str]):
    """Find a hypothetical object"""

    for x in list(s.hypothetical):
        if x not in other_than:
            return x


def get_inventory_by_object_type(s: CraftingWorld20230204Simulator, object_type: str):
    """Get the object in the inventory."""

    for i, content in s.inventory.items():
        if content is None:
            continue
        t, object_id = content
        if t == object_type:
            return i


;; Example translations from natural language to a code policy in Python.
;; Notice that code MUST only use predicates, object types, and receptacle types exactly as they appear in the domain above. People may also have been unclear about which objects and actions they were talking about, so consider multiple possible guesses for goal if there is uncertainty over what they meant.
Your plan may include multiple actions if necessary.

;; Human written natural language goal.
Mine wood from the map.
;; Problem specific initial information.
(:init
   (object-of-type o1 IronOreVein)
   (object-at o1 t10)
   (object-of-type o2 CoalOreVein)
   (object-at o2 t11)
   (object-of-type o3 CobblestoneStash)
   (object-at o3 t5)
   (object-of-type o4 Tree)
   (object-at o4 t7)
   (object-of-type o5 Chicken)
   (object-at o5 t14)
   (object-of-type o6 Sheep)
   (object-at o6 t1)
   (object-of-type o7 PotatoPlant)
   (object-at o7 t2)
   (object-of-type o8 BeetrootCrop)
   (object-at o8 t8)
   (object-of-type o9 GoldOreVein)
   (object-at o9 t9)
   (object-of-type o10 SugarCanePlant)
   (object-at o10 t13)
   (object-of-type o11 Pickaxe)
   (object-at o11 t7)
   (object-of-type o12 Axe)
   (object-at o12 t8)
   (object-of-type o13 Sword)
   (object-at o13 t9)
   (object-of-type o14 Shears)
   (object-at o14 t5)
   (object-of-type o15 Hypothetical)
   (inventory-empty i1)
   (object-of-type o16 Hypothetical)
   (inventory-empty i2)
   (object-of-type o17 Hypothetical)
   (inventory-empty i3)
   (tile-right t1 t2)
   (tile-left t2 t1)
   (tile-right t2 t3)
   (tile-left t3 t2)
   (tile-right t3 t4)
   (tile-left t4 t3)
   (tile-right t4 t5)
   (tile-left t5 t4)
   (tile-right t5 t6)
   (tile-left t6 t5)
   (tile-right t6 t7)
   (tile-left t7 t6)
   (tile-right t7 t8)
   (tile-left t8 t7)
   (tile-right t8 t9)
   (tile-left t9 t8)
   (tile-right t9 t10)
   (tile-left t10 t9)
   (tile-right t10 t11)
   (tile-left t11 t10)
   (tile-right t11 t12)
   (tile-left t12 t11)
   (tile-right t12 t13)
   (tile-left t13 t12)
   (tile-right t13 t14)
   (tile-left t14 t13)
   (tile-right t14 t15)
   (tile-left t15 t14)
   (agent-at t1)
 )
;; Plan as code policies for "Mine wood from the map."
<START>
[
{
    "action": "mine_wood",
    "argument_names" : ('s', 'inventory', 'target_object'),
    "ground_arguments" : ("env_state", "3", "'o17'"),
    "body" : 
"""
    # Get any additional tools you may need.
    tool_inventory = get_inventory_by_object_type(s, 'Axe')
    if tool_inventory is None:
        object_id = find_object(s, 'Axe')
        if object_id is None:
            return False
        tool_inventory = find_empty_inventory(s, {inventory})
        rv = pickup_object(s, tool_inventory, object_id)
        if not rv:
            return False

    tree_object = move_to_resource(s, 'Tree')
    if tree_object is None:
        return False
    rv = s.mine(tree_object, inventory, target_object, tool_inventory)
    if not rv:
        return False
    return True
"""
}
]
<END>
