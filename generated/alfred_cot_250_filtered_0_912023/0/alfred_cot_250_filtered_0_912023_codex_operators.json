{"ExamineObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ExamineObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ExamineObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ExamineObject.\n;; ExamineObject takes an object to examine and does not require any tool objects or tool receptacles.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: none.\n(:action ExamineObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n        )\n    )\n", "\n;; Operator, ExamineObject.\n;; ExamineObject takes an object to examine and a specific tool of type CellPhoneType.\n;; CellPhoneType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolobject - object to use to examine.\n;; Preconditions: The toolobject is a CellPhoneType, the agent is at a location and the object is at the same location, and the agent is holding the tool.\n;; Postconditions: none.\n(:action ExamineObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject CellPhoneType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n        )\n    )\n", "\n;; Operator, ExamineObject.\n;; ExamineObject takes an object to examine and a specific tool receptacle of type CoffeeMachineType.\n;; CoffeeMachineType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolreceptacle - receptacle to use to examine.\n;; Preconditions: The toolreceptacle is a CoffeeMachineType, the agent is at a location and the tool receptacle is at the same location.\n;; Postconditions: none.\n(:action ExamineObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle CoffeeMachineType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n        )\n        :effect (and\n        )\n    )\n"]}, "TurnOnObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TurnOnObject\n;; TurnOnObject takes an object to turn on.\n;; Parameters: ?a - agent, ?l - location of the object, ?o - object to be turned on.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is toggleable.\n;; Postconditions: The ?o object is now toggled on.\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n        )\n        :effect (and\n            (isToggled ?o)\n        )\n)\n", "\n;; Operator, TurnOnObjectWithToolObject\n;; TurnOnObjectWithToolObject takes an object to turn on and a specific tool of type LightSwitchType.\n;; LightSwitchType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object, ?o - object to be turned on, ?toolobject - object to turn on the object with.\n;; Preconditions: The toolobject is a LightSwitchType, the agent is at a location and the object is at the same location, the object is toggleable, and the agent is holding the tool.\n;; Postconditions: The ?o object is now toggled on.\n(:action TurnOnObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToggled ?o)\n        )\n)\n", "\n;; Operator, TurnOnObjectWithToolReceptacle\n;; TurnOnObjectWithToolReceptacle takes an object to turn on and a specific tool of type LightSwitchType.\n;; LightSwitchType is a rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object, ?o - object to be turned on, ?toolreceptacle - receptacle to turn on the object with.\n;; Preconditions: The toolreceptacle is a LightSwitchType, the agent is at a location and the object is at the same location, the object is toggleable, and the toolreceptacle is opened.\n;; Postconditions: The ?o object is now toggled on.\n(:action TurnOnObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (opened ?toolreceptacle)\n        )\n        :effect (and\n            (isToggled ?o)\n        )\n)\n"]}, "LookForObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookForObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookForObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LookForObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (not (objectAtLocation ?o ?l))\n        )\n        :effect (and\n\n        )\n    )\n", "\n(:action LookForObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (not (objectAtLocation ?o ?l))\n            (holds ?a ?toolobject)\n            (objectType ?toolobject TowelType)\n        )\n        :effect (and\n\n        )\n    )\n", "\n(:action LookForObjectInReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (not (objectAtLocation ?o ?l))\n            (receptacleAtLocation ?r ?l)\n        )\n        :effect (and\n\n        )\n    )\n"]}, "TurnOffObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOffObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOffObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOffObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (isToggled ?o))\n        )\n    )\n", "\n(:action TurnOffObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n        )\n        :effect (and\n            (not (isToggled ?o))\n        )\n    )\n", "\n(:action TurnOffObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle LightSwitchType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (isToggled ?o))\n        )\n    )\n"]}, "ThrowObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ThrowObject_NoTool\n      :parameters (?a - agent ?l - location ?o - object)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n      )\n      :effect (and\n          (not (objectAtLocation ?o ?l))\n      )\n)\n", "\n(:action ThrowObject_WithTool\n      :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n      :precondition (and\n          (objectType ?toolobject BaseballBatType)\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (holds ?a ?toolobject)\n      )\n      :effect (and\n          (not (objectAtLocation ?o ?l))\n      )\n)\n", "\n(:action ThrowObject_WithToolReceptacle\n      :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n      :precondition (and\n          (receptacleType ?toolreceptacle GarbageCanType)\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (holds ?a ?o)\n      )\n      :effect (and\n          (not (objectAtLocation ?o ?l))\n          (inReceptacle ?o ?toolreceptacle)\n      )\n)\n"]}, "CutObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CutObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CutObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CutObject with a tool object (ButterKnifeType).\n;; CutObject takes an object to cut and a specific tool object of type ButterKnifeType.\n;; ButterKnifeType is an otype.\n;; Parameters: ?a - agent, ?l - location of object to cut; ?o - object to be cut, ?toolobject - object to cut with.\n;; Preconditions: The toolobject is a ButterKnifeType, the agent is at a location and the object to be cut is at the same location, the object is sliceable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now sliced.\n(:action CutObject_WithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n)\n", "\n;; Operator, CutObject with a tool receptacle (CuttingBoardType).\n;; CutObject takes an object to cut and a specific tool receptacle of type CuttingBoardType.\n;; CuttingBoardType is an rtype.\n;; Parameters: ?a - agent, ?l - location of the object to cut; ?o - object to be cut, ?toolreceptacle - receptacle to cut the object on.\n;; Preconditions: The toolreceptacle is a CuttingBoardType, the agent is at a location and the object is at the same location, and the agent is holding the object to be cut.\n;; Postconditions: the ?o object is now sliced.\n(:action CutObject_WithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle CuttingBoardType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n)\n", "\n;; Operator, CutObject without any tools.\n;; CutObject takes an object to cut without any tools.\n;; Parameters: ?a - agent, ?l - location of object to cut; ?o - object to be cut.\n;; Preconditions: The agent is at a location and the object to be cut is at the same location, and the object is sliceable.\n;; Postconditions: the ?o object is now sliced.\n(:action CutObject_WithoutTools\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n)\n"]}, "SliceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called SliceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different SliceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action SliceObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action SliceObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle CuttingBoardType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (inReceptacle ?o ?toolreceptacle)\n        )\n        :effect (and\n           (isSliced ?o)\n        )\n    )\n", "\n(:action SliceObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n"]}, "InspectObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called InspectObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different InspectObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action InspectObjectNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            ;; No effect\n        )\n)\n", "\n(:action InspectObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MirrorType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            ;; No effect\n        )\n)\n", "\n(:action InspectObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SafeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            ;; No effect\n        )\n)\n"]}, "LightObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LightObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LightObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LightObject1\n    :parameters (?a - agent ?l - location ?o - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (toggleable ?o)\n    )\n    :effect (and\n        (isToggled ?o)\n    )\n)\n", "\n(:action LightObject2\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (objectType ?toolobject CandleType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (toggleable ?o)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (isToggled ?o)\n    )\n)\n", "\n(:action LightObject3\n    :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (receptacleType ?toolreceptacle LampType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (toggleable ?o)\n        (holds ?a ?toolreceptacle)\n    )\n    :effect (and\n        (isToggled ?o)\n    )\n)\n"]}, "HeatObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called HeatObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different HeatObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action HeatObjectUsingToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n(:action HeatObjectUsingToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n(:action HeatObjectNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n"]}, "CookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CookObject 1.\n;; CookObject takes an object to cook and a specific tool of type PanType.\n;; PanType is a rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be cooked, ?toolreceptacle - receptacle to cook the object in.\n;; Preconditions: The toolreceptacle is a PanType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be cooked.\n;; Postconditions: the ?o object is now hot.\n(:action CookObject1\n    :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (receptacleType ?toolreceptacle PanType)\n        (atLocation ?a ?l)\n        (receptacleAtLocation ?toolreceptacle ?l)\n        (holds ?a ?o)\n    )\n    :effect (and\n        (isHot ?o)\n    )\n)\n", "\n;; Operator, CookObject 2.\n;; CookObject takes an object to cook and a specific tool of type ToasterType.\n;; ToasterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be cooked, ?toolobject - object to cook the object with.\n;; Preconditions: The toolobject is a ToasterType, the agent is at a location and the object to be cooked is at the same location, and the agent is holding the tool object.\n;; Postconditions: the ?o object is now hot.\n(:action CookObject2\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (objectType ?toolobject ToasterType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (isHot ?o)\n    )\n)\n", "\n;; Operator, CookObject 3.\n;; CookObject takes an object to cook and does not require any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be cooked.\n;; Preconditions: The agent is at a location and the object to be cooked is at the same location.\n;; Postconditions: the ?o object is now hot.\n(:action CookObject3\n    :parameters (?a - agent ?l - location ?o - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n    )\n    :effect (and\n        (isHot ?o)\n    )\n)\n"]}, "WashObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WashObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WashObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action WashObjectWithWater\n    :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (receptacleType ?toolreceptacle SinkType)\n        (atLocation ?a ?l)\n        (receptacleAtLocation ?toolreceptacle ?l)\n        (holds ?a ?o)\n    )\n    :effect (and\n        (isClean ?o)\n    )\n)\n", "\n(:action WashObjectWithSoap\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (objectType ?toolobject SoapBarType)\n        (receptacleType ?toolreceptacle SinkType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (receptacleAtLocation ?toolreceptacle ?l)\n        (cleanable ?o)\n        (holds ?a ?o)\n        (holds ?a ?toolobject)\n        (not (inReceptacle ?toolobject ?toolreceptacle))\n    )\n    :effect (and\n        (isClean ?o)\n    )\n)\n", "\n(:action WashObjectInSink\n    :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (receptacleType ?toolreceptacle SinkBasinType)\n        (atLocation ?a ?l)\n        (receptacleAtLocation ?toolreceptacle ?l)\n        (holds ?a ?o)\n    )\n    :effect (and\n        (isClean ?o)\n    )\n)\n"]}, "ToastObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ToastObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ToastObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ToastObject1.\n;; ToastObject1 takes an object to toast and a specific tool of type ToasterType.\n;; ToasterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be toasted; ?o - object to be toasted, ?toolobject - object to toast with.\n;; Preconditions: The toolobject is a ToasterType, the agent is at a location and the object to be toasted is at the same location, and the agent is holding the tool.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n;; Operator, ToastObject2.\n;; ToastObject2 takes an object to toast and a specific tool receptacle of type OvenType.\n;; OvenType is an rtype. Therefore, the tool receptacle is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be toasted, ?toolreceptacle - receptacle to toast the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, the toolreceptacle is opened, and the agent is holding the object to be toasted.\n;; Postconditions: the ?o object is now hot.\n(:action ToastObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (opened ?toolreceptacle)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n;; Operator, ToastObject3.\n;; ToastObject3 takes an object to toast, and no tool object or tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be toasted.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n"]}, "MicrowaveObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called MicrowaveObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different MicrowaveObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action MicrowaveObject_Receptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action MicrowaveObject_NoTools\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action MicrowaveObject_WithTools\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (objectType ?toolobject CDType)\n            (receptacleType ?toolreceptacle SafeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}, "CoolObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CoolObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CoolObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CoolObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle FridgeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (opened ?toolreceptacle)\n            (isClean ?toolreceptacle)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n", "\n(:action CoolObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject IcePackType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (isClean ?toolobject)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n", "\n(:action CoolObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n"]}, "DryObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called DryObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different DryObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action DryObjectWithTowel\n        :parameters (?a - agent ?l - location ?o - object ?towel - object)\n        :precondition (and\n            (objectType ?towel TowelType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?towel)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n)\n", "\n(:action DryObjectWithAir\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n)\n", "\n(:action DryObjectWithHairDryer\n        :parameters (?a - agent ?l - location ?o - object ?hairdryer - object)\n        :precondition (and\n            (objectType ?hairdryer HairDryerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?hairdryer)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n)\n"]}, "PlaceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PlaceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PlaceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action PlaceObject\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (objectAtLocation ?o ?l)\n            (objectType ?o ?t)\n            (receptacleType ?r ?t)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n    )\n", "\n(:action PlaceObjectNoReceptacle\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n    )\n", "\n(:action PlaceObjectWithTypeCheck\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (objectAtLocation ?o ?l)\n            (objectType ?o ?t)\n            (receptacleType ?r ?t)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n    )\n"]}, "ChillObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ChillObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ChillObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ChillObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle FreezerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n", "\n(:action ChillObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject IcePackType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n", "\n(:action ChillObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n"]}, "RinseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called RinseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different RinseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action RinseObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n)\n", "\n(:action RinseObject2\n        :parameters (?a - agent ?l - location ?o - object ?sink - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (receptacleAtLocation ?sink ?l)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n)\n", "\n(:action RinseObject3\n        :parameters (?a - agent ?l - location ?o - object ?faucet - object ?sink - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectType ?faucet FaucetType)\n            (holds ?a ?faucet)\n            (receptacleAtLocation ?sink ?l)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n"]}, "AdjustLighting": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called AdjustLighting.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different AdjustLighting operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, AdjustLighting with tool receptacle.\n;; AdjustLighting takes a specific lighting receptacle of type LampType and adjusts its lighting level.\n;; Parameters: ?a - agent, ?l - location of the lighting receptacle; ?r - lighting receptacle to adjust.\n;; Preconditions: The agent is at a location and the lighting receptacle is at the same location, and the lighting receptacle is a LampType.\n;; Postconditions: the lighting level of the ?r receptacle is adjusted.\n(:action AdjustLightingWithReceptacle\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (receptacleType ?r LampType)\n        )\n        :effect (and\n            ;; adjust lighting level of ?r receptacle\n        )\n    )\n", "\n;; Operator, AdjustLighting with tool object.\n;; AdjustLighting takes a specific lighting object of type FloorLampType and adjusts its lighting level.\n;; Parameters: ?a - agent, ?l - location of the lighting object; ?o - lighting object to adjust.\n;; Preconditions: The agent is at a location and the lighting object is at the same location, and the lighting object is a FloorLampType.\n;; Postconditions: the lighting level of the ?o object is adjusted.\n(:action AdjustLightingWithObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectType ?o FloorLampType)\n        )\n        :effect (and\n            ;; adjust lighting level of ?o object\n        )\n    )\n", "\n;; Operator, AdjustLighting without tool.\n;; AdjustLighting takes a specific lighting receptacle of type LampType and adjusts its lighting level without needing any tool.\n;; Parameters: ?a - agent, ?l - location of the lighting receptacle to adjust.\n;; Preconditions: The agent is at a location and the lighting receptacle is at the same location, and the lighting receptacle is a LampType.\n;; Postconditions: the lighting level of the ?r receptacle is adjusted.\n(:action AdjustLightingWithoutTool\n        :parameters (?a - agent ?l - location)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (receptacleType ?r LampType)\n        )\n        :effect (and\n            ;; adjust lighting level of ?r receptacle\n        )\n    )\n"]}, "WarmObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WarmObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WarmObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action WarmObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n(:action WarmObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (heatable ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n(:action WarmObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n"]}, "ThrowAwayObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowAwayObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowAwayObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ThrowAwayObject with Tool\n;; ThrowAwayObject takes an object to throw away and a specific tool of type GarbageCanType.\n;; GarbageCanType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be thrown away, ?toolreceptacle - receptacle to throw the object into.\n;; Preconditions: The toolreceptacle is a GarbageCanType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be thrown away.\n;; Postconditions: The object is no longer at any location.\n(:action ThrowAwayObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle GarbageCanType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n    )\n", "\n;; Operator, ThrowAwayObject without Tool\n;; ThrowAwayObject takes an object to throw away without any specific tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be thrown away.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: The object is no longer at any location.\n(:action ThrowAwayObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n    )\n", "\n;; Operator, ThrowAwayObject with Discardable Object Type\n;; ThrowAwayObject takes an object to throw away without any specific tool, but the object must be of type DiscardableType.\n;; DiscardableType is an otype. Therefore, the object is a specific type.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be thrown away.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is of type DiscardableType.\n;; Postconditions: The object is no longer at any location.\n(:action ThrowAwayObjectWithType\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectType ?o DiscardableType)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n    )\n"]}, "PutdownObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PutdownObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PutdownObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action PutdownObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (holds ?a ?o))\n            (objectAtLocation ?o ?l)\n        )\n    )\n", "\n(:action PutdownObjectInReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (holds ?a ?o)\n            (receptacleAtLocation ?r ?l)\n        )\n        :effect (and\n            (not (holds ?a ?o))\n            (inReceptacle ?o ?r)\n        )\n    )\n", "\n(:action PutdownObjectInReceptacleWithTool\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (holds ?a ?o)\n            (receptacleAtLocation ?r ?l)\n            (objectType ?toolobject GraterType)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (holds ?a ?o))\n            (inReceptacle ?o ?r)\n        )\n    )\n"]}, "TakeObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TakeObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TakeObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TakeObject1.\n;; Takes a specific object and agent.\n;; Parameters: ?a - agent, ?l - location of the object to take, ?o - object to take.\n;; Preconditions: The object is at the location, the agent is at a location, and the agent is not holding any objects.\n;; Postconditions: The object is held by the agent.\n(:action TakeObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holdsAny ?a)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (not (objectAtLocation ?o ?l))\n        )\n)\n", "\n;; Operator, TakeObject2.\n;; Takes a specific object and agent, and uses a specific tool object.\n;; Parameters: ?a - agent, ?l - location of the object to take, ?o - object to take, ?toolobject - object to use for taking the object.\n;; Preconditions: The object is at the location, the agent is at a location, and the agent is holding the tool object.\n;; Postconditions: The object is held by the agent.\n(:action TakeObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (not (objectAtLocation ?o ?l))\n        )\n)\n", "\n;; Operator, TakeObject3.\n;; Takes a specific object and agent, and uses a specific tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object to take, ?o - object to take, ?toolreceptacle - receptacle to use for taking the object.\n;; Preconditions: The object is at the location, the agent is at a location, the receptacle is at the same location as the agent, and the receptacle contains the object.\n;; Postconditions: The object is held by the agent.\n(:action TakeObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (inReceptacle ?o ?toolreceptacle)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (not (objectAtLocation ?o ?l))\n            (not (inReceptacle ?o ?toolreceptacle))\n        )\n)\n"]}, "OpenObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called OpenObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different OpenObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, OpenObject with a tool object.\n;; OpenObject takes any object to open with a specific tool of type KeyChainType.\n;; KeyChainType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened, ?toolobject - object to open the object with.\n;; Preconditions: The toolobject is a KeyChainType, the agent is at a location and the object is at the same location, the object is openable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KeyChainType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (opened ?o)\n        )\n    )\n", "\n;; Operator, OpenObject with a tool receptacle.\n;; OpenObject takes any object to open with a specific tool receptacle of type SafeType.\n;; SafeType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be opened, ?toolreceptacle - receptacle to open the object with.\n;; Preconditions: The toolreceptacle is a SafeType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be opened.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SafeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (opened ?o)\n        )\n    )\n", "\n;; Operator, OpenObject without a tool.\n;; OpenObject takes any object to open without any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is openable.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n        )\n        :effect (and\n            (opened ?o)\n        )\n    )\n"]}, "CloseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CloseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CloseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CloseObject.\n;; CloseObject takes any receptacle to close.\n;; This action is applicable to any openable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be closed.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is openable and opened.\n;; Postconditions: the ?r receptacle is now closed.\n(:action CloseObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n", "\n;; Operator, CloseObjectWithTool.\n;; CloseObjectWithTool takes a tool object and a receptacle to close.\n;; The tool object must have the same type of the receptacle to be closed.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be closed; ?toolobject - tool object to use.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, the receptacle is openable and opened, the toolobject is of the same type as the receptacle, and the agent is holding the toolobject.\n;; Postconditions: the ?r receptacle is now closed.\n(:action CloseObjectWithTool\n        :parameters (?a - agent ?l - location ?r - receptacle ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (opened ?r)\n            (receptacleType ?r ?t)\n            (objectType ?toolobject ?t)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n", "\n;; Operator, CloseObjectWithReceptacle.\n;; CloseObjectWithReceptacle takes a tool receptacle and a receptacle to close.\n;; The tool receptacle must have the same type of the receptacle to be closed.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be closed; ?toolreceptacle - tool receptacle to use.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, the receptacle is openable and opened, the toolreceptacle is of the same type as the receptacle, and the agent is holding the ?toolreceptacle with the opened receptacle inside.\n;; Postconditions: the ?r receptacle is now closed.\n(:action CloseObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?r - receptacle ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (opened ?r)\n            (receptacleType ?r ?t)\n            (receptacleType ?toolreceptacle ?t)\n            (inReceptacle ?r ?toolreceptacle)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n    )\n"]}, "ActivateObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ActivateObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ActivateObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ActivateObject.\n;; ActivateObject takes any object to activate. The object may or may not require a tool to activate.\n;; This action is applicable to any object that is toggleable or has a toggleable component.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be activated.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: the ?o object is now activated.\n(:action ActivateObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (or\n              (toggleable ?o)\n              (exists (?c - object) \n                      (and \n                        (isComponentOf ?c ?o) \n                        (toggleable ?c)))))\n        :effect (and\n            (isToggled ?o)\n        )\n)\n", "\n;; Operator, ActivateObjectWithTool.\n;; ActivateObjectWithTool takes any object to activate. The object requires a specific tool of type KeyChainType to activate.\n;; KeyChainType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be activated; ?toolobject - object to activate the object with.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is toggleable or has a toggleable component, and the agent is holding the tool.\n;; Postconditions: the ?o object is now activated.\n(:action ActivateObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (or\n              (toggleable ?o)\n              (exists (?c - object) \n                      (and \n                        (isComponentOf ?c ?o) \n                        (toggleable ?c)))))\n        :effect (and\n            (isToggled ?o)\n        )\n)\n", "\n;; Operator, ActivateObjectInReceptacle.\n;; ActivateObjectInReceptacle takes any object to activate. The object requires a specific tool receptacle of type FridgeType to activate.\n;; FridgeType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle containing the object to be activated; ?o - object to be activated.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, the object is inside the receptacle, the object is toggleable or has a toggleable component, and the receptacle is of type FridgeType.\n;; Postconditions: the ?o object is now activated.\n(:action ActivateObjectInReceptacle\n        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (inReceptacle ?o ?r)\n            (receptacleType ?r FridgeType)\n            (or\n              (toggleable ?o)\n              (exists (?c - object) \n                      (and \n                        (isComponentOf ?c ?o) \n                        (toggleable ?c)))))\n        :effect (and\n            (isToggled ?o)\n        )\n)\n"]}, "LookAtObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookAtObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookAtObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LookAtObject\n    :parameters (?a - agent ?l - location ?o - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n    )\n    :effect (and\n        ; No effect specified\n    )\n)\n"]}, "TurnOnLight": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnLight.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnLight operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TurnOnLight.\n;; TurnOnLight takes a specific light switch object and a specific light receptacle.\n;; Parameters: ?a - agent, ?lSwitch - location of the light switch object; ?lLight - location of the light receptacle.\n;; Preconditions: The agent is at a location, the light switch object and the light receptacle are at the same location, the light switch object is toggleable, and the agent is holding the light switch object.\n;; Postconditions: the light switch object is now toggled and the light receptacle is now opened.\n(:action TurnOnLight\n        :parameters (?a - agent ?lSwitch - location ?lLight - location)\n        :precondition (and\n            (atLocation ?a ?lSwitch)\n            (atLocation ?lLight ?lSwitch)\n            (objectType ?lSwitch LightSwitchType)\n            (toggleable ?lSwitch)\n            (holds ?a ?lSwitch)\n        )\n        :effect (and\n            (isToggled ?lSwitch)\n            (opened ?lLight)\n        )\n    )\n", "\n;; Operator, TurnOnLight.\n;; TurnOnLight takes a specific tool object that can be used to turn on the light.\n;; Parameters: ?a - agent, ?l - location of the tool object; ?lLight - location of the light receptacle.\n;; Preconditions: The agent is at a location, the tool object and the light receptacle are at the same location, the agent is holding the tool object, and the light receptacle is toggleable.\n;; Postconditions: the light receptacle is now opened.\n(:action TurnOnLight\n        :parameters (?a - agent ?l - location ?lLight - location)\n        :precondition (and\n            (atLocation ?a ?l)\n            (atLocation ?lLight ?l)\n            (toggleable ?lLight)\n            (holds ?a ?l)\n        )\n        :effect (and\n            (opened ?lLight)\n        )\n    )\n", "\n;; Operator, TurnOnLight.\n;; TurnOnLight takes a specific tool receptacle that can be used to turn on the light.\n;; Parameters: ?a - agent, ?lSwitch - location of the light switch object; ?lLight - location of the tool receptacle to turn on the light.\n;; Preconditions: The agent is at a location, the light switch object and the tool receptacle are at the same location, the light switch object is toggleable, and the agent is holding the light switch object.\n;; Postconditions: the light switch object is now toggled and the light receptacle is now opened.\n(:action TurnOnLight\n        :parameters (?a - agent ?lSwitch - location ?lLight - location)\n        :precondition (and\n            (atLocation ?a ?lSwitch)\n            (atLocation ?lLight ?lSwitch)\n            (objectType ?lSwitch LightSwitchType)\n            (toggleable ?lSwitch)\n            (holds ?a ?lSwitch)\n        )\n        :effect (and\n            (isToggled ?lSwitch)\n            (opened ?lLight)\n        )\n    )\n"]}, "LookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, LookObject 1\n;; LookObject takes an object to look at.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to look at.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: None\n(:action LookObject1\n      :parameters (?a - agent ?l - location ?o - object)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n      )\n      :effect (and\n      )\n  )\n", "\n;; Operator, LookObject 2\n;; LookObject takes an object to look at and a tool receptacle to help inspect the object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to look at, ?toolreceptacle - tool receptacle to help inspect the object.\n;; Preconditions: The agent is at a location and the object is at the same location, the toolreceptacle is openable and is at the location.\n;; Postconditions: None\n(:action LookObject2\n      :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (openable ?toolreceptacle)\n          (receptacleAtLocation ?toolreceptacle ?l)\n      )\n      :effect (and\n      )\n  )\n", "\n;; Operator, LookObject 3\n;; LookObject takes an object to look at and a tool object to help inspect the object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to look at, ?toolobject - tool object to help inspect the object.\n;; Preconditions: The agent is at a location and the object is at the same location, the toolobject is at the location.\n;; Postconditions: None\n(:action LookObject3\n      :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (objectAtLocation ?toolobject ?l)\n      )\n      :effect (and\n      )\n  )\n"]}, "GoToObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GoToObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GoToObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, GoToObject (Option 1)\n;; GoToObject takes an object to approach and the agent goes to the location of the object.\n;; Parameters: ?a - agent, ?o - object to approach; ?l - location of the object.\n;; Preconditions: The agent is not at the location of the object and the object is at a specific location.\n;; Postconditions: The agent is at the location of the object and is not at the previous location.\n(:action GoToObject\n      :parameters (?a - agent ?o - object ?l - location)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n      )\n      :effect (and\n          (atLocation ?a ?l)\n          (not (atLocation ?a ?l))\n      )\n  )\n", "\n;; Operator, GoToObject (Option 2)\n;; GoToObject takes an object to approach and the agent goes to the location of the object.\n;; Parameters: ?a - agent, ?o - object to approach; ?l - location of the object.\n;; Preconditions: The agent is not at the location of the object and the object is at a specific location.\n;; Postconditions: The agent is at the location of the object and is not at the previous location.\n(:action GoToObject\n      :parameters (?a - agent ?o - object ?l - location)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n      )\n      :effect (and\n          (atLocation ?a ?l)\n          (not (atLocation ?a ?l))\n      )\n  )\n", "\n;; Operator, GoToObject (Option 3)\n;; GoToObject takes an object to approach and the agent goes to the location of the object.\n;; Parameters: ?a - agent, ?o - object to approach; ?l - location of the object.\n;; Preconditions: The agent is not at the location of the object and the object is at a specific location.\n;; Postconditions: The agent is at the location of the object and is not at the previous location.\n(:action GoToObject\n      :parameters (?a - agent ?o - object ?l - location)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n      )\n      :effect (and\n          (atLocation ?a ?l)\n          (not (atLocation ?a ?l))\n      )\n  )\n"]}, "DiscardObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called DiscardObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different DiscardObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, DiscardObject.\n;; DiscardObject takes an object to discard and a specific tool receptacle of type GarbageCanType.\n;; GarbageCanType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object to be discarded; ?o - object to be discarded, ?toolreceptacle - receptacle to discard the object in.\n;; Preconditions: The toolreceptacle is a GarbageCanType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be discarded.\n;; Postconditions: the ?o object is no longer at the location and is in the garbage can.\n(:action DiscardObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle GarbageCanType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (inReceptacle ?o ?toolreceptacle)\n        )\n    )\n", "\n;; Operator, DiscardObject.\n;; DiscardObject takes an object to discard without a tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object to be discarded; ?o - object to be discarded.\n;; Preconditions: The agent is at a location and the object to be discarded is at the same location.\n;; Postconditions: the ?o object is no longer at the location.\n(:action DiscardObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n    )\n", "\n;; Operator, DiscardObject.\n;; DiscardObject takes an object to discard with a specific tool object of type DishSpongeType.\n;; DishSpongeType is an otype. Therefore, the tool object is an object.\n;; Parameters: ?a - agent, ?l - location of the object to be discarded; ?o - object to be discarded, ?toolobject - object to discard the object with.\n;; Preconditions: The toolobject is a DishSpongeType, the agent is at a location and the object to be discarded is at the same location, and the agent is holding the tool object and the object to be discarded.\n;; Postconditions: the ?o object is no longer at the location and is cleaned with the tool object.\n(:action DiscardObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject DishSpongeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (cleanable ?o)\n            (isClean ?o)\n        )\n    )\n"]}, "CleanObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CleanObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CleanObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CleanObject with Cloth.\n;; CleanObject with Cloth takes an object to clean, and a specific tool of type ClothType.\n;; ClothType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cleaned; ?o - object to be cleaned, ?toolobject - object to clean with.\n;; Preconditions: The toolobject is a ClothType, the agent is at a location and the object to be cleaned is at the same location, the object is cleanable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now clean.\n(:action CleanObject-Cloth\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ClothType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n;; Operator, CleanObject with Sponge.\n;; CleanObject with Sponge takes an object to clean, and a specific tool of type SpongeType.\n;; SpongeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cleaned; ?o - object to be cleaned, ?toolobject - object to clean with.\n;; Preconditions: The toolobject is a SpongeType, the agent is at a location and the object to be cleaned is at the same location, the object is cleanable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now clean.\n(:action CleanObject-Sponge\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject SpongeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n;; Operator, CleanObject in Sink.\n;; CleanObject in Sink takes an object to clean, and a specific tool of type SinkBasinType, which is a receptacle type.\n;; Parameters: ?a - agent, ?l - location of object to be cleaned; ?o - object to be cleaned, ?toolreceptacle - receptacle to clean in.\n;; Preconditions: The toolreceptacle is a SinkBasinType, the agent is at a location and the object to be cleaned is at the same location, the object is cleanable.\n;; Postconditions: the ?o object is now clean.\n(:action CleanObject-Sink\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SinkBasinType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n"]}}