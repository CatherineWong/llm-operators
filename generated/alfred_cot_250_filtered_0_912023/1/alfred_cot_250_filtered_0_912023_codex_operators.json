{"ExamineObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ExamineObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ExamineObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ExamineObject1.\n;; ExamineObject1 takes an object to examine and a specific tool of type MagnifyingGlassType.\n;; MagnifyingGlassType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be examined; ?o - object to be examined; ?toolobject - object to examine with.\n;; Preconditions: The toolobject is a MagnifyingGlassType, the agent is at a location and the object to be examined is at the same location, and the agent is holding the tool.\n;; Postconditions: The agent has examined the object.\n(:action ExamineObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (hasExamined ?a ?o)\n        )\n    )\n", "\n;; Operator, ExamineObject2.\n;; ExamineObject2 takes an object to examine using a non-tool object.\n;; Parameters: ?a - agent, ?l - location of object to be examined; ?o - object to be examined; ?object - non-tool object to use for examination.\n;; Preconditions: The non-tool object is at the same location as the object to be examined, and the agent is at a location.\n;; Postconditions: The agent has examined the object.\n(:action ExamineObject2\n        :parameters (?a - agent ?l - location ?o - object ?object - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectAtLocation ?object ?l)\n        )\n        :effect (and\n            (hasExamined ?a ?o)\n        )\n    )\n", "\n;; Operator, ExamineObject3.\n;; ExamineObject3 takes an object to examine using a tool receptacle.\n;; Parameters: ?a - agent, ?l - location of object to be examined; ?o - object to be examined; ?toolreceptacle - tool receptacle to use for examination.\n;; Preconditions: The tool receptacle is at the same location as the object to be examined, and the agent is at a location.\n;; Postconditions: The agent has examined the object.\n(:action ExamineObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n        )\n        :effect (and\n            (hasExamined ?a ?o)\n        )\n    )\n"]}, "TurnOnObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOnObjectWithSwitchTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject SwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n    )\n", "\n(:action TurnOnObjectNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n    )\n", "\n(:action TurnOnObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?object)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n    )\n"]}, "TurnOnLight": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnLight.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnLight operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOnLightOption1\n        :parameters (?a - agent ?ls - object)\n        :precondition (and\n            (objectType ?ls LightSwitchType)\n            (isToggled ?ls)\n        )\n        :effect (and\n            (isOn ?ls)\n        )\n    )\n", "\n(:action TurnOnLightOption2\n        :parameters (?a - agent ?l - location ?to - object)\n        :precondition (and\n            (objectType ?to LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?to ?l)\n            (isToggled ?to)\n            (holds ?a ?to)\n        )\n        :effect (and\n            (isOn ?to)\n        )\n    )\n", "\n(:action TurnOnLightOption3\n        :parameters (?a - agent ?ls - object ?hp - object)\n        :precondition (and\n            (objectType ?ls LightSwitchType)\n            (objectType ?hp HousePlantType)\n            (isToggled ?ls)\n            (holds ?a ?hp)\n        )\n        :effect (and\n            (isOn ?ls)\n        )\n    )\n"]}, "SeeObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called SeeObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different SeeObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action SeeObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject TelescopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (canSeeObject ?a ?o)\n        )\n    )\n", "\n(:action SeeObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle BinocularsType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (canSeeObject ?a ?o)\n        )\n    )\n", "\n(:action SeeObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (canSeeObject ?a ?o)\n        )\n    )\n"]}, "ThrowObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ThrowObject1.\n;; ThrowObject1 takes any object to throw.\n;; This action is applicable to any throwable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be thrown.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is throwable.\n;; Postconditions: the ?o object is removed from its current location.\n(:action ThrowObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwable ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n)\n", " \n;; Operator, ThrowObject2.\n;; ThrowObject2 takes any object to throw.\n;; This action is applicable to any throwable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be thrown.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is throwable.\n;; Postconditions: the ?o object is removed from its current location and it becomes dirty.\n(:action ThrowObject2\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwable ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (isDirty ?o)\n        )\n)\n", " \n;; Operator, ThrowObject3.\n;; ThrowObject3 takes any object to throw.\n;; This action is applicable to any throwable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be thrown.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is throwable.\n;; Postconditions: the ?o object is removed from its current location and it becomes dirty, and the agent drops any object it is holding.\n(:action ThrowObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwable ?o)\n            (holdsAny ?a)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (isDirty ?o)\n            (not (holdsAny ?a))\n        )\n)\n"]}, "CutObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CutObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CutObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CutObject.\n;; CutObject takes an object to be cut, a specific tool of type KnifeType, and a specific receptacle of type cuttingBoardType.\n;; Parameters: ?a - agent, ?l - location of the object to be cut; ?o - object to be cut, ?toolobject - object to cut with, ?toolreceptacle - receptacle to cut the object on.\n;; Preconditions: The toolobject is a KnifeType, the toolreceptacle is a cuttingBoardType, the agent is at a location and the object to be cut is at the same location,\n;;               the object is cuttable, the receptacle is at the same location as the agent, and the agent is holding the toolobject and the toolreceptacle is empty.\n;; Postconditions: the ?o object is now cut and placed on the ?toolreceptacle.\n(:action CutObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (receptacleType ?toolreceptacle CuttingBoardType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cuttable ?o)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?toolobject)\n            (not (inReceptacle ?o ?toolreceptacle))\n        )\n        :effect (and\n            (isCut ?o)\n            (inReceptacle ?o ?toolreceptacle)\n        )\n    )\n", "\n;; Operator, CutObject.\n;; CutObject takes an object to be cut, only a specific tool of type KnifeType. \n;; Parameters: ?a - agent, ?l - location of the object to be cut; ?o - object to be cut, ?toolobject - object to cut with.\n;; Preconditions: The toolobject is a KnifeType, the agent is at a location and the object to be cut is at the same location,\n;;               the object is cuttable, and the agent is holding the toolobject.\n;; Postconditions: the ?o object is now cut.\n(:action CutObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cuttable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isCut ?o)\n        )\n    )\n", "\n;; Operator, CutObject.\n;; CutObject takes an object to be cut, only a specific receptacle of type cuttingBoardType.\n;; Parameters: ?a - agent, ?l - location of the object to be cut; ?o - object to be cut, ?toolreceptacle - receptacle to cut the object on.\n;; Preconditions: The toolreceptacle is a cuttingBoardType, the agent is at a location and the object to be cut is at the same location,\n;;               the object is cuttable, the receptacle is at the same location as the agent, and the toolreceptacle is empty.\n;; Postconditions: the ?o object is now cut.\n(:action CutObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle CuttingBoardType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cuttable ?o)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (not (inReceptacle ?o ?toolreceptacle))\n        )\n        :effect (and\n            (isCut ?o)\n        )\n    )\n"]}, "InspectObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called InspectObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different InspectObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, InspectObject with tool object.\n;; InspectObject takes an object to inspect and a specific tool of type MagnifyingGlassType.\n;; MagnifyingGlassType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be inspected; ?o - object to be inspected, ?toolobject - object to inspect with.\n;; Preconditions: The toolobject is a MagnifyingGlassType, the agent is at a location and the object to be inspected is at the same location, and the agent is holding the tool.\n;; Postconditions: The agent gains knowledge about the inspected object, represented by the predicate hasKnowledge(?a, ?o).\n(:action InspectObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (hasKnowledge ?a ?o)\n        )\n    )\n", "\n;; Operator, InspectObject without tool.\n;; InspectObject takes an object to inspect.\n;; This action does not require any tool objects or tool receptacles.\n;; Parameters: ?a - agent, ?l - location of object to be inspected; ?o - object to be inspected.\n;; Preconditions: The agent is at a location and the object to be inspected is at the same location.\n;; Postconditions: The agent gains knowledge about the inspected object, represented by the predicate hasKnowledge(?a, ?o).\n(:action InspectObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (hasKnowledge ?a ?o)\n        )\n    )\n", "\n;; Operator, InspectObject with tool receptacle.\n;; InspectObject takes an object to inspect and a specific tool of type MicroscopeType.\n;; MicroscopeType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of object to be inspected; ?o - object to be inspected, ?toolreceptacle - receptacle to inspect with.\n;; Preconditions: The toolreceptacle is a MicroscopeType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be inspected.\n;; Postconditions: The agent gains knowledge about the inspected object, represented by the predicate hasKnowledge(?a, ?o).\n(:action InspectObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (hasKnowledge ?a ?o)\n        )\n    )\n"]}, "HeatObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called HeatObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different HeatObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action HeatObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action HeatObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action HeatObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n"]}, "CookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CookObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action CookObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle GrillType)\n            (objectType ?toolobject GrillType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action CookObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}, "GoToObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GoToObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GoToObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, GoToObject.\n;; GoToObject takes an object to go to and an optional tool object and tool receptacle.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location; ?o - object to go to; ?toolobject - optional tool object; ?toolreceptacle - optional tool receptacle.\n;; Preconditions: The agent is at the start location, the object to go to is at the end location, and if a tool object or tool receptacle is specified, the agent is holding the tool object or the tool receptacle is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location. If a tool object or tool receptacle is specified, the agent is holding the tool object or the tool receptacle is at the end location.\n(:action GoToObject\n      :parameters (?a - agent ?lStart - location ?lEnd - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n      :precondition (and\n          (atLocation ?a ?lStart)\n          (objectAtLocation ?o ?lEnd)\n          (or (not (exists (?toolobject) (holds ?a ?toolobject))))\n          (or \n            (not (exists (?toolreceptacle) (receptacleAtLocation ?toolreceptacle ?lStart))))\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n          (when (and ?toolobject (objectType ?toolobject ToolType))\n            (holds ?a ?toolobject))\n          (when (and ?toolreceptacle (receptacleType ?toolreceptacle ToolReceptacleType))\n            (receptacleAtLocation ?toolreceptacle ?lEnd))\n      )\n )\n", "\n;; Operator, GoToObject with a tool object.\n;; GoToObject takes an object to go to and an optional tool object and tool receptacle.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location; ?o - object to go to; ?toolobject - optional tool object; ?toolreceptacle - optional tool receptacle.\n;; Preconditions: The agent is at the start location, the object to go to is at the end location, the tool object is a ToolType, the agent is holding the tool object, and if a tool receptacle is specified, the agent is holding the tool receptacle.\n;; Postconditions: The agent is at the end location and is not at the start location. The agent is still holding the tool object and if a tool receptacle is specified, the agent is still holding the tool receptacle.\n(:action GoToObjectWithTool\n      :parameters (?a - agent ?lStart - location ?lEnd - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n      :precondition (and\n          (atLocation ?a ?lStart)\n          (objectAtLocation ?o ?lEnd)\n          (objectType ?toolobject ToolType)\n          (holds ?a ?toolobject)\n          (or (not (exists (?toolreceptacle) (holds ?a ?toolreceptacle))))\n          (or \n            (not (exists (?toolreceptacle) (receptacleAtLocation ?toolreceptacle ?lStart))))\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n          (holds ?a ?toolobject)\n          (when (and ?toolreceptacle (receptacleType ?toolreceptacle ToolReceptacleType))\n            (receptacleAtLocation ?toolreceptacle ?lEnd))\n      )\n )\n", "\n;; Operator, GoToObject with a tool receptacle.\n;; GoToObject takes an object to go to and an optional tool object and tool receptacle.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location; ?o - object to go to; ?toolobject - optional tool object; ?toolreceptacle - optional tool receptacle.\n;; Preconditions: The agent is at the start location, the object to go to is at the end location, the tool receptacle is a ToolReceptacleType, the agent is holding the tool receptacle, and if a tool object is specified, it is a ToolType and the agent is holding the tool object.\n;; Postconditions: The agent is at the end location and is not at the start location. The agent is still holding the tool receptacle and if a tool object is specified, the agent is still holding the tool object.\n(:action GoToObjectWithToolReceptacle\n      :parameters (?a - agent ?lStart - location ?lEnd - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n      :precondition (and\n          (atLocation ?a ?lStart)\n          (objectAtLocation ?o ?lEnd)\n          (receptacleType ?toolreceptacle ToolReceptacleType)\n          (receptacleAtLocation ?toolreceptacle ?lStart)\n          (or (not (exists (?toolobject) (holds ?a ?toolobject))))\n          (or \n            (not (exists (?toolobject) (objectType ?toolobject ToolType))))\n          (or \n            (not (exists (?toolobject) (holds ?a ?toolobject))))\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n          (receptacleAtLocation ?toolreceptacle ?lEnd)\n          (when (and ?toolobject (objectType ?toolobject ToolType))\n            (holds ?a ?toolobject))\n      )\n )\n"]}, "GoalExamineObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GoalExamineObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GoalExamineObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, GoalExamineObject1.\n;; GoalExamineObject1 takes an object to examine.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is examinable.\n;; Postconditions: The agent now knows the details of the ?o object.\n(:action GoalExamineObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (examinable ?o)\n        )\n        :effect (and\n            (knowsDetails ?a ?o)\n        )\n    )\n", "\n;; Operator, GoalExamineObject2.\n;; GoalExamineObject2 takes an object to examine and a specific tool of type MagnifyingGlassType.\n;; MagnifyingGlassType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolobject - object to examine with.\n;; Preconditions: The toolobject is a MagnifyingGlassType, the agent is at a location and the object to be examined is at the same location, the object is examinable, and the agent is holding the tool.\n;; Postconditions: The agent now knows the details of the ?o object.\n(:action GoalExamineObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (examinable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (knowsDetails ?a ?o)\n        )\n    )\n", "\n;; Operator, GoalExamineObject3.\n;; GoalExamineObject3 takes an object to examine and a specific tool of type MicroscopeType, and a specific receptacle of type LaboratoryTableType.\n;; MicroscopeType is an otype. Therefore, the tool is an object.\n;; LaboratoryTableType is an rtype. Therefore, the receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object to be examined; ?o - object to be examined, ?toolobject - object to examine with, ?receptacle - location of the Microscope.\n;; Preconditions: The toolobject is a MicroscopeType, the agent is at a location and the object to be examined is at the same location, the object is examinable, the agent is holding the tool, and the Microscope receptacle is at the same location.\n;; Postconditions: The agent now knows the details of the ?o object.\n(:action GoalExamineObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?receptacle - receptacle)\n        :precondition (and\n            (objectType ?toolobject MicroscopeType)\n            (receptacleType ?receptacle LaboratoryTableType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (examinable ?o)\n            (holds ?a ?toolobject)\n            (receptacleAtLocation ?receptacle ?l)\n        )\n        :effect (and\n            (knowsDetails ?a ?o)\n        )\n    )\n"]}, "ChillObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ChillObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ChillObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle FreezerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCold ?o)\n        )\n    )\n", "\n(:action FreezeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LiquidNitrogenType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (freezable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isFrozen ?o)\n        )\n    )\n", "\n(:action IceObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle IceboxType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isIced ?o)\n        )\n    )\n"]}, "TurnOffObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOffObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOffObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOffObject-ToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (isOn ?o))\n        )\n    )\n", "\n(:action TurnOffObject-ToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SinkType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (isOn ?o))\n        )\n    )\n", "\n(:action TurnOffObject-NoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n        )\n        :effect (and\n            (not (isOn ?o))\n        )\n    )\n"]}, "WashObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WashObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WashObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, WashObject1.\n;; WashObject1 takes an object to be washed, a specific tool object of type ClothType, and a specific tool receptacle of type SinkBasinType.\n;; Parameters: ?a - agent, ?l - location of the tool receptacle; ?o - object to be washed, ?toolobject - object to wash with, ?toolreceptacle - receptacle to wash the object in.\n;; Preconditions: The toolobject is a ClothType, the toolreceptacle is a SinkBasinType, the agent is at a location and the receptacle is at the same location, the object is washable, the agent is holding the tool object, and the object is in the tool receptacle.\n;; Postconditions: the ?o object is now clean and not in the tool receptacle.\n(:action WashObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (objectType ?toolobject ClothType)\n            (receptacleType ?toolreceptacle SinkBasinType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (objectAtLocation ?o ?toolreceptacle)\n            (washable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n            (not (inReceptacle ?o ?toolreceptacle))\n        )\n    )\n", "\n;; Operator, WashObject2.\n;; WashObject2 takes an object to be washed and a specific tool object of type DishSpongeType.\n;; The object is not washed in a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be washed, ?toolobject - object to wash with.\n;; Preconditions: The toolobject is a DishSpongeType, the agent is at a location and the object is at the same location, and the object is washable and not in any receptacle, and the agent is holding the tool object.\n;; Postconditions: the ?o object is now clean.\n(:action WashObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject DishSpongeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (washable ?o)\n            (not (inReceptacle ?o ?r))\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n;; Operator, WashObject3.\n;; WashObject3 takes an object to be washed and a specific tool receptacle of type BathtubBasinType.\n;; The object is washed inside the tool receptacle.\n;; Parameters: ?a - agent, ?l1 - location of the agent, ?l2 - location of the object; ?o - object to be washed, ?toolreceptacle - receptacle to wash the object in.\n;; Preconditions: The toolreceptacle is a BathtubBasinType, the agent is at location ?l1, the object is at location ?l2, the object is washable and in location ?l2, and the agent can reach ?l2 from ?l1.\n;; Postconditions: the ?o object is now clean and in the tool receptacle.\n(:action WashObject3\n        :parameters (?a - agent ?l1 - location ?l2 - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle BathtubBasinType)\n            (atLocation ?a ?l1)\n            (objectAtLocation ?o ?l2)\n            (washable ?o)\n            (reachable ?l1 ?l2)\n        )\n        :effect (and\n            (isClean ?o)\n            (inReceptacle ?o ?toolreceptacle)\n        )\n    )\n"]}, "LookAtObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookAtObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookAtObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LookAtObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n        )\n)\n", "\n(:action LookAtObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject BookType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n        )\n)\n", "\n(:action LookAtObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle DrawerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n        )\n)\n"]}, "LookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LookObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n        )\n    )\n", "\n(:action LookObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n        )\n)\n", "\n(:action LookObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolreceptacle)\n        )\n        :effect (and\n        )\n    )\n"]}}