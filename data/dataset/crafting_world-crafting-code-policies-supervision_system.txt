;; You will be a software engineer who will be writing a plan for a robot acting in a video game environment based on Minecraft. Your plan will be written as a sequence of imperative functions, each which defines a single action in this environment to achieve a natural language goal. These functions should be written in Python, with respect to the following code API.

;; Underlying PDDL predicates for querying the environment state.
(:predicates
   (tile-up ?t1 - tile ?t2 - tile)     ;; t2 is up of t1
   (tile-down ?t1 - tile ?t2 - tile)   ;; t2 is down of t1
   (tile-left ?t1 - tile ?t2 - tile)   ;; t2 is left of t1
   (tile-right ?t1 - tile ?t2 - tile)  ;; t2 is right of t1

   (agent-at ?t - tile)
   (object-at ?x - object ?t - tile)
   (inventory-holding ?i - inventory ?x - object)
   (inventory-empty ?i - inventory)

   (object-of-type ?x - object ?ot - object-type)
 )

 ;; Underlying objects in the environment state.
 (:constants
  Key - object-type
  WorkStation - object-type
  Pickaxe - object-type
  IronOreVein - object-type
  IronOre - object-type
  IronIngot - object-type
  CoalOreVein - object-type
  Coal - object-type
  GoldOreVein - object-type
  GoldOre - object-type
  GoldIngot - object-type
  CobblestoneStash - object-type
  Cobblestone - object-type
  Axe - object-type
  Tree - object-type
  Wood - object-type
  WoodPlank - object-type
  Stick - object-type
  Sword - object-type
  Chicken - object-type
  Feather - object-type
  Arrow - object-type
  Shears - object-type
  Sheep - object-type
  Wool - object-type
  Bed - object-type
  Boat - object-type
  SugarCanePlant - object-type
  SugarCane - object-type
  Paper - object-type
  Bowl - object-type
  PotatoPlant - object-type
  Potato - object-type
  CookedPotato - object-type
  BeetrootCrop - object-type
  Beetroot - object-type
  BeetrootSoup - object-type

  Hypothetical - object-type
  Trash - object-type
 )

;; Actions that can be taken in the environment state.
def move_to_resource(s: CraftingWorld20230204Simulator, resource_name: str):
    """Move to the nearest resource."""

    for o, (t, x) in s.objects.items():
        if t == resource_name:
            s.move_to(x)
            return o


def find_object(s: CraftingWorld20230204Simulator, object_type_name: str):
    """Find the nearest object of the target type"""

    for o, (t, x) in s.objects.items():
        if t == object_type_name:
            return o


def pickup_object(s: CraftingWorld20230204Simulator, inventory: int, object_name: str):
    """Pick up the object."""
    assert object_name in s.objects
    rv = s.move_to(s.objects[object_name][1])
    if not rv:
        return False
    rv = s.pick_up(inventory, object_name)
    if not rv:
        return False
    return True


def find_empty_inventory(s: CraftingWorld20230204Simulator, other_than: set[int]):
    """Find a empty inventory."""
    for i, content in s.inventory.items():
        if content is None:
            if i not in other_than:
                return i


def find_hypothetical_object(s: CraftingWorld20230204Simulator, other_than: set[str]):
    """Find a hypothetical object"""

    for x in list(s.hypothetical):
        if x not in other_than:
            return x


def get_inventory_by_object_type(s: CraftingWorld20230204Simulator, object_type: str):
    """Get the object in the inventory."""

    for i, content in s.inventory.items():
        if content is None:
            continue
        t, object_id = content
        if t == object_type:
            return i


;; Example translations from natural language to a code policy in Python.
;; Notice that code MUST only use predicates, object types, and receptacle types exactly as they appear in the domain above. People may also have been unclear about which objects and actions they were talking about, so consider multiple possible guesses for goal if there is uncertainty over what they meant.
Your plan may include multiple actions if necessary.
;; Target objects should always be a hypothetical object.
;; You may both DEFINE code policies and CALL code policies ('call_function')
;; Notice, for instance, that the crafting functions generally need to define additional mining functions that are called within their body.

;; Human written natural language goal.
Craft a wood plank.
;; Problem specific initial information.
(:init
   (object-of-type o1 WorkStation)
   (object-at o1 t12)
   (object-of-type o2 WeaponStation)
   (object-at o2 t11)
   (object-of-type o3 ToolStation)
   (object-at o3 t13)
   (object-of-type o4 Furnace)
   (object-at o4 t15)
   (object-of-type o5 BedStation)
   (object-at o5 t5)
   (object-of-type o6 BoatStation)
   (object-at o6 t3)
   (object-of-type o7 FoodStation)
   (object-at o7 t8)
   (object-of-type o8 Wood)
   (object-at o8 t4)
   (object-of-type o9 WoodPlank)
   (object-at o9 t7)
   (object-of-type o10 Stick)
   (object-at o10 t8)
   (object-of-type o11 Feather)
   (object-at o11 t12)
   (object-of-type o12 IronIngot)
   (object-at o12 t7)
   (object-of-type o13 GoldIngot)
   (object-at o13 t11)
   (object-of-type o14 IronOre)
   (object-at o14 t12)
   (object-of-type o15 Coal)
   (object-at o15 t12)
   (object-of-type o16 GoldOre)
   (object-at o16 t6)
   (object-of-type o17 Wool)
   (object-at o17 t2)
   (object-of-type o18 Potato)
   (object-at o18 t14)
   (object-of-type o19 Beetroot)
   (object-at o19 t5)
   (object-of-type o20 Bowl)
   (object-at o20 t5)
   (object-of-type o21 SugarCane)
   (object-at o21 t15)
   (object-of-type o22 Hypothetical)
   (inventory-empty i1)
   (object-of-type o23 Hypothetical)
   (inventory-empty i2)
   (object-of-type o24 Hypothetical)
   (inventory-empty i3)
   (tile-right t1 t2)
   (tile-left t2 t1)
   (tile-right t2 t3)
   (tile-left t3 t2)
   (tile-right t3 t4)
   (tile-left t4 t3)
   (tile-right t4 t5)
   (tile-left t5 t4)
   (tile-right t5 t6)
   (tile-left t6 t5)
   (tile-right t6 t7)
   (tile-left t7 t6)
   (tile-right t7 t8)
   (tile-left t8 t7)
   (tile-right t8 t9)
   (tile-left t9 t8)
   (tile-right t9 t10)
   (tile-left t10 t9)
   (tile-right t10 t11)
   (tile-left t11 t10)
   (tile-right t11 t12)
   (tile-left t12 t11)
   (tile-right t12 t13)
   (tile-left t13 t12)
   (tile-right t13 t14)
   (tile-left t14 t13)
   (tile-right t14 t15)
   (tile-left t15 t14)
   (agent-at t1)
 )
;; Plan as code policies for "Craft a wood plank." Notice that we first define a mine wood function. 
<START>
[
{
    "action_type": "action_definition",
    "action": "mine_wood",
    "argument_names" : ('s', 'inventory', 'target_object'),
    "ground_arguments" : None,
    "body" : 
"""
    # First, define a function to mine wood.
    # Get any additional tools you may need.
    tool_inventory = get_inventory_by_object_type(s, 'Axe')
    if tool_inventory is None:
        object_id = find_object(s, 'Axe')
        if object_id is None:
            return False
        tool_inventory = find_empty_inventory(s, {inventory})
        rv = pickup_object(s, tool_inventory, object_id)
        if not rv:
            return False

    tree_object = move_to_resource(s, 'Tree')
    if tree_object is None:
        return False
    rv = s.mine(tree_object, inventory, target_object, tool_inventory)
    if not rv:
        return False
    return True
"""
},
{
    "action_type": "action_definition",
    "action": "craft_wood_plank",
    "argument_names" : ('s', 'inventory', 'target_object'),
    "ground_arguments" : None,
    "body" : 
"""
    # Now, define a function to craft wood. This has previously defined a mine_wood function.
    # We can then craft wood planks from the mined wood.
    exclude_inventory = set()
    exclude_object = set()

    ingredient1_inventory = get_inventory_by_object_type(s, 'Wood')
    if ingredient1_inventory is None:
        object_id = find_object(s, 'Wood')
        if object_id is not None:
            ingredient1_inventory = find_empty_inventory(s, exclude_inventory | {inventory})
            rv = pickup_object(s, ingredient1_inventory, object_id)
            if not rv:
                return False
        else:
            ingredient1_inventory = find_empty_inventory(s, exclude_inventory | {inventory})
            ingredient1_target_object = find_hypothetical_object(s, exclude_object | {target_object})
            # Call mine_wood if we don't already have it.
            ingredient1_inventory = mine_wood(s, ingredient1_inventory, ingredient1_target_object)

    work_station = move_to_resource(s, 'WorkStation')
    if work_station is None:
        return False
    rv = s.craft(work_station, inventory, target_object, [ingredient1_inventory], target_type='WoodPlank')
    if not rv:
        return False
    return True
"""
},
{
    "action_type": "call_action",
    "action": "craft_wood_plank",
    "argument_names" : ('s', 'inventory', 'target_object'),
    "ground_arguments" : ("env_state", "3", "'o24'"),
    "body" : None,
}
]
<END>