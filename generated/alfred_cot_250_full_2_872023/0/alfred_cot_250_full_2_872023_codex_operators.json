{"TurnOnObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (not (isOn ?o))\n        )\n        :effect (and\n            (isOn ?o)\n        )\n)\n", "\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (not (isOn ?o))\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n)\n", "\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle LampType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (not (isOn ?o))\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n)\n"]}, "ExamineObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ExamineObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ExamineObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ExamineObject.\n;; ExamineObject takes an object to examine.\n;; This action is applicable to any object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: The agent has examined the object.\n(:action ExamineObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (objectExamined ?o)\n        )\n    )\n", "\n;; Operator, ExamineObjectWithToolObject.\n;; ExamineObjectWithToolObject takes an object to examine and a specific tool of type MagnifyingGlassType.\n;; MagnifyingGlassType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolobject - object to examine with.\n;; Preconditions: The toolobject is a MagnifyingGlassType, the agent is at a location and the object to be examined is at the same location, and the agent is holding the tool.\n;; Postconditions: The agent has examined the object.\n(:action ExamineObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (objectExamined ?o)\n        )\n    )\n", "\n;; Operator, ExamineObjectWithToolReceptacle.\n;; ExamineObjectWithToolReceptacle takes an object to examine and a specific tool of type MicroscopeType.\n;; MicroscopeType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolreceptacle - receptacle to examine with.\n;; Preconditions: The toolreceptacle is an MicroscopeType, the agent is at a location and the object to be examined is at the same location, and the agent is holding the object to put in the receptacle.\n;; Postconditions: The agent has examined the object.\n(:action ExamineObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (objectExamined ?o)\n        )\n    )\n"]}, "TurnOffObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOffObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOffObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TurnOffObject - Using a tool object\n;; TurnOffObject using a tool object takes an object that can be turned off and a specific tool of type LightSwitchType.\n;; LightSwitchType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be turned off; ?o - object to be turned off, ?toolobject - object to turn off the object with.\n;; Preconditions: The toolobject is a LightSwitchType, the agent is at a location and the object to be turned off is at the same location, and the agent is holding the tool.\n;; Postconditions: the ?o object is now turned off.\n(:action TurnOffObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (turnableOff ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (isOn ?o))\n            (not (isToggled ?o))\n        )\n    )\n", "\n;; Operator, TurnOffObject - Using a tool receptacle\n;; TurnOffObject using a tool receptacle takes an object that can be turned off and a specific tool of type StoveKnobType.\n;; StoveKnobType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be turned off; ?o - object to be turned off, ?toolreceptacle - receptacle to turn off the object with.\n;; Preconditions: The toolreceptacle is a StoveKnobType, the agent is at a location and the object to be turned off is at the same location, and the agent is holding the object.\n;; Postconditions: the ?o object is now turned off.\n(:action TurnOffObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveKnobType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (turnableOff ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (isOn ?o))\n            (not (isToggled ?o))\n        )\n    )\n", "\n;; Operator, TurnOffObject - No tool needed\n;; TurnOffObject with no tool needed takes an object that can be turned off without any specific tool.\n;; Parameters: ?a - agent, ?l - location of object to be turned off; ?o - object to be turned off.\n;; Preconditions: The agent is at a location and the object to be turned off is at the same location, and the object is turnable off.\n;; Postconditions: the ?o object is now turned off.\n(:action TurnOffObjectNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (turnableOff ?o)\n        )\n        :effect (and\n            (not (isOn ?o))\n            (not (isToggled ?o))\n        )\n    )\n"]}, "OpenObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called OpenObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different OpenObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, OpenObject.\n;; OpenObject takes any openable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is openable and not already opened.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (not (opened ?o))\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n", "\n;; Operator, OpenObjectWithTool.\n;; OpenObjectWithTool takes any openable object and a specific tool object of type KeyType.\n;; KeyType is an otype. Therefore, the tool object is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened; ?toolobject - object used to open.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is openable and not already opened, and the agent is holding the tool object.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (not (opened ?o))\n            (holds ?a ?toolobject)\n            (objectType ?toolobject KeyType)\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n", "\n;; Operator, OpenReceptacle.\n;; OpenReceptacle takes any openable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be opened.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is openable and not already opened.\n;; Postconditions: the ?r receptacle is now opened.\n(:action OpenReceptacle\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (not (opened ?r))\n        )\n        :effect (and\n            (opened ?r)\n        )\n)\n"]}, "CloseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CloseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CloseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CloseObjectNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (opened ?o)\n        )\n        :effect (and\n            (not (opened ?o))\n        )\n)\n", "\n(:action CloseObjectToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (opened ?o)\n            (holds ?a ?toolobject)\n            (toolToClose ?o ?toolobject)\n        )\n        :effect (and\n            (not (opened ?o))\n        )\n)\n", "\n(:action CloseObjectToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (opened ?o)\n            (holds ?a ?toolreceptacle)\n            (toolToClose ?o ?toolreceptacle)\n        )\n        :effect (and\n            (not (opened ?o))\n        )\n)\n"]}, "SliceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called SliceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different SliceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action SliceObject_toolobject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action SliceObject_toolreceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle DrawerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (openable ?toolreceptacle)\n            (opened ?toolreceptacle)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action SliceObject_no_tool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n"]}, "CoolObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CoolObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CoolObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CoolObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject IcePackType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n(:action CoolObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle FridgeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n(:action CoolObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n"]}, "WashObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WashObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WashObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action WashObjectWithSoapBottle\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject SoapBottleType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n(:action WashObjectWithSinkBasin\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SinkBasinType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n(:action WashObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n)\n"]}, "CutObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CutObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CutObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CutObject 1.\n;; CutObject takes an object to cut and a specific tool of type KnifeType.\n;; KnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cut; ?o - object to be cut, ?toolobject - object to cut with.\n;; Preconditions: The toolobject is a KnifeType, the agent is at a location and the object to be cut is at the same location, the object is cuttable, and the agent is holding the tool.\n;; Postconditions: The ?o object is now sliced.\n(:action CutObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cuttable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n;; Operator, CutObject 2.\n;; CutObject takes an object to cut and a specific tool of type ButterKnifeType.\n;; ButterKnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cut; ?o - object to be cut, ?toolobject - object to cut with.\n;; Preconditions: The toolobject is a ButterKnifeType, the agent is at a location and the object to be cut is at the same location, the object is cuttable, and the agent is holding the tool.\n;; Postconditions: The ?o object is now sliced.\n(:action CutObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cuttable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n;; Operator, CutObject 3.\n;; CutObject takes an object to cut and a specific tool of type KnifeType.\n;; KnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cut; ?o - object to be cut, ?toolreceptacle - receptacle to cut the object on.\n;; Preconditions: The toolreceptacle is a cutting board, the agent is at a location, the object to be cut is at the same location, and the agent is holding the object and the toolreceptacle is at the same location as the agent.\n;; Postconditions: The ?o object is now sliced.\n(:action CutObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle CuttingBoardType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cuttable ?o)\n            (holds ?a ?o)\n            (holds ?a ?toolreceptacle)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n"]}, "ChillObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ChillObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ChillObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ChillObject - Operator 1\n;; ChillObject takes an object to chill.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be chilled.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is coolable.\n;; Postconditions: the ?o object is now cool.\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n)\n", "\n;; Operator, ChillObject - Operator 2\n;; ChillObject takes an object to chill using a chill receptacle of type FridgeType.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be chilled, ?chillreceptacle - receptacle to chill the object in.\n;; Preconditions: The chillreceptacle is of type FridgeType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be chilled.\n;; Postconditions: the ?o object is now cool.\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object ?chillreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?chillreceptacle FridgeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?chillreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n", "\n;; Operator, ChillObject - Operator 3\n;; ChillObject takes an object to chill using a chill tool of type IcePackType.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be chilled, ?chilltool - tool to chill the object with.\n;; Preconditions: The chilltool is of type IcePackType, the agent is at a location and the object is at the same location, and the agent is holding the chilltool and the object to be chilled is coolable.\n;; Postconditions: the ?o object is now cool.\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object ?chilltool - object)\n        :precondition (and\n            (objectType ?chilltool IcePackType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n            (holds ?a ?chilltool)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n"]}, "GoToLocation": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GoToLocation.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GoToLocation operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action GoToLocation1\n      :parameters (?a - agent ?lStart1 - location ?lEnd1 - location)\n      :precondition (and\n          (atLocation ?a ?lStart1)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd1)\n          (not (atLocation ?a ?lStart1))\n      )\n  )\n", "\n(:action GoToLocation2\n      :parameters (?a - agent ?lStart2 - location ?lEnd2 - location)\n      :precondition (and\n          (atLocation ?a ?lStart2)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd2)\n          (not (atLocation ?a ?lStart2))\n      )\n  )\n", "\n(:action GoToLocation3\n      :parameters (?a - agent ?lStart3 - location ?lEnd3 - location)\n      :precondition (and\n          (atLocation ?a ?lStart3)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd3)\n          (not (atLocation ?a ?lStart3))\n      )\n  )\n"]}, "MicrowaveObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called MicrowaveObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different MicrowaveObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action MicrowaveObjectTool\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHeated ?o)\n        )\n    )\n", "\n(:action MicrowaveObjectNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (microwavable ?o)\n        )\n        :effect (and\n           (isHeated ?o)\n        )\n    )\n", "\n(:action MicrowaveObjectMicrowaveSafeTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MicrowaveSafeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (microwavable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n           (isHeated ?o)\n        )\n    )\n"]}, "HeatObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called HeatObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different HeatObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, HeatObject Option 1.\n;; HeatObject Option 1 takes an object to heat and a specific tool of type StoveBurnerType.\n;; StoveBurnerType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the tool; ?o - object to be heated, ?toolreceptacle - receptacle to heat the object on.\n;; Preconditions: The toolreceptacle is a StoveBurnerType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be heated.\n;; Postconditions: the ?o object is now hot.\n(:action HeatObjectOption1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, HeatObject Option 2.\n;; HeatObject Option 2 takes an object to heat and a specific tool of type MicrowaveType.\n;; MicrowaveType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the tool; ?o - object to be heated, ?toolreceptacle - receptacle to heat the object in.\n;; Preconditions: The toolreceptacle is a MicrowaveType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be heated.\n;; Postconditions: the ?o object is now hot.\n(:action HeatObjectOption2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, HeatObject Option 3.\n;; HeatObject Option 3 takes an object to heat without any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be heated.\n;; Preconditions: The agent is at a location and the object is at the same location, and the agent is holding the object to be heated.\n;; Postconditions: the ?o object is now hot.\n(:action HeatObjectOption3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}, "ThrowAwayObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowAwayObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowAwayObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ThrowAwayObject 1.\n;; ThrowAwayObject 1 takes any object to throw away.\n;; This action is applicable to any throwaway object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be thrown away.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is throwaway.\n;; Postconditions: The object is no longer at any location.\n(:action ThrowAwayObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwaway ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n)\n", "\n;; Operator, ThrowAwayObject 2.\n;; ThrowAwayObject 2 takes any object to throw away and a specific tool of type GarbageCanType.\n;; GarbageCanType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be thrown away, ?toolreceptacle - receptacle to throw the object in.\n;; Preconditions: The toolreceptacle is a GarbageCanType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be thrown away.\n;; Postconditions: The object is no longer at any location.\n(:action ThrowAwayObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle GarbageCanType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n        )\n)\n", "\n;; Operator, ThrowAwayObject 3.\n;; ThrowAwayObject 3 takes any object to throw away, a specific tool object of type TrashBagType, and a specific tool receptacle of type GarbageCanType.\n;; TrashBagType and GarbageCanType are objectTypes, so both the tool object and tool receptacle are objects.\n;; Parameters: ?a - agent, ?lTrashbag - location of the receptacle; ?lGarbageCan - location of the receptacle; ?o - object to be thrown away, ?trashbag - toolobject to hold the object, ?garbagecan - toolreceptacle to throw the object in.\n;; Preconditions: The trashbag object is TrashBagType, the garbagecan receptacle is GarbageCanType, the agent is at a location and both the trashbag and garbagecan are at the same location, the agent is holding the object to be thrown away.\n;; Postconditions: The object is no longer at any location.\n(:action ThrowAwayObject3\n        :parameters (?a - agent ?lTrashbag - location ?lGarbageCan - location ?o - object ?trashbag - object ?garbagecan - receptacle)\n        :precondition (and\n            (objectType ?trashbag TrashBagType)\n            (receptacleType ?garbagecan GarbageCanType)\n            (atLocation ?a ?lTrashbag)\n            (atLocation ?garbagecan ?lGarbageCan)\n            (objectAtLocation ?trashbag ?lTrashbag)\n            (receptacleAtLocation ?garbagecan ?lGarbageCan)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?lTrashbag))\n        )\n)\n"]}, "PlaceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PlaceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PlaceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action PlaceObjectOption1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle BowlType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (inReceptacle ?o ?toolreceptacle)\n        )\n    )\n", "\n(:action PlaceObjectOption2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject SpoonType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (atLocation ?o ?newLocation)\n        )\n    )\n", "\n(:action PlaceObjectOption3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (atLocation ?o ?newLocation)\n        )\n    )\n"]}, "WarmObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WarmObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WarmObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, WarmObject\n;; WarmObject takes an object to warm and a specific tool of type MicrowaveType.\n;; MicrowaveType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be warmed, ?toolreceptacle - receptacle to warm the object in.\n;; Preconditions: The toolreceptacle is a MicrowaveType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be warmed.\n;; Postconditions: the ?o object is now hot.\n(:action WarmObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, WarmObject\n;; WarmObject takes an object to warm and a specific tool of type HeatSource.\n;; HeatSource is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be warmed, ?toolreceptacle - receptacle to warm the object in.\n;; Preconditions: The toolreceptacle is a HeatSource, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be warmed.\n;; Postconditions: the ?o object is now hot.\n(:action WarmObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle HeatSourceType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, WarmObject\n;; WarmObject takes an object to warm and a specific tool of type HeatSourceObject.\n;; HeatSourceObject is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be warmed, ?toolobject - object to warm the object with.\n;; Preconditions: The toolobject is a HeatSourceObjectType, the agent is at a location and the object is at the same location, and the agent is holding the object to be warmed.\n;; Postconditions: the ?o object is now hot.\n(:action WarmObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject HeatSourceObjectType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}, "TakeObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TakeObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TakeObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TakeObject1.\n;; TakeObject1 takes an object to take.\n;; This action is applicable to any object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be taken.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: the agent is now holding the object.\n(:action TakeObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n    )\n", "\n;; Operator, TakeObject2.\n;; TakeObject2 takes an object to take and a tool object of type GraspingToolType.\n;; GraspingToolType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be taken, ?toolobject - object to grasp the object with.\n;; Preconditions: The toolobject is a GraspingToolType, the agent is at a location and the object to be taken is at the same location, and the agent is not already holding an object.\n;; Postconditions: the agent is now holding the object.\n(:action TakeObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraspingToolType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (not (holdsAny ?a))\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n    )\n", "\n;; Operator, TakeObject3.\n;; TakeObject3 takes an object to take and a tool object of type FingersType.\n;; FingersType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be taken, ?toolobject - object to grasp the object with.\n;; Preconditions: The toolobject is a FingersType, the agent is at a location and the object to be taken is at the same location, and the agent is not already holding an object.\n;; Postconditions: the agent is now holding the object.\n(:action TakeObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject FingersType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (not (holdsAny ?a))\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n    )\n"]}, "RinseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called RinseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different RinseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action RinseObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject SprayerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (rinsable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isRinsed ?o)\n        )\n    )\n", "\n(:action RinsePlate\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SinkBasinType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isRinsed ?o)\n        )\n    )\n", "\n(:action RinseBook\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle DeskType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isRinsed ?o)\n        )\n    )\n"]}, "LookAtObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookAtObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookAtObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, LookAtObject (Option 1)\n;; LookAtObject takes an object to look at and a specific tool of type MirrorType.\n;; MirrorType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be looked at, ?toolobject - object to use for looking.\n;; Preconditions: The toolobject is a MirrorType, the agent is at a location and the object to be looked at is at the same location, and the agent is holding the tool.\n;; Postconditions: None.\n(:action LookAtObject-1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MirrorType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and)\n    )\n", "\n;; Operator, LookAtObject (Option 2)\n;; LookAtObject takes an object to look at and a specific tool of type TelescopeType.\n;; TelescopeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be looked at, ?toolobject - object to use for looking.\n;; Preconditions: The toolobject is a TelescopeType, the agent is at a location and the object to be looked at is at the same location, and the agent is holding the tool.\n;; Postconditions: None.\n(:action LookAtObject-2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject TelescopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and)\n    )\n", "\n;; Operator, LookAtObject (Option 3)\n;; LookAtObject takes an object to look at and does not require any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be looked at.\n;; Preconditions: The agent is at a location and the object to be looked at is at the same location.\n;; Postconditions: None.\n(:action LookAtObject-3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and)\n    )\n"]}, "InspectObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called InspectObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different InspectObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action InspectObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (inspectable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isInspected ?o)\n        )\n    )\n", "\n(:action InspectObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (inspectable ?o)\n        )\n        :effect (and\n            (isInspected ?o)\n        )\n    )\n", "\n(:action InspectObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isInspected ?o)\n        )\n    )\n"]}, "ToastObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ToastObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ToastObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ToastObject.\n;; ToastObject takes an object to toast and a specific tool of type ToasterType.\n;; ToasterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the toaster; ?o - object to be toasted, ?toolobject - object to toast with.\n;; Preconditions: The toolobject is a ToasterType, the agent is at a location and the toaster is at the same location, the object is toastable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toastable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n    )\n", "\n;; Operator, ToastObject.\n;; ToastObject takes an object to toast and a specific tool object of type PanType.\n;; PanType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the pan; ?o - object to be toasted, ?toolobject - object to toast with.\n;; Preconditions: The toolobject is a PanType, the agent is at a location and the pan is at the same location, the object is toastable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject PanType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toastable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n    )\n", "\n;; Operator, ToastObject.\n;; ToastObject takes an object to toast and a specific tool receptacle of type StoveBurnerType.\n;; StoveBurnerType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the stove; ?o - object to be toasted, ?toolreceptacle - receptacle to toast with.\n;; Preconditions: The toolreceptacle is a StoveBurnerType, the agent is at a location and the stove is at the same location, the object is toastable, and the agent is holding the object to be toasted.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (toastable ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n    )\n"]}, "CookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CookObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject PanType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cookable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isCooked ?o)\n        )\n    )\n", "\n(:action CookObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCooked ?o)\n        )\n    )\n", "\n(:action CookObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cookable ?o)\n        )\n        :effect (and\n            (isCooked ?o)\n        )\n    )\n"]}, "UseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called UseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different UseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, UseObject - Option 1\n;; UseObject takes an object that can be used.\n;; This action is applicable to any object that can be used without any tools.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be used.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is usable.\n;; Postconditions: the ?o object is now used.\n(:action UseObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (usable ?o)\n        )\n        :effect (and\n            (isUsed ?o)\n        )\n)\n", "\n;; Operator, UseObject - Option 2\n;; UseObject takes an object and a specific tool object of certain types.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be used, ?toolobject - object to use the object with.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is usable, the agent is holding the toolobject, and the toolobject type is compatible with the object to be used.\n;; Postconditions: the ?o object is now used.\n(:action UseObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (usable ?o)\n            (holds ?a ?toolobject)\n            (compatibleToolObject ?o ?toolobject)\n        )\n        :effect (and\n            (isUsed ?o)\n        )\n)\n", "\n;; Operator, UseObject - Option 3\n;; UseObject takes an object and a specific tool receptacle of certain types.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be used, ?toolreceptacle - object to use the object with.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is usable, the agent is holding the toolreceptacle, and the toolreceptacle type is compatible with the object to be used.\n;; Postconditions: the ?o object is now used.\n(:action UseObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (usable ?o)\n            (holds ?a ?toolreceptacle)\n            (compatibleToolReceptacle ?o ?toolreceptacle)\n        )\n        :effect (and\n            (isUsed ?o)\n        )\n)\n"]}, "TurnOnLight": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnLight.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnLight operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TurnOnLight.\n;; TurnOnLight takes a light switch object of type LightSwitchType.\n;; Parameters: ?a - agent, ?l - location of the light switch; ?o - light switch object.\n;; Preconditions: The ?o light switch object is a LightSwitchType, the agent is at the location ?l, and the light switch is at the location ?l.\n;; Postconditions: The light switch is now turned on.\n(:action TurnOnLight\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (objectType ?o LightSwitchType)\n            (atLocation ?o ?l)\n            (atLocation ?a ?l)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n    )\n", "\n;; Operator, TurnOnLight.\n;; TurnOnLight takes a lamp object of type FloorLampType as a tool object.\n;; Parameters: ?a - agent, ?l - location of the lamp; ?o - lamp object; ?toolobject - floor lamp object.\n;; Preconditions: The ?o lamp object is a FloorLampType, the agent is at the location ?l, the lamp is at the location ?l, and the agent is holding the floor lamp.\n;; Postconditions: The ?o lamp object is now turned on.\n(:action TurnOnLight\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?o FloorLampType)\n            (atLocation ?o ?l)\n            (holds ?a ?toolobject)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n    )\n", "\n;; Operator, TurnOnLight.\n;; TurnOnLight takes a lamp object of type DeskLampType as a tool object and a table of type DeskType as a tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the lamp; ?o - lamp object; ?toolobject - desk lamp object; ?toolreceptacle - desk table object.\n;; Preconditions: The ?o lamp object is a DeskLampType, the agent is at the location ?l, the lamp is at the location ?l, the agent is holding the desk lamp, and the desk table is at the location ?l.\n;; Postconditions: The ?o lamp object is now turned on.\n(:action TurnOnLight\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - object)\n        :precondition (and\n            (objectType ?o DeskLampType)\n            (atLocation ?o ?l)\n            (receptacleType ?toolreceptacle DeskType)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?toolobject)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n    )\n"]}, "InvestigateObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called InvestigateObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different InvestigateObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, InvestigateObject without using any tool objects or tool receptacles.\n;; InvestigateObject takes any object to investigate.\n;; This action is applicable to any object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be investigated.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: the agent knows more information about the ?o object.\n(:action InvestigateObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (knowsMore ?a ?o)\n        )\n)\n", "\n;; Operator, InvestigateObject using a specific tool object of type MagnifyingGlassType.\n;; MagnifyingGlassType is an otype. Therefore, the tool object is an object.\n;; InvestigateObject takes any object to investigate.\n;; This action is applicable to any object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be investigated; ?toolobject - object to investigate with.\n;; Preconditions: The toolobject is a MagnifyingGlassType, the agent is at a location and the object is at the same location, and the agent is holding the tool.\n;; Postconditions: the agent knows more information about the ?o object.\n(:action InvestigateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (knowsMore ?a ?o)\n        )\n)\n", "\n;; Operator, InvestigateObject using a specific tool receptacle of type MicroscopeType.\n;; MicroscopeType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; InvestigateObject takes any object to investigate.\n;; This action is applicable to any object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be investigated; ?toolreceptacle - receptacle to investigate with.\n;; Preconditions: The toolreceptacle is a MicroscopeType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be investigated.\n;; Postconditions: the agent knows more information about the ?o object.\n(:action InvestigateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (knowsMore ?a ?o)\n        )\n)\n"]}, "DropObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called DropObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different DropObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action DropObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (atLocation ?o ?l)\n            (not (holds ?a ?o))\n        )\n    )\n", "\n(:action DropObjectInReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (receptacleAtLocation ?r ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n            (not (holds ?a ?o))\n        )\n    )\n", "\n(:action DropObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (atLocation ?o ?l)\n            (not (holds ?a ?o))\n            (not (holds ?a ?toolobject))\n        )\n    )\n"]}, "ThrowObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ThrowObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n            (throwable ?toolobject)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (thrown ?o)\n        )\n    )\n", "\n(:action ThrowObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n            (throwable ?toolreceptacle)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (thrown ?o)\n        )\n    )\n", "\n(:action ThrowObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (thrown ?o)\n        )\n    )\n"]}, "TurnOnLamp": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnLamp.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnLamp operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TurnOnLamp - Operator that turns on a lamp.\n;; TurnOnLamp takes a lamp object.\n;; Parameters: ?a - agent, ?l - location of the lamp, ?o - lamp object.\n;; Preconditions: The agent is at a location and the lamp is at the same location, and the lamp object is toggleable and off.\n;; Postconditions: The lamp object is on.\n(:action TurnOnLamp\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (isOff ?o)\n        )\n        :effect (and\n            (isOn ?o)\n        )\n)\n", "\n;; Operator, TurnOnLampWithSwitch - Operator that turns on a lamp using a switch.\n;; TurnOnLampWithSwitch takes a lamp object and a switch object.\n;; Parameters: ?a - agent, ?l - location of the lamp, ?o - lamp object, ?switch - switch object.\n;; Preconditions: The agent is at a location and the lamp and switch are at the same location, and the lamp object is toggleable and off, and the switch object is toggleable and off.\n;; Postconditions: The lamp object is on, and the switch object is toggled.\n(:action TurnOnLampWithSwitch\n        :parameters (?a - agent ?l - location ?o - object ?switch - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectAtLocation ?switch ?l)\n            (toggleable ?o)\n            (isOff ?o)\n            (toggleable ?switch)\n            (isOff ?switch)\n        )\n        :effect (and\n            (isOn ?o)\n            (isToggled ?switch)\n        )\n)\n", "\n;; Operator, TurnOnLampWithBulb - Operator that turns on a lamp using a bulb.\n;; TurnOnLampWithBulb takes a lamp object and a bulb object.\n;; Parameters: ?a - agent, ?l - location of the lamp, ?o - lamp object, ?bulb - bulb object.\n;; Preconditions: The agent is at a location and the lamp and bulb are at the same location, and the lamp object is toggleable and off, and the bulb object is toggleable and off.\n;; Postconditions: The lamp object is on, and the bulb object is toggled.\n(:action TurnOnLampWithBulb\n        :parameters (?a - agent ?l - location ?o - object ?bulb - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectAtLocation ?bulb ?l)\n            (toggleable ?o)\n            (isOff ?o)\n            (toggleable ?bulb)\n            (isOff ?bulb)\n        )\n        :effect (and\n            (isOn ?o)\n            (isToggled ?bulb)\n        )\n)\n"]}}