{"TurnOnObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject LightSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToggled ?o)\n        )\n    )\n", "\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject CDType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToggled ?o)\n        )\n    )\n", "\n(:action TurnOnObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject BaseballBatType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToggled ?o)\n        )\n    )\n"]}, "GetObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GetObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GetObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action GetObjectNoTool\n      :parameters (?a - agent ?l - location ?o - object)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (not (isGrated ?o))\n          (not (isHot ?o))\n          (not (isSliced ?o))\n          (not (holdsAny ?a))\n      )\n      :effect (and\n          (holds ?a ?o)\n          (not (objectAtLocation ?o ?l))\n      )\n  )\n", "\n(:action GetObjectWithToolObject\n      :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (not (isGrated ?o))\n          (not (isHot ?o))\n          (not (isSliced ?o))\n          (not (holdsAny ?a))\n          (holds ?a ?toolobject)\n      )\n      :effect (and\n          (holds ?a ?o)\n          (not (objectAtLocation ?o ?l))\n      )\n  )\n", "\n(:action GetObjectWithToolReceptacle\n      :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n      :precondition (and\n          (atLocation ?a ?l)\n          (objectAtLocation ?o ?l)\n          (not (isGrated ?o))\n          (not (isHot ?o))\n          (not (isSliced ?o))\n          (not (holdsAny ?a))\n          (holds ?a ?toolreceptacle)\n      )\n      :effect (and\n          (holds ?a ?o)\n          (not (objectAtLocation ?o ?l))\n      )\n  )\n"]}, "CutObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CutObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CutObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CutObject.\n;; CutObject takes an object to cut and a specific tool of type KnifeType.\n;; KnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cut; ?o - object to be cut, ?toolobject - object to cut with.\n;; Preconditions: The toolobject is a KnifeType, the agent is at a location and the object to be cut is at the same location, the object is sliceable, and the agent is holding the tool.\n;; Postconditions: the ?o object is sliced.\n(:action CutObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n;; Operator, CutObject.\n;; CutObject takes an object to cut and a specific tool of type ButterKnifeType.\n;; ButterKnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be cut; ?o - object to be cut, ?toolobject - object to cut with.\n;; Preconditions: The toolobject is a ButterKnifeType, the agent is at a location and the object to be cut is at the same location, the object is sliceable, and the agent is holding the tool.\n;; Postconditions: the ?o object is sliced.\n(:action CutObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n;; Operator, CutObject.\n;; CutObject takes an object to cut, but does not require a tool.\n;; Parameters: ?a - agent, ?l - location of object to be cut; ?o - object to be cut.\n;; Preconditions: The agent is at a location and the object to be cut is at the same location, the object is sliceable.\n;; Postconditions: the ?o object is sliced.\n(:action CutObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n"]}, "SliceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called SliceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different SliceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, SliceObject.\n;; SliceObject takes an object to slice and a specific tool of type KnifeType.\n;; KnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be sliced; ?o - object to be sliced, ?toolobject - object to slice with.\n;; Preconditions: The toolobject is a KnifeType, the agent is at a location and the object to be sliced is at the same location, the object is sliceable, and the agent is holding the tool.\n;; Postconditions: the ?o object is sliced.\n(:action SliceObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n;; Operator, SliceObject.\n;; SliceObject takes an object to slice and a specific tool of type ButterKnifeType.\n;; ButterKnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be sliced; ?o - object to be sliced, ?toolobject - object to slice with.\n;; Preconditions: The toolobject is a ButterKnifeType, the agent is at a location and the object to be sliced is at the same location, the object is sliceable, and the agent is holding the tool.\n;; Postconditions: the ?o object is sliced.\n(:action SliceObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n;; Operator, SliceObject.\n;; SliceObject takes an object to slice and a specific tool of type BreadType.\n;; BreadType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the tool; ?o - object to be sliced, ?toolreceptacle - receptacle to slice the object with.\n;; Preconditions: The toolreceptacle is a BreadType, the agent is at a location and the object to be sliced is at the same location, the object is sliceable, and the agent is holding the tool.\n;; Postconditions: the ?o object is sliced.\n(:action SliceObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle BreadType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolreceptacle)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n"]}, "ToastObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ToastObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ToastObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ToastObject. Option 1\n;; ToastObject takes an object to toast and a specific tool of type ToasterType.\n;; ToasterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be toasted; ?o - object to be toasted, ?toolobject - object to toast with.\n;; Preconditions: The toolobject is a ToasterType, the agent is at a location and the object to be toasted is at the same location, and the agent is holding the tool.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObjectOption1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n    )\n", "\n;; Operator, ToastObject. Option 2\n;; ToastObject takes an object to toast and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be toasted, ?toolreceptacle - receptacle to toast the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be toasted.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObjectOption2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n    )\n", "\n;; Operator, ToastObject. Option 3\n;; ToastObject takes an object to toast without the use of any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be toasted.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: the ?o object is now toasted.\n(:action ToastObjectOption3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n    )\n"]}, "HeatObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called HeatObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different HeatObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action HeatObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KettleType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n(:action HeatObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n", "\n(:action HeatObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (heatable ?o)\n        )\n        :effect (and\n            (isHot ?o)\n        )\n    )\n"]}, "CleanObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CleanObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CleanObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CleanObjectWithToolObject\n        :parameters (?a - agent ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ScrubBrushType)\n            (holds ?a ?toolobject)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n(:action CleanObjectWithToolReceptacle\n        :parameters (?a - agent ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SinkType)\n            (holds ?a ?o)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n(:action CleanObjectWithoutTools\n        :parameters (?a - agent ?o - object)\n        :precondition (and\n            (holds ?a ?o)\n            (cleanable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n"]}, "ChillObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ChillObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ChillObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ChillObject - using a Tool Object and a Tool Receptacle\n;; ChillObject takes an object to chill, a specific tool object of type FreezerType, and a specific tool receptacle of type BowlType.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be chilled, ?toolobject - object to chill with, ?toolreceptacle - receptacle to chill the object in.\n;; Preconditions: The toolobject is a FreezerType, the toolreceptacle is a BowlType, the agent is at a location and the receptacle is at the same location, the receptacle is open, the object is coolable, and the agent is holding both the tool object and the tool receptacle.\n;; Postconditions: the ?o object is now cool.\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (objectType ?toolobject FreezerType)\n            (receptacleType ?toolreceptacle BowlType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (openable ?toolreceptacle)\n            (opened ?toolreceptacle)\n            (coolable ?o)\n            (holds ?a ?toolobject)\n            (holds ?a ?toolreceptacle)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n;; Operator, ChillObject - using a Tool Object only\n;; ChillObject takes an object to chill and a specific tool object of type FreezerType.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be chilled, ?toolobject - object to chill with.\n;; Preconditions: The toolobject is a FreezerType, the agent is at a location and the object is at the same location, the object is coolable, and the agent is holding the tool object.\n;; Postconditions: the ?o object is now cool.\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject FreezerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n;; Operator, ChillObject - without using any Tools\n;; ChillObject takes an object to chill.\n;; This action does not require any tool objects or tool receptacles.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be chilled.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is coolable.\n;; Postconditions: the ?o object is now cool.\n(:action ChillObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n"]}, "ThrowObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ThrowObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject BaseballBatType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (not (holds ?a ?o))\n        )\n)\n", "\n(:action ThrowObject2\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (not (holds ?a ?o))\n        )\n)\n", "\n(:action ThrowObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle GarbageCanType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (objectAtLocation ?o ?l))\n            (inReceptacle ?o ?toolreceptacle)\n        )\n)\n"]}, "WarmObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WarmObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WarmObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action WarmObjectUsingToolObject\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (objectType ?toolobject ToasterType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (heatable ?o)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (isHot ?o)\n    )\n)\n", "\n(:action WarmObjectUsingToolReceptacle\n    :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (receptacleType ?toolreceptacle OvenType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (holds ?a ?o)\n    )\n    :effect (and\n        (isHot ?o)\n    )\n)\n", "\n(:action WarmObjectWithoutTools\n    :parameters (?a - agent ?l - location ?o - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (heatable ?o)\n    )\n    :effect (and\n        (isHot ?o)\n    )\n)\n"]}, "OpenObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called OpenObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different OpenObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, OpenObject.\n;; OpenObject takes any object to open.\n;; This action is applicable to any openable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is openable.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n", "\n;; Operator, OpenObjectWithTool.\n;; OpenObjectWithTool takes any object to open and a specific tool of type ButterKnifeType.\n;; ButterKnifeType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened, ?toolobject - object to open with.\n;; Preconditions: The toolobject is a ButterKnifeType, the agent is at a location and the object to be opened is at the same location, the object is openable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n", "\n;; Operator, OpenObjectWithReceptacle.\n;; OpenObjectWithReceptacle takes any object to open and a specific tool of type SafeType.\n;; SafeType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be opened, ?toolreceptacle - receptacle to open with.\n;; Preconditions: The toolreceptacle is a SafeType, the agent is at a location and the object to be opened is at the same location, the object is openable, and the agent is holding the tool.\n;; Postconditions: the ?o object is now opened.\n(:action OpenObjectWithReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SafeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (holds ?a ?toolreceptacle)\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n"]}, "CloseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CloseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CloseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CloseBox.\n;; CloseBox takes a box object and closes it.\n;; The box object must be sliceable.\n;; Parameters: ?a - agent, ?l - location of the box object; ?o - box object to be closed.\n;; Preconditions: The agent is at a location and the box object is at the same location, and the box is sliceable.\n;; Postconditions: the ?o box object is closed.\n(:action CloseBox\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (not (isSliced ?o))\n        )\n)\n", "\n;; Operator, CloseCabinet.\n;; CloseCabinet takes a cabinet receptacle and closes it.\n;; The cabinet receptacle must be openable and opened.\n;; Parameters: ?a - agent, ?l - location of the cabinet receptacle; ?r - cabinet receptacle to be closed.\n;; Preconditions: The agent is at a location and the cabinet receptacle is at the same location, the cabinet receptacle is openable, and the cabinet receptacle is opened.\n;; Postconditions: the ?r cabinet receptacle is closed.\n(:action CloseCabinet\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n)\n", "\n;; Operator, CloseRefrigerator.\n;; CloseRefrigerator takes a refrigerator receptacle and closes it.\n;; The refrigerator receptacle must be openable and opened.\n;; Parameters: ?a - agent, ?l - location of the refrigerator receptacle; ?r - refrigerator receptacle to be closed.\n;; Preconditions: The agent is at a location and the refrigerator receptacle is at the same location, the refrigerator receptacle is openable, and the refrigerator receptacle is opened.\n;; Postconditions: the ?r refrigerator receptacle is closed.\n(:action CloseRefrigerator\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (opened ?r)\n        )\n        :effect (and\n            (not (opened ?r))\n        )\n)\n"]}, "MicrowaveObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        GraterType - otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n        (fillable ?r - receptacle)\n        (isFilled ?r - receptacle) \n\t    (openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object)\n        (restartable ?o - object)\n        (isRestarted ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object)  \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object)\n        (gratable ?o - object)\n        (isGrated ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called MicrowaveObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different MicrowaveObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, MicrowaveObject. Option 1.\n;; MicrowaveObject takes an object to microwave and a specific tool of type MicrowaveType.\n;; MicrowaveType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be microwaved, ?toolreceptacle - receptacle to microwave the object in.\n;; Preconditions: The toolreceptacle is a MicrowaveType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be microwaved.\n;; Postconditions: the ?o object is now hot.\n(:action MicrowaveObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, MicrowaveObject. Option 2.\n;; MicrowaveObject takes an object to microwave and does not require a tool object or a tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be microwaved.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: the ?o object is now hot.\n(:action MicrowaveObject2\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, MicrowaveObject. Option 3.\n;; MicrowaveObject takes an object to microwave and a specific tool of type MicrowaveType. \n;; The tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be microwaved, ?toolobject - object to microwave the object with.\n;; Preconditions: The toolobject is a MicrowaveType, the agent is at a location and the object is at the same location, the agent is holding the object to be microwaved, and the object is coolable.\n;; Postconditions: the ?o object is now hot.\n(:action MicrowaveObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MicrowaveType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (coolable ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}}