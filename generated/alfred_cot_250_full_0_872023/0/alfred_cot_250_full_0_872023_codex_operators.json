{"LookAtObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookAtObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookAtObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LookAtObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            ;; No effect\n        )\n)\n"]}, "ExamineObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ExamineObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ExamineObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ExamineObject (Option 1)\n;; ExamineObject takes an object to examine and a tool of type HandheldMagnifierType.\n;; HandheldMagnifierType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolobject - object to examine with.\n;; Preconditions: The toolobject is a HandheldMagnifierType, the agent is at a location and the tool object is at the same location, and the agent is holding the object to be examined.\n;; Postconditions: none\n(:action ExamineObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject HandheldMagnifierType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            ; add any desired effect here\n        )\n)\n", "\n;; Operator, ExamineObject (Option 2)\n;; ExamineObject takes an object to examine and a tool receptacle of type MicroscopeType.\n;; MicroscopeType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined, ?toolreceptacle - receptacle with microscope to examine with.\n;; Preconditions: The toolreceptacle is a MicroscopeType, the agent is at a location and the tool receptacle is at the same location, and the agent is holding the object to be examined.\n;; Postconditions: none\n(:action ExamineObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            ; add any desired effect here\n        )\n)\n", "\n;; Operator, ExamineObject (Option 3)\n;; ExamineObject takes an object to examine.\n;; This action doesn't require any specific tool objects or tool receptacles.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be examined.\n;; Preconditions: The agent is at a location and the object is at the same location, and the agent is holding the object to be examined.\n;; Postconditions: none\n(:action ExamineObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            ; add any desired effect here\n        )\n)\n"]}, "LookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called LookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different LookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action LookObject\n    :parameters (?a - agent ?l - location ?o - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (lookable ?o)\n    )\n    :effect (and\n        (hasLookedAt ?a ?o)\n    )\n)\n", "\n(:action LookObjectWithMagnifyingGlass\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (lookable ?o)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (hasLookedAt ?a ?o)\n    )\n)\n", "\n(:action LookObjectFromDistance\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (lookable ?o)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (hasLookedAt ?a ?o)\n    )\n)\n"]}, "PickupObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PickupObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PickupObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action PickupObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (pickable ?o)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n", "\n(:action PickupObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject HandyToolType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (pickable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n", "\n(:action PickupObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle HandyToolReceptacleType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (pickable ?o)\n            (holds ?a ?toolreceptacle)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n"]}, "PutObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PutObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PutObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, PutObject.\n;; PutObject takes an object to put and a specific receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be put, ?r - receptacle to put the object in.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the agent is holding the object to be put.\n;; Postconditions: the ?o object is now in the ?r receptacle.\n(:action PutObject\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n    )\n", "\n;; Operator, PutObjectWithTool.\n;; PutObjectWithTool takes an object to put, a tool object of specific type, and a specific receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be put, ?toolobject - tool to use for putting, ?r - receptacle to put the object in.\n;; Preconditions: The toolobject is a valid tool type, the agent is at a location and the receptacle is at the same location, the agent is holding the object to be put, and the agent is holding the toolobject. \n;; Postconditions: the ?o object is now in the ?r receptacle.\n(:action PutObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?r - receptacle)\n        :precondition (and\n            (objectType ?toolobject ?toolType) ; change ?toolType to the specific tool type\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (holds ?a ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n    )\n", "\n;; Operator, PutObjectWithToolReceptacle.\n;; PutObjectWithToolReceptacle takes an object to put, a specific tool receptacle, and a specific receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacles; ?o - object to be put, ?toolreceptacle - tool receptacle to use for putting, ?r - receptacle to put the object in.\n;; Preconditions: The toolreceptacle is a valid tool receptacle type, the agent is at a location and both receptacles are at the same location, the agent is holding the object to be put, and the toolreceptacle is opened and the agent can hold the tool object.\n;; Postconditions: the ?o object is now in the ?r receptacle.\n(:action PutObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle ?r - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle ?toolReceptacleType) ; change ?toolReceptacleType to the specific tool receptacle type\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (receptacleAtLocation ?r ?l)\n            (holds ?a ?o)\n            (opened ?toolreceptacle)\n            (canHold ?a ?toolreceptacle ?toolobject) ; ?toolobject is the object in the toolreceptacle\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n    )\n"]}, "CutObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CutObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CutObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CutObjectWithKnife\n        :parameters (?a - agent ?l - location ?o - object ?knife - object)\n        :precondition (and\n            (objectType ?knife KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?knife)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action CutObjectWithScissors\n        :parameters (?a - agent ?l - location ?o - object ?scissors - object)\n        :precondition (and\n            (objectType ?scissors ScissorsType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?scissors)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action CutObjectWithoutTools\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n"]}, "UseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called UseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different UseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action UseObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (usable ?o)\n        )\n        :effect (and\n            (isUsed ?o)\n        )\n)\n", "\n(:action UseObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (usableWith ?o ?toolobject)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isUsed ?o)\n        )\n)\n", "\n(:action UseObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (usableWith ?o ?toolreceptacle)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (opened ?toolreceptacle)\n            (empty ?toolreceptacle)\n        )\n        :effect (and\n            (isUsed ?o)\n        )\n)\n"]}, "TurnOnObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TurnOnObject.\n;; TurnOnObject takes any object to turn on. The object may or may not require a tool object or a tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be turned on; ?toolobject - optional tool object; ?toolreceptacle - optional tool receptacle.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is toggleable, and the agent either holds the required tool object or the required tool receptacle is at the same location.\n;; Postconditions: the ?o object is now turned on.\n(:action TurnOnObject\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (toggleable ?o)\n        (or\n            (holds ?a ?toolobject)\n            (and\n                (receptacleAtLocation ?toolreceptacle ?l)\n                (receptacleType ?toolreceptacle ToolType)\n            )\n        )\n    )\n    :effect (and\n        (isOn ?o)\n    )\n)\n", "\n;; Operator, TurnOnObjectWithToolObject.\n;; TurnOnObjectWithToolObject takes any object to turn on, plus a specific tool object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be turned on; ?toolobject - object to turn on the object with.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is toggleable, and the agent holds the required tool object.\n;; Postconditions: the ?o object is now turned on.\n(:action TurnOnObjectWithToolObject\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (toggleable ?o)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (isOn ?o)\n    )\n)\n", "\n;; Operator, TurnOnObjectWithToolReceptacle.\n;; TurnOnObjectWithToolReceptacle takes any object to turn on, plus a specific tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be turned on; ?toolreceptacle - receptacle to turn on the object with.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is toggleable, and the required tool receptacle is at the same location.\n;; Postconditions: the ?o object is now turned on.\n(:action TurnOnObjectWithToolReceptacle\n    :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (toggleable ?o)\n        (receptacleAtLocation ?toolreceptacle ?l)\n        (receptacleType ?toolreceptacle ToolType)\n    )\n    :effect (and\n        (isOn ?o)\n    )\n)\n"]}, "TurnOffObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOffObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOffObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOffObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (isOn ?o)\n        )\n        :effect (and\n            (not (isOn ?o))\n        )\n)\n", "\n(:action TurnOffObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject SwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toggleable ?o)\n            (isOn ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (not (isOn ?o))\n        )\n)\n", "\n(:action TurnOffObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle LightSwitchBoxType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (toggleable ?o)\n            (isOn ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (not (isOn ?o))\n        )\n)\n"]}, "CoolObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CoolObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CoolObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CoolObject.\n;; CoolObject takes an object to be cooled and a specific tool of type IceChestType.\n;; IceChestType is a rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be cooled, ?toolreceptacle - receptacle to cool the object in.\n;; Preconditions: The toolreceptacle is an IceChestType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be cooled.\n;; Postconditions: the ?o object is now cool.\n(:action CoolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle IceChestType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCool ?o)\n        )\n    )\n", "\n;; Operator, CoolObject.\n;; CoolObject takes an object to be cooled and a specific tool of type FanType.\n;; FanType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object to be cooled; ?o - object to be cooled, ?toolobject - object to cool the object with.\n;; Preconditions: The toolobject is a FanType, the agent is at a location and the object to be cooled is at the same location, and the agent is holding the tool.\n;; Postconditions: the ?o object is now cool.\n(:action CoolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject FanType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n;; Operator, CoolObject.\n;; CoolObject takes an object to be cooled, but does not require a specific tool.\n;; Parameters: ?a - agent, ?l - location of the object to be cooled; ?o - object to be cooled.\n;; Preconditions: The agent is at a location and the object to be cooled is at the same location.\n;; Postconditions: the ?o object is now cool.\n(:action CoolObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n"]}, "OpenObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called OpenObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different OpenObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action OpenObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n", "\n(:action OpenObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle DrawerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (not (opened ?toolreceptacle))\n        )\n        :effect (and\n            (opened ?o)\n            (opened ?toolreceptacle)\n        )\n)\n", "\n(:action OpenObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (openable ?o)\n        )\n        :effect (and\n            (opened ?o)\n        )\n)\n"]}, "CloseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CloseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CloseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CloseObjectUsingTool\n    :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n    :precondition (and\n        (objectType ?toolobject ContainerType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (openable ?o)\n        (opened ?o)\n        (holds ?a ?toolobject)\n    )\n    :effect (and\n        (not (opened ?o))\n    )\n)\n", "\n(:action CloseObjectUsingReceptacle\n    :parameters (?a - agent ?l - location ?o - object ?receptacle - receptacle)\n    :precondition (and\n        (receptacleType ?receptacle LidType)\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (openable ?o)\n        (opened ?o)\n        (holds ?a ?receptacle)\n    )\n    :effect (and\n        (not (opened ?o))\n    )\n)\n", "\n(:action CloseObjectNoTool\n    :parameters (?a - agent ?l - location ?o - object)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?o ?l)\n        (openable ?o)\n        (opened ?o)\n    )\n    :effect (and\n        (not (opened ?o))\n    )\n)\n"]}, "CookObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CookObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CookObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CookObject (Option 1)\n;; CookObject takes an object to be cooked and a specific tool of type StoveType.\n;; StoveType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be cooked, ?toolreceptacle - receptacle to cook the object on.\n;; Preconditions: The toolreceptacle is a StoveType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be cooked.\n;; Postconditions: the ?o object is now cooked.\n(:action CookObjectOption1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCooked ?o)\n        )\n    )\n", "\n;; Operator, CookObject (Option 2)\n;; CookObject takes an object to be cooked and a specific tool of type MicrowaveType.\n;; MicrowaveType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be cooked, ?toolreceptacle - receptacle to cook the object in.\n;; Preconditions: The toolreceptacle is a MicrowaveType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be cooked.\n;; Postconditions: the ?o object is now cooked.\n(:action CookObjectOption2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCooked ?o)\n        )\n    )\n", "\n;; Operator, CookObject (Option 3)\n;; CookObject takes an object to be cooked and a specific tool of type GrillType.\n;; GrillType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be cooked, ?toolreceptacle - receptacle to cook the object on.\n;; Preconditions: The toolreceptacle is a GrillType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be cooked.\n;; Postconditions: the ?o object is now cooked.\n(:action CookObjectOption3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle GrillType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isCooked ?o)\n        )\n    )\n"]}, "EmptyObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called EmptyObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different EmptyObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action EmptyObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject EmptyingToolType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (emptyable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isEmpty ?o)\n        )\n    )\n", "\n(:action EmptyContainer\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (emptyable ?r)\n        )\n        :effect (and\n            (isEmpty ?r)\n        )\n    )\n", "\n(:action ClearObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (clearable ?o)\n        )\n        :effect (and\n            (isClear ?o)\n        )\n)\n"]}, "MicrowaveObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called MicrowaveObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different MicrowaveObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action MicrowaveObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicrowaveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action MicrowaveObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MugType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n(:action MicrowaveObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}, "HeatObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called HeatObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different HeatObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, HeatObject with a HotPlateTool\n;; HeatObject takes an object to be heated and a specific tool of type HotPlateType.\n;; HotPlateType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be heated, ?toolreceptacle - receptacle to heat the object with.\n;; Preconditions: The toolreceptacle is a HotPlateType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be heated.\n;; Postconditions: the ?o object is now hot.\n(:action HeatObjectWithHotPlate\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle HotPlateType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, HeatObject with a StoveTool\n;; HeatObject takes an object to be heated and a specific tool of type StoveType.\n;; StoveType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be heated, ?toolreceptacle - receptacle to heat the object with.\n;; Preconditions: The toolreceptacle is a StoveType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be heated.\n;; Postconditions: the ?o object is now hot.\n(:action HeatObjectWithStove\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n", "\n;; Operator, HeatObject with NoTool\n;; HeatObject takes an object to be heated and does not require any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be heated.\n;; Preconditions: The agent is at a location and the object is at the same location,\n;; Postconditions: the ?o object is now hot.\n(:action HeatObjectWithNoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n"]}, "SliceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called SliceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different SliceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action SliceObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject KnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action SliceObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ButterKnifeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n    )\n", "\n(:action SliceObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (sliceable ?o)\n        )\n        :effect (and\n            (isSliced ?o)\n        )\n)\n"]}, "WashObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WashObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WashObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, WashObject (Option 1)\n;; WashObject takes an object to wash and a specific tool of type ScrubBrushType.\n;; ScrubBrushType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object to wash; ?o - object to be washed, ?toolobject - object to wash with.\n;; Preconditions: The toolobject is a ScrubBrushType, the agent is at a location and the object to be washed is at the same location, the object is washable, and the agent is holding the tool.\n;; Postconditions: the ?o object is clean.\n(:action WashObjectOption1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ScrubBrushType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (washable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n;; Operator, WashObject (Option 2)\n;; WashObject takes an object to wash and a specific tool receptacle of type SinkBasinType.\n;; SinkBasinType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the tool receptacle; ?o - object to be washed, ?toolreceptacle - tool receptacle to wash the object in.\n;; Preconditions: The toolreceptacle is a SinkBasinType, the agent is at a location and the tool receptacle is at the same location, and the agent is holding the object to be washed.\n;; Postconditions: the ?o object is now clean.\n(:action WashObjectOption2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle SinkBasinType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n;; Operator, WashObject (Option 3)\n;; WashObject takes an object to wash, but does not require any specific tool.\n;; Parameters: ?a - agent, ?l - location of the object to wash; ?o - object to be washed.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is washable.\n;; Postconditions: the ?o object is now clean.\n(:action WashObjectOption3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (washable ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n"]}, "PlaceObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PlaceObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PlaceObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, PlaceCandle.\n;; PlaceCandle takes a candle object and a specific receptacle of type CandleHolderType to place the candle.\n;; Parameters: ?a - agent, ?l - location of the candle and the receptacle; ?candle - candle object to be placed, ?holder - specific receptacle of type CandleHolderType to place the candle.\n;; Preconditions: The agent is at a location and the candle and receptacle are at the same location, the agent is holding the candle, the receptacle is of type CandleHolderType, and the receptacle is empty.\n;; Postconditions: The candle object is now in the receptacle and the receptacle is no longer empty.\n(:action PlaceCandle\n    :parameters (?a - agent ?l - location ?candle - object ?holder - receptacle)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?candle ?l)\n        (receptacleAtLocation ?holder ?l)\n        (objectType ?candle CandleType)\n        (receptacleType ?holder CandleHolderType)\n        (holds ?a ?candle)\n        (empty ?holder)\n    )\n    :effect (and\n        (inReceptacle ?candle ?holder)\n        (not (empty ?holder))\n    )\n)\n", "\n(:action PlaceBook\n    :parameters (?a - agent ?l - location ?book - object ?shelf - receptacle)\n    :precondition (and\n        (atLocation ?a ?l)\n        (objectAtLocation ?book ?l)\n        (receptacleAtLocation ?shelf ?l)\n        (objectType ?book BookType)\n        (receptacleType ?shelf BookshelfType)\n        (holds ?a ?book)\n        (empty ?shelf)\n    )\n    :effect (and\n        (inReceptacle ?book ?shelf)\n        (not (empty ?shelf))\n    )\n)\n"]}, "WarmObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called WarmObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different WarmObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, WarmObject.\n;; WarmObject takes any object to warm.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be warmed.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is warmable.\n;; Postconditions: the ?o object is now warm.\n;; This operator does not require any tool objects or tool receptacles.\n(:action WarmObjectOption1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (warmable ?o)\n        )\n        :effect (and\n            (isWarm ?o)\n        )\n)\n", "\n;; Operator, WarmObject.\n;; WarmObject takes any object to warm.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be warmed.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is warmable.\n;; Postconditions: the ?o object is now warm, and the agent is holding the object.\n;; This operator requires the agent to hold the object while warming it.\n(:action WarmObjectOption2\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (warmable ?o)\n            (not (holds ?a ?o)) ; Agent does not currently hold the object\n        )\n        :effect (and\n            (isWarm ?o)\n            (holds ?a ?o)\n        )\n)\n", "\n;; Operator, WarmObject.\n;; WarmObject takes any object to warm.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be warmed; ?toolobject - reusable object to warm with.\n;; Preconditions: The agent is at a location and the object is at the same location, the object is warmable, the toolobject is a ReusableType, the agent is holding the toolobject, and the object is not already warm.\n;; Postconditions: the ?o object is now warm.\n;; This operator requires the use of a reusable object to warm the other object.\n(:action WarmObjectOption3\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (warmable ?o)\n            (objectType ?toolobject ReusableType)\n            (holds ?a ?toolobject)\n            (not (isWarm ?o))\n        )\n        :effect (and\n            (isWarm ?o)\n        )\n)\n"]}, "GoToObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GoToObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GoToObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, GoToBook\n;; GoToBook takes an agent and a book to go to.\n;; This action is applicable to any book object.\n;; Parameters: ?a - agent, ?lStart - start location; ?lBook - location of the book.\n;; Preconditions: The agent is at the start location and the book is at the location specified.\n;; Postconditions: The agent is at the location of the book.\n(:action GoToBook\n    :parameters (?a - agent ?lStart - location ?lBook - location)\n    :precondition (and\n        (atLocation ?a ?lStart)\n        (objectType ?o BookType)\n        (objectAtLocation ?o ?lBook)\n    )\n    :effect (and\n        (atLocation ?a ?lBook)\n    )\n)\n", "\n;; Operator, GoToCabinet\n;; GoToCabinet takes an agent and a cabinet to go to.\n;; This action is applicable to any cabinet receptacle.\n;; Parameters: ?a - agent, ?lStart - start location; ?lCabinet - location of the cabinet; ?r - cabinet receptacle.\n;; Preconditions: The agent is at the start location and the cabinet is at the location specified.\n;; Postconditions: The agent is at the location of the cabinet and the cabinet is opened.\n(:action GoToCabinet\n    :parameters (?a - agent ?lStart - location ?lCabinet - location ?r - receptacle)\n    :precondition (and\n        (atLocation ?a ?lStart)\n        (receptacleType ?r CabinetType)\n        (receptacleAtLocation ?r ?lCabinet)\n        (opened ?r)\n    )\n    :effect (and\n        (atLocation ?a ?lCabinet)\n    )\n)\n", "\n;; Operator, GoToBed\n;; GoToBed takes an agent and a bed to go to.\n;; This action is applicable to any bed receptacle.\n;; Parameters: ?a - agent, ?lStart - start location; ?lBed - location of the bed; ?r - bed receptacle.\n;; Preconditions: The agent is at the start location and the bed is at the location specified.\n;; Postconditions: The agent is at the location of the bed and the bed is opened.\n(:action GoToBed\n    :parameters (?a - agent ?lStart - location ?lBed - location ?r - receptacle)\n    :precondition (and\n        (atLocation ?a ?lStart)\n        (receptacleType ?r BedType)\n        (receptacleAtLocation ?r ?lBed)\n        (opened ?r)\n    )\n    :effect (and\n        (atLocation ?a ?lBed)\n    )\n)\n"]}, "ChillObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ChillObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ChillObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ChillObjectOption1\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle FreezerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n(:action ChillObjectOption2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject IceCubeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n", "\n(:action ChillObjectOption3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (isCool ?o)\n        )\n    )\n"]}, "GetObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called GetObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different GetObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, GetObject with Tool Object\n;; GetObject takes an object to get and a specific tool of type TowelType.\n;; TowelType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be obtained, ?toolobject - object to use for obtaining.\n;; Preconditions: The toolobject is a TowelType, the agent is at a location and the object to be obtained is at the same location, and the agent is not holding the object.\n;; Postconditions: the ?o object is now held by the agent.\n(:action GetObjectWithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject TowelType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (not (holds ?a ?o))\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n", "\n;; Operator, GetObject with Tool Receptacle\n;; GetObject takes an object to get and a specific tool of type DrawerType.\n;; DrawerType is an rtype. Therefore, the tool is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be obtained, ?toolreceptacle - receptacle to use for obtaining.\n;; Preconditions: The toolreceptacle is a DrawerType, the agent is at a location and the object to be obtained is at the same location, and the agent is not holding the object.\n;; Postconditions: the ?o object is now held by the agent.\n(:action GetObjectWithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle DrawerType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (not (holds ?a ?o))\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n", "\n;; Operator, GetObject without Tool\n;; GetObject takes an object to get without any tool.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be obtained.\n;; Preconditions: The agent is at a location and the object to be obtained is at the same location, and the agent is not holding the object.\n;; Postconditions: the ?o object is now held by the agent.\n(:action GetObjectWithoutTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (not (holds ?a ?o))\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n"]}, "CleanObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CleanObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CleanObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action CleanObjectWithRag\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject RagType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n(:action CleanObjectWithSoapAndWater\n        :parameters (?a - agent ?l - location ?o - object ?soapbottle - object ?sinkbasin - receptacle)\n        :precondition (and\n            (objectType ?soapbottle SoapBottleType)\n            (receptacleType ?sinkbasin SinkBasinType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?soapbottle)\n            (receptacleAtLocation ?sinkbasin ?l)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n", "\n(:action CleanObjectWithDishwasher\n        :parameters (?a - agent ?l - location ?o - object ?dishwasher - receptacle)\n        :precondition (and\n            (receptacleType ?dishwasher DishwasherType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (cleanable ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isClean ?o)\n        )\n    )\n"]}, "RinseObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called RinseObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different RinseObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, RinseObject - No tool required.\n;; RinseObject takes an object to rinse.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be rinsed.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is rinseable.\n;; Postconditions: the ?o object is now rinsed.\n(:action RinseObject_NoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (rinseable ?o)\n        )\n        :effect (and\n            (isRinsed ?o)\n        )\n)\n", "\n;; Operator, RinseObject - With water from a SinkBasin.\n;; RinseObject takes an object to rinse and a SinkBasin.\n;; Parameters: ?a - agent, ?l - location of the SinkBasin; ?o - object to be rinsed, ?sinkbasin - SinkBasin to rinse the object with.\n;; Preconditions: The sinkbasin is a SinkBasinType, the agent is at a location and the sinkbasin is at the same location, the object is rinseable, and the agent is holding the object to be rinsed.\n;; Postconditions: the ?o object is now rinsed.\n(:action RinseObject_WithSinkBasin\n        :parameters (?a - agent ?l - location ?o - object ?sinkbasin - receptacle)\n        :precondition (and\n            (receptacleType ?sinkbasin SinkBasinType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?sinkbasin ?l)\n            (rinseable ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isRinsed ?o)\n        )\n)\n", "\n;; Operator, RinseObject - With water from a WateringCan.\n;; RinseObject takes an object to rinse and a WateringCan.\n;; Parameters: ?a - agent, ?l - location of the WateringCan; ?o - object to be rinsed, ?wateringcan - WateringCan to rinse the object with.\n;; Preconditions: The wateringcan is a WateringCanType, the agent is at a location and the wateringcan is at the same location, the object is rinseable, and the agent is holding the object to be rinsed.\n;; Postconditions: the ?o object is now rinsed.\n(:action RinseObject_WithWateringCan\n        :parameters (?a - agent ?l - location ?o - object ?wateringcan - object)\n        :precondition (and\n            (objectType ?wateringcan WateringCanType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?wateringcan ?l)\n            (rinseable ?o)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isRinsed ?o)\n        )\n)\n"]}, "ToastObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ToastObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ToastObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action ToastObject1\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject ToasterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toastable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n)\n", "\n(:action ToastObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle StoveBurnerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n)\n", "\n(:action ToastObject3\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (toastable ?o)\n        )\n        :effect (and\n            (isToasted ?o)\n        )\n)\n"]}, "InspectObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called InspectObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different InspectObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, InspectObject.\n;; InspectObject takes any object to inspect.\n;; This action is applicable to any inspectable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be inspected.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is inspectable.\n;; Postconditions: The agent holds the inspected object and the object is marked as inspected.\n(:action InspectObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (inspectable ?o)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (isInspected ?o)\n        )\n)\n", "\n;; Operator, InspectObjectWithTool.\n;; InspectObjectWithTool takes any object to inspect and a specific tool of type InspectionToolType.\n;; InspectionToolType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be inspected, ?toolobject - object to inspect with.\n;; Preconditions: The toolobject is an InspectionToolType, the agent is at a location and the object to be inspected is at the same location, the object is inspectable, and the agent is holding the tool.\n;; Postconditions: The agent holds the inspected object and the object is marked as inspected.\n(:action InspectObjectWithTool\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject InspectionToolType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (inspectable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (isInspected ?o)\n        )\n)\n", "\n;; Operator, InspectObjectInReceptacle.\n;; InspectObjectInReceptacle takes any object to inspect and a specific receptacle of type InspectionDeskType.\n;; InspectionDeskType is an rtype. Therefore, the receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be inspected, ?receptacle - receptacle to inspect in.\n;; Preconditions: The receptacle is an InspectionDeskType, the agent is at a location and the receptacle is at the same location, the receptacle is an inspection desk, and the object to be inspected is in the receptacle.\n;; Postconditions: The agent holds the inspected object and the object is marked as inspected.\n(:action InspectObjectInReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?receptacle - receptacle)\n        :precondition (and\n            (receptacleType ?receptacle InspectionDeskType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?receptacle ?l)\n            (inspectionDesk ?receptacle)\n            (inReceptacle ?o ?receptacle)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (isInspected ?o)\n        )\n)\n"]}, "TurnOnLamp": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnLamp.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnLamp operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; First TurnOnLamp operator\n(:action TurnOnLamp1\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (receptacleType ?r LampType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (toggleable ?r)\n            (not (isOn ?r))\n        )\n        :effect (and\n            (isOn ?r)\n        )\n    )\n", "\n;; Second TurnOnLamp operator\n(:action TurnOnLamp2\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (receptacleType ?r LampType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (toggleable ?r)\n            (isToggled ?r)\n        )\n        :effect (and\n            (isOn ?r)\n        )\n    )\n", "\n;; Third TurnOnLamp operator\n(:action TurnOnLamp3\n        :parameters (?a - agent ?l - location ?r - receptacle ?to - object)\n        :precondition (and\n            (receptacleType ?r LampType)\n            (objectType ?to LampSwitchType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?to ?l)\n            (receptacleAtLocation ?r ?l)\n            (toggleable ?r)\n            (holds ?a ?to)\n            (isToggled ?to)\n        )\n        :effect (and\n            (isOn ?r)\n        )\n    )\n"]}, "CarryObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called CarryObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different CarryObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, CarryObject1.\n;; CarryObject1 takes an object to be carried and the agent's location.\n;; This action is applicable to any object that can be carried.\n;; Parameters: ?a - agent, ?l - location of the agent, ?o - object to be carried.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is carryable.\n;; Postconditions: the agent is holding the object.\n(:action CarryObject1\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (carryable ?o)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n", "\n;; Operator, CarryObject2.\n;; CarryObject2 takes an object to be carried, a tool object to help with carrying, and the agent's location.\n;; This action is applicable to any object that can be carried and any tool object that can be used for carrying.\n;; Parameters: ?a - agent, ?l - location of the agent, ?o - object to be carried, ?toolobject - tool object to help with carrying.\n;; Preconditions: The agent is at a location and the object and tool object are at the same location, the object is carryable, the tool object can be used for carrying, and the agent is holding the tool object.\n;; Postconditions: the agent is holding the object.\n(:action CarryObject2\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (objectAtLocation ?toolobject ?l)\n            (carryable ?o)\n            (carryTool ?toolobject)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n", "\n;; Operator, CarryObject3.\n;; CarryObject3 takes an object to be carried, a tool receptacle to help with carrying, and the agent's location.\n;; This action is applicable to any object that can be carried and any tool receptacle that can be used for carrying.\n;; Parameters: ?a - agent, ?l - location of the agent, ?o - object to be carried, ?toolreceptacle - tool receptacle to help with carrying.\n;; Preconditions: The agent is at a location and the object and tool receptacle are at the same location, the object is carryable, the tool receptacle can be used for carrying, and the agent is holding the object.\n;; Postconditions: the agent is holding the object.\n(:action CarryObject3\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (carryable ?o)\n            (carryTool ?toolreceptacle)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (holds ?a ?o)\n        )\n)\n"]}, "ThrowObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called ThrowObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different ThrowObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, ThrowObjectA\n;; ThrowObjectA takes an object to throw and a specific tool of type BaseBallBatType.\n;; BaseBallBatType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object to be thrown; ?o - object to be thrown, ?toolobject - object to throw with.\n;; Preconditions: The toolobject is a BaseBallBatType, the agent is at a location and the object to be thrown is at the same location, the object is throwable, and the agent is holding the tool.\n;; Postconditions: the ?o object is thrown.\n(:action ThrowObjectA\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject BaseBallBatType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isThrown ?o)\n        )\n    )\n", "\n;; Operator, ThrowObjectB\n;; ThrowObjectB takes an object to throw and a specific tool of type BasketBallType.\n;; BasketBallType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of the object to be thrown; ?o - object to be thrown, ?toolobject - object to throw with.\n;; Preconditions: The toolobject is a BasketBallType, the agent is at a location and the object to be thrown is at the same location, the object is throwable, and the agent is holding the tool.\n;; Postconditions: the ?o object is thrown.\n(:action ThrowObjectB\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject BasketBallType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isThrown ?o)\n        )\n    )\n", "\n;; Operator, ThrowObjectC\n;; ThrowObjectC takes an object to throw without needing any tools.\n;; Parameters: ?a - agent, ?l - location of the object to be thrown; ?o - object to be thrown.\n;; Preconditions: The agent is at a location and the object to be thrown is at the same location, and the object is throwable.\n;; Postconditions: the ?o object is thrown.\n(:action ThrowObjectC\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (throwable ?o)\n        )\n        :effect (and\n            (isThrown ?o)\n        )\n    )\n"]}, "TakeObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TakeObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TakeObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, TakeObject (without tool)\n;; TakeObject takes an object that can be taken.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be taken.\n;; Preconditions: The agent is at a location with the object to be taken, and the object can be taken.\n;; Postconditions: The agent is holding the object, and the object is no longer at the location.\n(:action TakeObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (takeable ?o)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (not (objectAtLocation ?o ?l))\n        )\n)\n", "\n;; Operator, TakeObject (with tool object)\n;; TakeObject takes an object that can be taken, using a tool object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be taken; ?toolobject - tool object to use.\n;; Preconditions: The agent is at a location with the object to be taken and the tool object, the object can be taken, and the agent is holding the tool object.\n;; Postconditions: The agent is holding the object, the object is no longer at the location, and the agent is no longer holding the tool object.\n(:action TakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (takeable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (not (objectAtLocation ?o ?l))\n            (not (holds ?a ?toolobject))\n        )\n)\n", "\n;; Operator, TakeObject (with tool receptacle)\n;; TakeObject takes an object that can be taken, using a tool receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be taken; ?toolreceptacle - tool receptacle to use.\n;; Preconditions: The agent is at a location with the object to be taken and the tool receptacle, the object can be taken, and the tool receptacle is at the same location.\n;; Postconditions: The agent is holding the object, the object is no longer at the location, and the tool receptacle is empty.\n(:action TakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (takeable ?o)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (empty ?toolreceptacle)\n        )\n        :effect (and\n            (holds ?a ?o)\n            (not (objectAtLocation ?o ?l))\n            (not (empty ?toolreceptacle))\n        )\n)\n"]}, "InvestigateObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called InvestigateObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different InvestigateObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n;; Operator, InvestigateObject - No tool\n;; InvestigateObject takes an object to investigate.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be investigated.\n;; Preconditions: The agent is at a location and the object is at the same location.\n;; Postconditions: The agent knows something about the object (?o).\n(:action InvestigateObject_NoTool\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n        )\n        :effect (and\n            (investigated ?o)\n        )\n    )\n", "\n;; Operator, InvestigateObject - With tool object\n;; InvestigateObject takes an object to investigate and a specific tool object of type MagnifyingGlassType.\n;; MagnifyingGlassType is an otype. Therefore, the tool object is an object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be investigated, ?toolobject - tool object to investigate with.\n;; Preconditions: The tool object is a MagnifyingGlassType, the agent is at a location and the object to be investigated is at the same location, and the agent is holding the tool object.\n;; Postconditions: The agent knows something detailed about the object (?o).\n(:action InvestigateObject_WithToolObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject MagnifyingGlassType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (detailedInvestigated ?o)\n        )\n    )\n", "\n;; Operator, InvestigateObject - With tool receptacle\n;; InvestigateObject takes an object to investigate and a specific tool receptacle of type MicroscopeType.\n;; MicroscopeType is an rtype. Therefore, the tool receptacle is a receptacle.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be investigated, ?toolreceptacle - tool receptacle to investigate with.\n;; Preconditions: The tool receptacle is a MicroscopeType, the agent is at a location and the object to be investigated is at the same location, and the agent is holding the object to be investigated in the tool receptacle.\n;; Postconditions: The agent knows something at a molecular level about the object (?o).\n(:action InvestigateObject_WithToolReceptacle\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle MicroscopeType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (molecularInvestigated ?o)\n        )\n)\n"]}, "TurnOnLight": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called TurnOnLight.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different TurnOnLight operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action TurnOnLightSwitch\n        :parameters (?a - agent ?l - location ?lobject - object ?sobject - object)\n        :precondition (and\n            (toggleable ?lobject)\n            (toggleable ?sobject)\n            (atLocation ?a ?l)\n            (objectAtLocation ?lobject ?l)\n            (objectAtLocation ?sobject ?l)\n            (isOff ?sobject)\n            (holds ?a ?sobject)\n        )\n        :effect (and\n            (isOn ?lobject)\n            (isToggled ?sobject)\n        )\n    )\n", "\n(:action TurnOnLightCandle\n        :parameters (?a - agent ?l - location ?lobject - object ?cobject - object)\n        :precondition (and\n            (toggleable ?lobject)\n            (heatable ?cobject)\n            (atLocation ?a ?l)\n            (objectAtLocation ?lobject ?l)\n            (objectAtLocation ?cobject ?l)\n            (not (isBurned ?cobject))\n            (holds ?a ?cobject)\n        )\n        :effect (and\n            (isOn ?lobject)\n            (isBurned ?cobject)\n        )\n    )\n", "\n(:action TurnOnLightSafe\n        :parameters (?a - agent ?l - location ?lobject - object ?robject - receptacle)\n        :precondition (and\n            (toggleable ?lobject)\n            (openable ?robject)\n            (atLocation ?a ?l)\n            (objectAtLocation ?lobject ?l)\n            (receptacleAtLocation ?robject ?l)\n            (closed ?robject)\n            (holds ?a ?kobject)\n        )\n        :effect (and\n            (isOn ?lobject)\n            (opened ?robject)\n        )\n    )\n"]}, "PutdownObject": {"codex_prompt": [{"role": "system", "content": ";; You are a software engineer who will be writing planning operators in the PDDL planning language.\n;; These operators are based on the following PDDL domain definition. \n;; Note that there are separate types for both objects (otype) and receptacles (rtype).\n(:requirements :adl)\n\n(:types \n\t\t\t\tagent location receptacle object rtype otype\n)\n\n;; otype: object types.\n(:otype\n        CandleType - otype\n        ShowerGlassType - otype\n        CDType - otype\n        TomatoType - otype\n        MirrorType - otype\n        ScrubBrushType - otype\n        MugType - otype\n        ToasterType - otype\n        PaintingType - otype\n        CellPhoneType - otype\n        LadleType - otype\n        BreadType - otype\n        PotType - otype\n        BookType - otype\n        TennisRacketType - otype\n        ButterKnifeType - otype\n        ShowerDoorType - otype\n        KeyChainType - otype\n        BaseballBatType - otype\n        EggType - otype\n        PenType - otype\n        ForkType - otype\n\t\t\t\tWhiskType - otype\n        VaseType - otype\n        ClothType - otype\n        WindowType - otype\n        PencilType - otype\n        StatueType - otype\n        LightSwitchType - otype\n        WatchType - otype\n        SpatulaType - otype\n        PaperTowelRollType - otype\n        FloorLampType - otype\n        KettleType - otype\n        SoapBottleType - otype\n        BootsType - otype\n        TowelType - otype\n        PillowType - otype\n        AlarmClockType - otype\n        PotatoType - otype\n        ChairType - otype\n        PlungerType - otype\n        SprayBottleType - otype\n        HandTowelType - otype\n        BathtubType - otype\n        RemoteControlType - otype\n        PepperShakerType - otype\n        PlateType - otype\n        BasketBallType - otype\n        DeskLampType - otype\n        FootstoolType - otype\n        GlassbottleType - otype\n        PaperTowelType - otype\n        CreditCardType - otype\n        PanType - otype\n        ToiletPaperType - otype\n        SaltShakerType - otype\n        PosterType - otype\n        ToiletPaperRollType - otype\n        LettuceType - otype\n        WineBottleType - otype\n        KnifeType - otype\n        LaundryHamperLidType - otype\n        SpoonType - otype\n        TissueBoxType - otype\n        BowlType - otype\n        BoxType - otype\n        SoapBarType - otype\n        HousePlantType - otype\n        NewspaperType - otype\n        CupType - otype\n        DishSpongeType - otype\n        LaptopType - otype\n        TelevisionType - otype\n        StoveKnobType - otype\n        CurtainsType - otype\n        BlindsType - otype\n        TeddyBearType - otype\n        AppleType - otype\n        WateringCanType - otype\n        SinkType - otype\n)\n;; rtype: receptacle types.\n(:rtype\n        ArmChairType - rtype\n        BedType - rtype\n        BathtubBasinType - rtype\n        DresserType - rtype\n        SafeType - rtype\n        DiningTableType - rtype\n        SofaType - rtype\n        HandTowelHolderType - rtype\n        StoveBurnerType - rtype\n        CartType - rtype\n        DeskType - rtype\n        CoffeeMachineType - rtype\n        MicrowaveType - rtype\n        ToiletType - rtype\n        CounterTopType - rtype\n        GarbageCanType - rtype\n        CoffeeTableType - rtype\n        CabinetType - rtype\n        SinkBasinType - rtype\n        OttomanType - rtype\n        ToiletPaperHangerType - rtype\n        TowelHolderType - rtype\n        FridgeType - rtype\n        DrawerType - rtype\n        SideTableType - rtype\n        ShelfType - rtype\n        LaundryHamperType - rtype\n)\n\n;; Predicates defined on this domain. Note the types for each predicate.\n(:predicates\n\t\t\t\t(atLocation ?a - agent ?l - location) \n        (receptacleAtLocation ?r - receptacle ?l - location) \n        (objectAtLocation ?o - object ?l - location)\n        (inReceptacle ?o - object ?r - receptacle) \n        (receptacleType ?r - receptacle ?t - rtype) \n        (objectType ?o - object ?t - otype) \n        (holds ?a - agent ?o - object) \n        (holdsAny ?a - agent) \n        (holdsAnyReceptacleObject ?a - agent) \n        \n\t\t\t\t(openable ?r - receptacle) \n        (opened ?r - receptacle) \n        (isClean ?o - object) \n        (cleanable ?o - object) \n        (isHot ?o - object) \n        (heatable ?o - object) \n        (isCool ?o - object) \n        (coolable ?o - object) \n        (toggleable ?o - object) \n        (isOn ?o - object) \n        (isToggled ?o - object) \n        (sliceable ?o - object) \n        (isSliced ?o - object) \n )\n\n;; Operators defined given the object types, receptacle types, and predicates.\n;; Note that operator names may not be correct. For instance, FillObject actually fills a receptacle.\n;; Parameters should specify the correct type of all arguments, distinguishing between objects and receptables.\n;; Preconditions should specify any specific objectType and receptacleType if necessary, locations of objects and receptacles, and any precondition predicates.\n;; Effects should specify any effects.\n\n;; Operator, GotoLocation\n;; GotoLocation takes a start and end location.\n;; This is applicable to all locations.\n;; Parameters: ?a - agent, ?lStart - start location; ?lEnd - end location;\n;; Preconditions: The agent is at the start location.\n;; Postconditions: The agent is at the end location and is not at the start location.\n<START>\n(:action GotoLocation\n      :parameters (?a - agent ?lStart - location ?lEnd - location)\n      :precondition (and\n          (atLocation ?a ?lStart)\n      )\n      :effect (and\n          (atLocation ?a ?lEnd)\n          (not (atLocation ?a ?lStart))\n      )\n  )\n<END>\n\n;; Operator, GrateObject.\n;; GrateObject takes an object to grate and a specific tool of type GraterType.\n;; GraterType is an otype. Therefore, the tool is an object.\n;; Parameters: ?a - agent, ?l - location of object to be grated; ?o - object to be grated, ?toolobject - object to grate with.\n;; Preconditions: The toolobject is a GraterType, the agent is at a location and the object to be grated is at the same location, the object is gratable, and the agent is holding the tool.\n;; Postconditions: the ?o object is grated.\n(:action GrateObject\n        :parameters (?a - agent ?l - location ?o - object ?toolobject - object)\n        :precondition (and\n            (objectType ?toolobject GraterType)\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (gratable ?o)\n            (holds ?a ?toolobject)\n        )\n        :effect (and\n            (isGrated ?o)\n        )\n    )\n<END>\n\n;; Operator, BakeObject.\n;; BakeObject takes an object to baked and a specific tool of type OvenType.\n;; OvenType is an rtype. Therefore, the tool is an receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?o - object to be baked, ?toolreceptacle - receptacle to bake the object in.\n;; Preconditions: The toolreceptacle is an OvenType, the agent is at a location and the receptacle is at the same location, and the agent is holding the object to be baked.\n;; Postconditions: the ?o object is now hot.\n<START>\n(:action BakeObject\n        :parameters (?a - agent ?l - location ?o - object ?toolreceptacle - receptacle)\n        :precondition (and\n            (receptacleType ?toolreceptacle OvenType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?toolreceptacle ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n           (isHot ?o)\n        )\n    )\n<END>\n\n;; Operator, FillObject.\n;; FillObject takes any receptacle to fill.\n;; This action is applicable to any fillable receptacle.\n;; Parameters: ?a - agent, ?l - location of the receptacle; ?r - receptacle to be filled.\n;; Preconditions: The agent is at a location and the receptacle is at the same location, and the receptacle is fillable.\n;; Postconditions: the ?r receptacle is now filled.\n<START>\n(:action FillObject\n        :parameters (?a - agent ?l - location ?r - receptacle)\n        :precondition (and\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (fillable ?r)\n        )\n        :effect (and\n            (isFilled ?r)\n        )\n    )\n<END>\n\n;; Operator, RestartObject.\n;; RestartObject takes any object to restart.\n;; This action is applicable to any restartable object.\n;; Parameters: ?a - agent, ?l - location of the object; ?o - object to be restarted.\n;; Preconditions: The agent is at a location and the object is at the same location, and the object is restartable.\n;; Postconditions: the ?o object is now restarted.\n<START>\n(:action RestartObject\n        :parameters (?a - agent ?l - location ?o - object)\n        :precondition (and\n            (atLocation ?a ?l)\n            (objectAtLocation ?o ?l)\n            (restartable ?o)\n        )\n        :effect (and\n            (isRestarted ?o)\n        )\n)\n<END>"}, {"role": "user", "content": ";; Based on those examples, write an example for an operator called PutdownObject.\n;; As with the examples, consider whether we can use a tool object, a tool receptacle, and what types they could be if you use them, based on the list of objectTypes and receptacleTypes. Or, you may not need to use any tool objects or tool receptacles at all. Make sure to only use valid predicates that appear in the domain definition.\n;; Write three different PutdownObject operators. Start each with <START> and end with <END>. "}], "codex_output": ["\n(:action PutdownObject1\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (receptacleType ?r BedType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n)\n", "\n(:action PutdownObject2\n        :parameters (?a - agent ?l - location ?o - object ?r - receptacle)\n        :precondition (and\n            (receptacleType ?r DrawerType)\n            (atLocation ?a ?l)\n            (receptacleAtLocation ?r ?l)\n            (openable ?r)\n            (opened ?r)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (inReceptacle ?o ?r)\n        )\n)\n", "\n(:action PutdownObject3\n        :parameters (?a - agent ?l - location ?o - object ?r - location)\n        :precondition (and\n            (atLocation ?a ?l)\n            (holds ?a ?o)\n        )\n        :effect (and\n            (atLocation ?o ?r)\n        )\n)\n"]}}