operator_name,gt_operator,operator_body,n_operator_successes,n_operator_attempts,score,
PickupObject_702,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",2.05,2.5,0.82,
PickupObject_74,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",2.05,2.5,0.82,
PickupObject_978,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_988,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pencil!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_141,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the pencil."")
        return False, env_state

    # Low-level actions: put the object on the shelf.
    try:
        print(""Trying to put the pencil on the shelf."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the pencil on the shelf."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the shelf.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_79,,"
    # Preconditions: None.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the knife!"")
    except:
        print(""Execution failure in picking up the knife..."")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_322,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the knife.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the knife."")
        return False, env_state

    # Low-level actions: Open fridge (receptacle) before putting the knife in it.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Fridge opened successfully."")
    except:
        print(""Execution failure in opening the fridge..."")
        return False, env_state

    # Low-level actions: put the knife in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Knife placed in the fridge successfully."")
    except:
        print(""Failure, could not place the knife in the fridge."")
        return False, env_state

    # Postconditions: Knife is in the fridge.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_992,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_418,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
CoolObject_111,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: the potato should be held by the robot.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: open the fridge to put the potato inside.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure, could not open the fridge..."")
        return False, env_state
    
    # Low-level actions: put the potato in the fridge to cool it.
    try:
        print(""Putting the potato in the fridge to cool."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject (cooling potato) is: {success}"")
    except:
        print(""Failure, could not put the potato in the fridge."")
        return False, env_state

    # Low-level actions: close the fridge after putting the potato inside.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of CloseObject (fridge) is: {success}"")
    except:
        print(""Execution failure, could not close the fridge..."")
        return False

    # Postconditions: potato should be in the fridge and cool.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id) and final_env_state.isCool(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObjectFromReceptacle_11,,"
    # Preconditions: the potato should be cooled inside the fridge.
    if (not env_state.inReceptacle(object_id, receptacle_object_id) or not env_state.isCool(object_id)):
        print(""Failure, the potato is not cool or not in the fridge."")
        return False, env_state

    # Low-level actions: open the fridge to retrieve the potato.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge to retrieve the potato!"")
    except:
        print(""Execution failure, could not open the fridge..."")
        return False, env_state

    # Low-level actions: pick up the potato from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled potato from the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the chilled potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_768,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the remote control!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the remote control.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_52,,"
    # Preconditions: None.
    
    # Low-level actions: pick up the mug.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure during pickup..."")
        return False

    # Postconditions: now holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_129,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: open the heating source (e.g., microwave).
    try:
        action = OpenObject(args={'object_id': heat_source_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure during opening..."")
        return False

    # Low-level actions: put the mug in the heating source.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': heat_source_id})
        success = act(env=env, action=action)
        print(""Placed the mug inside the microwave."")
    except:
        print(""Failure during placement inside the microwave."")
        return False

    # Low-level actions: close the heating source and turn it on to heat the mug.
    try:
        action = CloseObject(args={'object_id': heat_source_id})
        success = act(env=env, action=action)
        action = ToggleObjectOn(args={'object_id': heat_source_id})
        success = act(env=env, action=action)
        print(""Microwave turned on to heat the mug."")
    except:
        print(""Execution failure during microwave operation..."")
        return False

    # Postconditions: mug is hot.
    final_env_state = perceive(env)
    # Assuming there is some delay needed for heating, a wait or check for isHot might be needed here.
    return (final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_278,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_147,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure in opening microwave..."")
        return False, env_state

    # Low-level actions: put the potato in the microwave.
    try:
        print(""Trying to put the potato in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject in microwave is: {success}"")
    except:
        print(""Failure in placing potato in microwave."")
        return False, env_state

    # Low-level actions: close the microwave and start heating.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave closed: {success}"")
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave started: {success}"")
    except:
        print(""Execution failure in starting microwave..."")
        return False, env_state

    # Assuming heating process is instantaneous for the sake of simulation.
    # In a real scenario, we would wait for a set amount of time here.

    # Low-level actions: open microwave to take out the heated potato.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave stopped: {success}"")
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave opened: {success}"")
    except:
        print(""Execution failure in opening microwave..."")
        return False, env_state

    # Low-level actions: pick up the heated potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated potato!"")
    except:
        print(""Failure in picking up potato from microwave."")
        return False, env_state

    # Postconditions: holding the heated object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_242,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated potato.
    if (not env_state.holds(object_id)) or (not env_state.isHot(object_id)):
        print(""Failure, not holding a heated potato."")
        return False, env_state

    # Low-level actions: put the heated potato on the sidetable.
    try:
        print(""Trying to put the heated potato on the sidetable."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject on sidetable is: {success}"")
    except:
        print(""Failure in placing heated potato on sidetable."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the sidetable.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_843,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the soap bar!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_118,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure when attempting to pick up tomato."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_970,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object (potato).
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
EnsureLightIsOn_0,,"
    # Preconditions: Light is toggleable and not currently toggled on.

    # Check if light can be toggled
    if env_state.toggleable(object_id) and not env_state.isToggled(object_id):
        # Low-level actions: toggle the light on.
        try:
            action = ToggleObjectOn(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully turned on the light!"")
        except:
            print(""Execution failure..."")
            return False

        # Postconditions: The light is on.
        final_env_state = perceive(env)
        return (final_env_state.isToggled(object_id)), final_env_state
    else:
        # Light is already on or cannot be toggled.
        return True, env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_76,,"
    # Preconditions: floorlamp should be off and toggleable.
    if not (env_state.toggleable(object_id) and not env_state.isToggled(object_id)):
        print(""Failure, floorlamp not toggleable or already on."")
        return False, env_state

    # Low-level actions: turn on the floorlamp.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the floorlamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: floorlamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_254,,"
    # Preconditions: None.

    # Low-level actions: pick up the remote control.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the remote control!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the remote control.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_777,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_85,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_984,,"
    # Preconditions: None.

    # Low-level actions: pick up the mug.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_135,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding mug."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the mug in the microwave.
    try:
        print(""Trying to put the mug in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place mug in the microwave."")
        return False, env_state

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of CloseObject is: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: toggle the microwave on to heat up the mug.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOn is: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Simulate heating time (in actual implementation, this would be a wait for a certain time period)
    print(""Waiting for the mug to be heated up..."")
    
    # Low-level actions: toggle the microwave off after heating the mug.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOff is: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: mug is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1069,,"
    # Preconditions: None.

    # Low-level actions: pick up the mug from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the heated mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1029,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the spray bottle!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectOnReceptacle_17,,"
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the spray bottle."")
        return False, env_state

    # Low-level actions: put the object on the receptacle.
    try:
        print(""Trying to put the spray bottle on the toilet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the spray bottle on the toilet."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1130,,"
    # Preconditions: None.
    # Low-level actions: pick up the object if it's not already held.
    try:
        if not env_state.holds(object_id):
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False
    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_972,,"
    # Preconditions: None.
    
    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an apple!"")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_600,,"
    # Preconditions: None.

    # Low-level actions: pick up the bowl.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bowl!"")
    except:
        print(""Execution failure during picking up the bowl..."")
        return False

    # Postconditions: holding the bowl.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_419,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_11,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the apple."")
        return False, env_state

    # Additional Preconditions: the object must be heatable.
    if not env_state.heatable(object_id):
        print(""The apple cannot be heated."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action_open = OpenObject(args={'object_id':receptacle_object_id})
        success_open = act(env=env, action=action_open)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the apple in the microwave.
    try:
        action_put = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success_put = act(env=env, action=action_put)
        print(""Successfully placed the apple in the microwave!"")
    except:
        print(""Failure, could not place the apple in the microwave."")
        return False

    # Low-level actions: close the microwave.
    try:
        action_close = CloseObject(args={'object_id':receptacle_object_id})
        success_close = act(env=env, action=action_close)
        print(""Successfully closed the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: turn on the microwave to heat the apple.
    try:
        action_toggle_on = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success_toggle_on = act(env=env, action=action_toggle_on)
        print(""Successfully turned on the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Assume there is some waiting time for heating the apple here.
    # ...

    # Low-level actions: turn off the microwave after heating.
    try:
        action_toggle_off = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success_toggle_off = act(env=env, action=action_toggle_off)
        print(""Successfully turned off the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: open the microwave.
    try:
        action_open_again = OpenObject(args={'object_id':receptacle_object_id})
        success_open_again = act(env=env, action=action_open_again)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: pick up the apple.
    try:
        action_pickup_again = PickupObject(args={'object_id':object_id})
        success_pickup_again = act(env=env, action=action_pickup_again)
        print(""Successfully picked up the heated apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the heated apple.
    final_env_state = perceive(env)
    return final_env_state.isHot(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_490,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated object.
    if not env_state.holds(object_id) or not env_state.isHot(object_id):
        print(""Failure, not holding a heated apple."")
        return False, env_state

    # Low-level actions: put the heated apple on the counter.
    try:
        print(""Trying to put the heated apple on the counter."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the heated apple on the counter."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the counter.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1059,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the plate!"")
    except:
        print(""Execution failure, couldn't pick up the plate..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
CoolObject_168,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding plate."")
        return False, env_state

    if not env_state.isCool(object_id) and env_state.coolable(object_id):
        # Low-level actions: put the object in the fridge to cool down.
        try:
            action = OpenObject(args={'object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Opened fridge to cool the plate."")
            action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Placed the plate inside fridge to cool."")
        except:
            print(""Execution failure while cooling the plate..."")
            return False, env_state

        try:
            action = CloseObject(args={'object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Closed the fridge to cool the plate."")
        except:
            print(""Execution failure, couldn't close the fridge..."")
            return False, env_state

        # Waiting for the object to cool down might be required here.

        # Low-level actions: take the object out of the fridge after cooling.
        try:
            action = OpenObject(args={'object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Opened the fridge to take out the cooled plate."")
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Picked up the cooled plate."")
        except:
            print(""Execution failure, couldn't retrieve the plate from the fridge..."")
            return False, env_state

    # Postconditions: object is cool and in hand.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id) and final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_848,,"
    # Preconditions: None.

    # Low-level actions: Pick up the apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: The apple is being held.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_578,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the spoon!"")
    except:
        print(""Execution failure when picking up the spoon..."")
        return False

    # Postconditions: holding the spoon.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1092,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1065,,"
    # Preconditions: None.

    # Low-level actions: pick up the bowl.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bowl!"")
    except:
        print(""Execution failure when trying to pick up the bowl..."")
        return False

    # Postconditions: holding the bowl.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_154,,"
    # Preconditions: None.

    # Check if the desklamp can be toggled on.
    if (not env_state.toggleable(object_id)):
        print(""Failure, desklamp not toggleable."")
        return False, env_state

    # Low-level actions: turn on the desklamp.
    try:
        print(""Trying to toggle on the desklamp."")
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOn is: {success}"")
    except:
        print(""Execution failure when trying to toggle on the desklamp..."")
        return False, env_state

    # Postconditions: desklamp is toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_708,,"
    # Preconditions: None.

    # Low-level actions: pick up the tomato.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_398,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the book!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_326,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the book."")
        return False, env_state

    # Low-level actions: put the book in the desk.
    try:
        print(""Trying to place the book in the desk."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the book in the desk."")
        return False, env_state

    # Postconditions: Not holding the book and the book is in the desk.
    final_env_state = perceive(env)
    placed_correctly = not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)
    return placed_correctly, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_211,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObjectFromReceptacle_19,,"
    # Preconditions: The object is in the specified receptacle.
    if (not env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Failure, object is not in the specified receptacle."")
        return False, env_state

    # Low-level actions: pick up the object from the receptacle.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the object from the receptacle!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectOnReceptacle_13,,"
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: put the object on the receptacle.
    try:
        print(""Trying to put object on receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place object on receptacle."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_496,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the box!"")
    except:
        print(""Execution failure when trying to pick up the box..."")
        return False

    # Postconditions: holding the object (box).
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_157,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the box.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the box."")
        return False, env_state

    # Low-level actions: put the box on the couch (sofa being a good replacement receptacle for couch).
    try:
        print(""Trying to put the box on the couch."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the box on the couch."")
        return False, env_state

    # Postconditions: not holding the box and the box is now on the couch.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1097,,"
    # Preconditions: None.

    # Low-level actions: pick up the pot.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pot!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the pot.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
CoolObject_2,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the pot.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the pot."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Fridge is now open."")
    except:
        print(""Execution failure while opening fridge..."")
        return False

    # Low-level actions: put the pot in the fridge.
    try:
        print(""Placing the pot in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Pot placed in the fridge."")
    except:
        print(""Failure, could not place the pot in the fridge."")
        return False, env_state

    # Postconditions: pot should be in the fridge.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_490,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bread!"")
    except:
        print(""Execution failure while trying to pick up the bread..."")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_592,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure in picking up the apple..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_59,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an apple!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_57,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the apple.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the apple."")
        return False, env_state

    # Low-level actions: open the microwave
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: put the apple in the microwave.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Apple placed in the microwave: {success}"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: close the microwave to allow the apple to heat up.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Microwave closed: {success}"")
    except Exception as e:
        print(f""Failure closing the microwave: {e}"")
        return False

    # Low-level actions: toggle the microwave on to heat the apple.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Microwave turned on: {success}"")
    except Exception as e:
        print(f""Failure turning on the microwave: {e}"")
        return False

    # Postconditions: apple is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_361,,"
    # Preconditions: None.

    # Low-level actions: pick up the object (potato).
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObjectFromReceptacle_4,,"
    # Preconditions: the object must be in the initial receptacle.
    if (not env_state.inReceptacle(object_id, initial_receptacle_id)):
        print(""The object is not in the specified receptacle."")
        return False, env_state

    # Low-level actions: pick up the object from the receptacle.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(f""Successfully picked up the object {object_id} from {initial_receptacle_id}!"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_255,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object to place it in the target receptacle.
    if (not env_state.holds(object_id)):
        print(""Not holding the object, cannot place it in the target receptacle."")
        return False, env_state

    # Low-level actions: put the object in the target receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':target_receptacle_id})
        success = act(env=env, action=action)
        print(f""Successfully placed the object {object_id} into {target_receptacle_id}."")
    except Exception as e:
        print(f""Failure in placing the object: {str(e)}"")
        return False

    # Postconditions: not holding the object and the object is in the target receptacle.
    final_env_state = perceive(env)
    placed_correctly = not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, target_receptacle_id)
    return placed_correctly, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1135,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_334,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_129,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure when trying to pick up the mug..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_502,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: put the mug in the receptacle (sink).
    try:
        print(""Trying to put the mug in the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the mug in the sink."")
        return False, env_state

    # Postconditions: the mug is in the sink.
    final_env_state = perceive(env)
    if (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_412,,"
    # Preconditions: None.

    # Low-level actions: pick up the pan.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pan!"")
    except:
        print(""Execution failure in picking up the pan..."")
        return False

    # Postconditions: holding the pan.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1001,,"
    # Preconditions: None.

    # Low-level actions: pick up the lettuce.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up lettuce!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the lettuce.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_640,,"
    # Preconditions: None.

    # Trying to find book and pick it up
    try:
        # Low-level actions: pick up the book object
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the book."")
        # Postconditions: holding the book
        final_env_state = perceive(env)
        return final_env_state.holds(object_id), final_env_state
    except Exception as e:
        print(""Failed to pick up the book:"", str(e))
        # Further action may be required to handle failure
        return False, env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1095,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_165,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: open the receptacle.
    if (not env_state.toggleable(receptacle_object_id)):
        print(""Failure, microwave is not toggleable."")
        return False, env_state
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Low-level actions: put the object in the receptacle for heating.
    try:
        print(""Trying to put the egg in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject (egg in microwave) is: {success}"")
    except Exception as e:
        print(f""Failure, could not place egg in microwave: {str(e)}"")
        return False, env_state

    # Low-level actions: close the receptacle to start the microwave.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of CloseObject (microwave door) is: {success}"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state
    
    # Low-level actions: toggle the microwave on to heat the object.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOn (microwave) is: {success}"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Wait for a while to simulate microwaving time (this would be done in a more sophisticated system).

    # Low-level actions: toggle the microwave off after the object is heated.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOff (microwave) is: {success}"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Low-level actions: open the receptacle again.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of OpenObject (microwave door) is: {success}"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Low-level actions: pick up the heated object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(f""Result of PickupObject (egg) is: {success}"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Postconditions: object is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_436,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated object.
    if (not env_state.holds(object_id) or not env_state.isHot(object_id)):
        print(""Failure, not holding heated object."")
        return False, env_state

    # Low-level actions: put the heated object in the garbage receptacle.
    try:
        print(""Trying to put the microwaved egg in the garbage can."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject (egg in garbage can) is: {success}"")
    except Exception as e:
        print(f""Failure, could not place microwaved egg in garbage can: {str(e)}"")
        return False, env_state

    # Postconditions: not holding the object and the object is in the garbage receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Microwaved egg successfully discarded in the garbage can."")
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1118,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    # Assuming env is the environment object created as per AlfredActionFactory.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the keychain."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: Holding the keychain.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_309,,"
    # Preconditions: The knife must not be held.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_5,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the plunger!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_70,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a box!"")
    except:
        print(""Execution failure when trying to pick up the box..."")
        return False

    # Postconditions: holding the object (the box).
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_543,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: should be holding the object (the box).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the box."")
        return False, env_state

    # Low-level actions: put the box on the table.
    try:
        print(""Trying to put the box on the table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject (placing the box on the table) is: {success}"")
    except:
        print(""Failure, could not place the box on the table."")
        return False, env_state

    # Postconditions: not holding the box and the box is on the table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_113,,"
    # Preconditions: None.
    
    # Low-level actions: pick up the potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False
    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_921,,"
    # Preconditions: None.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the knife."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_567,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up bread!"")
    except:
        print(""Execution failure when trying to pick up bread..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_121,,"
    # Preconditions: Lamp is not already on.
    if env_state.isToggled(object_id):
        print(""Lamp is already on."")
        return True, env_state

    # Low-level actions: toggle the lamp on.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the lamp!"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Postconditions: Lamp should be on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_459,,"
    # Preconditions: None.

    # Low-level actions: pick up the remote control.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the remote control!"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Postconditions: holding the remote control.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_764,,"
    # Preconditions: None.

    # Low-level actions: pick up the object (credit card).
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the credit card!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the credit card.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1126,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_991,,"
    # Preconditions: The candle must not be currently held.

    # Low-level actions to pick up the candle.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the candle."")
    except Exception as e:
        print(""Execution failure:"", str(e))
        return False

    # Postconditions: We should be holding the candle.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObject_92,,"
    # Preconditions: The candle must be held.

    if not env_state.holds(object_id):
        print(""Not holding the candle to place."")
        return False, env_state

    # Low-level actions to put the candle on the countertop.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the candle on the countertop."")
    except Exception as e:
        print(""Could not place the candle on the countertop:"", str(e))
        return False, env_state

    # Postconditions: The candle should be on the countertop and not held anymore.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_396,,"
    # Preconditions: None.
    
    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_82,,"
    # Preconditions: the lamp is not already on.
    if env_state.isToggled(object_id):
        print(""The lamp is already on, no Action required."")
        return True, env_state
        
    # Low-level actions: turn the lamp on.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""The lamp has been turned on!"")
    except:
        print(""Execution failure while trying to toggle on the lamp."")
        return False, env_state

    # Postconditions: the lamp is on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_520,,"
    # Preconditions: the object is not already held.
    if env_state.holds(object_id):
        print(""Already holding the laptop, no action required."")
        return True, env_state

    # Low-level actions: pick up the laptop.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the laptop!"")
    except:
        print(""Execution failure while trying to pick up the laptop."")
        return False, env_state

    # Postconditions: holding the laptop.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_962,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato!"")
    except:
        print(""Execution failure when trying to pick up a tomato..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_636,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: open the microwave if it's not open.
    if (not env_state.opened(receptacle_object_id)):
        try:
            action = OpenObject(args={'object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(f""Successfully opened the microwave!"")
        except:
            print(""Execution failure when trying to open the microwave..."")
            return False, env_state

    # Low-level actions: put the tomato in the microwave.
    try:
        print(""Trying to put the tomato in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Successfully put the tomato in the microwave: {success}"")
    except:
        print(""Failure, could not place the tomato in the microwave."")
        return False, env_state

    # Postconditions: not holding the tomato and the tomato is in the microwave.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_113,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_17,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object, the stove burner should be off (not hot).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    if (env_state.isHot(receptacle_object_id)):
        try:
            action = ToggleObjectOff(args={'object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Successfully turned off stove burner."")
        except:
            print(""Execution failure when trying to turn off stove burner."")
            return False

    # Low-level actions: turn on the stove burner to heat up the tomato.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stove burner turned on to warm the tomato."")
    except:
        print(""Execution failure when trying to turn on stove burner."")
        return False

    # Simulate the process of heating by waiting; Not coded as per API limitation.

    # Low-level actions: turn off the stove burner after heating up the tomato.
    try:
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stove burner turned off after warming the tomato."")
    except:
        print(""Execution failure when trying to turn off stove burner."")
        return False

    # Postconditions: the tomato is warmed.
    # No explicit way to check if the tomato has been warmed, no env_state.isWarm. Assuming heating succeeded.
    final_env_state = perceive(env)
    return True, final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_477,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: put the tomato in the sink basin.
    try:
        print(""Trying to put the warmed tomato in the sink basin."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the tomato in the sink basin."")
        return False, env_state

    # Postconditions: not holding the tomato and the tomato is in the sink basin.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1097,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure when picking up the potato..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_267,,"
    # Preconditions: None.

    # Low-level actions: pick up the apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1038,,"
    # Preconditions: None.
    
    # Low-level actions: find the object and pick it up.
    try:
        # Assuming that 'cellphone' is present in the environment and visible.
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the cellphone!"")
        else:
            print(""Failed to pick up the cellphone."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cellphone.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id), final_env_state)
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_519,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The robot should be holding the cellphone.
    if not env_state.holds(object_id):
        print(""Failure, not holding the cellphone."")
        return False, env_state

    # Low-level actions: put the cellphone on the desk.
    try:
        # Assuming that 'desk' is within reachable distance.
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully put the cellphone on the desk."")
        else:
            print(""Failed to put the cellphone on the desk."")
            return False
    except:
        print(""Failure, could not place the cellphone on the desk."")
        return False, env_state

    # Postconditions: The robot is not holding the cellphone, and the cellphone is now on the desk.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Cellphone is successfully moved to the desk."")
        return True, final_env_state
    else:
        print(""Cellphone is not on the desk."")
        return False, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1048,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the keychain!"")
        else:
            print(""Failed to pick up the keychain."")
            return False
    except Exception as e:
        print(""Execution failure while picking up the keychain:"", str(e))
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_271,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the keychain."")
        return False, env_state

    # Low-level actions: put the object on the receptacle (sofa).
    try:
        print(""Trying to put the keychain on the sofa."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully placed the keychain on the sofa!"")
        else:
            print(""Failed to place the keychain on the sofa."")
            return False
    except Exception as e:
        print(""Failure, could not place the keychain on the sofa:"", str(e))
        return False, env_state

    # Postconditions: not holding the object and the object is on the receptacle.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1009,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cellphone!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_195,,"
    # Preconditions: The object must be a toggleable lamp.
    if (not env_state.toggleable(object_id)):
        print(""Failure, object is not toggleable."")
        return False, env_state

    # Low-level actions: turn on the lamp.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOn for {object_id} is: {success}"")
    except:
        print(""Failure, could not toggle on the object."")
        return False, env_state

    # Checking if the postcondition are correct: lamp is toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_27,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the keychain!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the keys.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1123,,"
    # Preconditions: None.

    # Low-level actions: pick up the apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not pick up the apple."")
        print(""Successfully picked up an apple."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_73,,"
    # Preconditions: None.

    # Low-level actions: pick up the object (mug).
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_48,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object (mug).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding mug."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the mug into the microwave.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the mug in the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: turn the microwave on to heat the mug.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the mug is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObjectFromReceptacle_27,,"
    # Preconditions: the cup is on the dining table.

    # Low-level actions: pick up the white cup from the dining table.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the white cup from the dining table."")
        else:
            print(""Failed to pick up the white cup from the dining table."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the white cup.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_878,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the soap!"")
    except:
        print(""Execution failure in picking up the soap."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_9,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object (soapbar).
    if not env_state.holds(object_id):
        print(""Not holding the soapbar; cannot proceed to place it."")
        return False, env_state

    # Low-level actions: put the object in the receptacle (bathtubbasin).
    try:
        print(""Attempting to place the soapbar on the edge of the bathtub."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Execution failure in placing the soapbar."")
        return False, env_state

    # Postconditions: soapbar is no longer held and is now in the receptacle.
    final_env_state = perceive(env)
    return not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_340,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cup."")
    except:
        print(""Execution failure when trying to pick up the cup."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_30,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the cup."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave is opened."")
    except:
        print(""Execution failure when trying to open the microwave."")
        return False

    # Low-level actions: put the cup in the microwave.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Cup placed inside the microwave."")
    except:
        print(""Failure when trying to place the cup inside the microwave."")
        return False, env_state

    # Low-level actions: heat the cup by closing the microwave and turn it on.
    try:
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave is closed."")
    except:
        print(""Execution failure when trying to close the microwave."")
        return False

    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave is turned on and is heating the cup."")
    except:
        print(""Failure when trying to heat the cup."")
        return False, env_state

    # Assuming there is some time delay needed for heating, we would insert a wait here.
    # wait_for_heating() 

    # Low-level actions: turn off the microwave and open it.
    try:
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave is turned off."")
    except:
        print(""Failure when trying to turn off the microwave."")
        return False

    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave is opened again."")
    except:
        print(""Execution failure when trying to open the microwave again."")
        return False

    # Low-level actions: pick up the heated cup from the microwave.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated cup."")
    except:
        print(""Execution failure when trying to pick up the heated cup."")
        return False

    # Postconditions: holding the heated cup.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_642,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated cup.
    if (not (env_state.holds(object_id) and env_state.isHot(object_id))):
        print(""Failure, not holding a heated cup."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Fridge is opened."")
    except:
        print(""Execution failure when trying to open the fridge."")
        return False

    # Low-level actions: put the heated cup in the fridge.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Heated cup placed inside the fridge."")
    except:
        print(""Failure when trying to place the heated cup inside the fridge."")
        return False, env_state

    # Postconditions: not holding the cup and the cup is in the fridge.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_542,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the bread!"")
        else:
            print(""Failed to pick up the bread."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_194,,"
    # Preconditions: the lamp needs to be toggleable and off.
    if (not env_state.toggleable(object_id)) or (env_state.isToggled(object_id)):
        print(""The lamp is not toggleable or already on."")
        return False, env_state

    # Low-level actions: turn on the floor lamp.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the floor lamp!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: the lamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_64,,"
    # Preconditions: None.

    # Low-level actions: pick up the pen to examine it.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pen!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: holding the pen.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_467,,"
    # Preconditions: None.

    # Low-level actions: pick up the object (pillow).
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a pillow!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object (pillow).
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_356,,"
    # Preconditions: None.

    # Low-level actions: pick up the keychain.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the keychain!"")
    except:
        print(""Execution failure when trying to pick up the keychain..."")
        return False

    # Postconditions: Holding the keychain.
    final_env_state = perceive(env)
    if final_env_state.holds(object_id):
        print(""Holding the keychain confirmed."")
        return True, final_env_state
    else:
        print(""Failed to confirm holding the keychain."")
        return False, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_548,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple."")
    except:
        print(""Execution failure, unable to pick up the apple."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_228,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except Exception as e:
        print(""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1102,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a glass bottle."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_112,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the wine bottle!"")
    except:
        print(""Execution failure picking up wine bottle..."")
        return False

    # Postconditions: holding the wine bottle.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_866,,"
    # Preconditions: None.
    
    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_706,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bowl!"")
    except:
        print(""Execution failure when trying to pick up the bowl..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_769,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: should be holding the bowl.
    if (not env_state.holds(object_id)):
        print(""Failure: not holding the bowl."")
        return False, env_state

    # Low-level actions: put the bowl on the coffee table.
    try:
        print(""Trying to set the bowl on the coffee table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure: could not set the bowl on the coffee table."")
        return False, env_state

    # Postconditions: not holding the bowl and the bowl is on the coffee table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Success: bowl is now on the coffee table."")
        return True, final_env_state
    else:
        print(""Failure: bowl is not on the coffee table."")
        return False, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_569,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_123,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_279,,"
    # Preconditions: None.

    # Low-level actions: pick up the CD object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the CD."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the CD.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
ToggleObjectOn_54,,"
    # Preconditions: The lamp must be toggleable and currently off.
    if (not env_state.toggleable(object_id)) or env_state.isToggled(object_id):
        print(""Lamp is not toggleable or is already on."")
        return False, env_state

    # Low-level actions: turn on the desk lamp.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the desk lamp."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: The desk lamp will be on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_705,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the CD and there should be a desk under the light.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the CD."")
        return False, env_state

    # Low-level actions: put the CD in an appropriate location under the lamp (on a desk).
    try:
        print(""Trying to put the CD on the desk."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the CD on the desk."")
        return False, env_state

    # Postconditions: not holding the CD and the CD is on the desk under the light.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_371,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato."")
    except:
        print(""Execution failure while picking up a tomato."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_778,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the towel!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_693,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the candle."")
    except:
        print(""Execution failure when trying to pick up the candle."")
        return False

    # Postconditions: holding the object (candle).
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_301,,"
    # Preconditions: None.

    # Low-level actions: pick up the potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_882,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the keychain."")
    except:
        print(""Failed to pick up the keychain."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_370,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the keychain.
    if not env_state.holds(object_id):
        print(""Not holding the keychain, cannot place it."")
        return False, env_state

    # Low-level actions: put the keychain in the dresser.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Placed the keychain on the dresser: {success}"")
    except:
        print(""Failed to place the keychain on the dresser."")
        return False, env_state

    # Postconditions: keychain is on the dresser.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_577,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_992,,"
    # Preconditions: None.

    # Low-level actions: pick up the spatula.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the spatula!"")
    except:
        print(""Execution failure picking up the spatula..."")
        return False

    # Postconditions: holding the spatula.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_474,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up remote control!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    if final_env_state.holds(object_id):
        print(""Now holding the remote control."")
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1050,,"
    # Preconditions: None.

    # Low-level actions: pick up the CD.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the CD."")
        else:
            print(""Failed to pick up the CD."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: Now holding the CD.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_666,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the CD.
    if not env_state.holds(object_id):
        print(""Failure: Not holding the CD."")
        return False, env_state

    # Low-level actions: Place the CD in the shelf.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully placed the CD in the shelf."")
        else:
            print(""Failed to place the CD in the shelf."")
            return False
    except Exception as e:
        print(f""Failure: Could not place the CD in the shelf due to {e}"")
        return False, env_state

    # Postconditions: CD is no longer held and is in the shelf.
    final_env_state = perceive(env)
    return not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_491,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_983,,"
    # Preconditions: None.

    # Low-level actions: pick up the object 'vase'.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the vase!"")
    except:
        print(""Execution failure in picking up vase..."")
        return False

    # Postconditions: the robot is holding the vase.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_709,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the newspaper."")
    except:
        print(""Execution failure when trying to pick up the newspaper..."")
        return False

    # Postconditions: holding the newspaper.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_833,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the newspaper.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the newspaper."")
        return False, env_state

    # Low-level actions: put the newspaper on the sofa.
    try:
        print(""Trying to place the newspaper on the sofa."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the newspaper on the sofa."")
        return False, env_state

    # Postconditions: not holding the newspaper and the newspaper is on the sofa.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Newspaper successfully moved to the sofa."")
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_598,,"
    # Preconditions: None

    # Low-level actions: pick up the tomato.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_728,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_416,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_56,,"
    # Preconditions: None.

    # Low-level actions: pick up the plate.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the plate."")
    except:
        print(""Execution failure while picking up the plate."")
        return False

    # Postconditions: holding the plate.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObjectFromReceptacle_7,,"
    # Preconditions: The object should be in the receptacle.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        print(""The object is not in the specified receptacle."")
        return False, env_state

    # Low-level actions: pick up the object from the receptacle.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pen from the dresser!"")
    except:
        print(""Execution failure in picking up the object..."")
        return False, env_state

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
TurnOnObject_0,,"
    # Preconditions: The object should be toggleable and not already on.
    if not env_state.toggleable(object_id) or env_state.isToggled(object_id):
        print(""The object is not toggleable or already on."")
        return False, env_state

    # Low-level actions: turn the object on.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned the lamp on!"")
    except:
        print(""Execution failure in turning on the object..."")
        return False, env_state

    # Postconditions: The object is on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1016,,"
    # Preconditions: None.

    # Low-level actions: pick up the mug.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
HeatObject_46,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding mug."")
        return False, env_state

    # Low-level actions: open the microwave.
    action = OpenObject(args={'object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: put the mug in the microwave.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Mug placed in the microwave"")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: close the microwave.
    action = CloseObject(args={'object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: turn on the microwave to heat the mug. 
    action = ToggleObjectOn(args={'object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Execution failure..."")
        return False, env_state

    # Simulating time passing for heating, assume it takes enough time for the mug to heat.

    # Low-level actions: turn off the microwave after heating the mug.
    action = ToggleObjectOff(args={'object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: open the microwave to retrieve the mug.
    action = OpenObject(args={'object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: pick up the heated mug.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Picked up the heated mug."")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: mug is hot and being held.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isHot(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1126,,"
    # Preconditions: None.

    # Low-level actions: pick up the egg.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the egg.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_492,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a pen."")
    except:
        print(""Could not pick up the pen."")
        return False

    # Postconditions: holding the pen.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_114,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pan!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the pan.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_85,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the plunger!"")
    except:
        print(""Failed to pick up the plunger!"")
        return False

    # Postconditions: holding the plunger.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_991,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except:
        print(""Failed to pick up the potato..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_488,,"
    # Preconditions: None.

    # Low-level actions: pick up the cloth.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cloth!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the cloth.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_423,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_411,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_438,,"
    # Preconditions: None.

    # Low-level actions: Pick up the alarm clock.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the alarm clock!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the alarm clock.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
TurnOnDeskLamp_0,,"
    # Preconditions: The desk lamp must be toggleable and not already on.

    if not env_state.toggleable(object_id):
        print(""Failure: Object is not toggleable."")
        return False, env_state

    if env_state.isToggled(object_id):
        print(""The desk lamp is already on."")
        return True, env_state

    # Low-level actions: Turn on the desk lamp for better visibility.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the desk lamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: The desk lamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_286,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the remote control!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_698,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the remote control."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the remote control in the armchair."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the remote control in the armchair."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_402,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_691,,"
    # Preconditions: None.

    # Low-level actions: pick up the pencil.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a pencil!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the pencil.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_553,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up lettuce!"")
    except:
        print(""Execution failure while picking up lettuce..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1018,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato."")
    except:
        print(""Execution failure: Could not pick up the tomato."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_665,,"
    # Preconditions: None.

    # Low-level actions: pick up the object 'lettuce'.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up lettuce!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the 'lettuce'.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_630,,"
    # Preconditions: The cellphone is assumed to be on top of a nightstand, which can be considered as a sidetable.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the cellphone."")
        else:
            print(""Failed to pick up the cellphone."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the cellphone.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_887,,"
    # Preconditions: None.

    # Low-level actions: pick up the bread.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_212,,"
    # Preconditions: None.

    # Low-level actions: pick up the soapbar.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the soapbar!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the soapbar.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1021,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the lettuce!"")
    except Exception as e:
        print(f""Execution failure while picking up lettuce: {e}"")
        return False

    # Postconditions: holding the lettuce.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_599,,"
    # Preconditions: None.

    # Low-level actions: pick up the object (egg).
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the egg.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_859,,"
    # Preconditions: None.

    # Low-level actions: pick up the potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a potato."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1091,,"
    # Preconditions: None.

    # Low-level actions: pick up the object (tomato).
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_897,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a potato!"")
    except:
        print(""Execution failure while trying to pick up a potato..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_158,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the egg.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_581,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up bread."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
CoolObject_103,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding bread."")
        return False, env_state

    # Low-level actions: open the fridge, place the bread inside, 
    # and close the fridge to chill it.
    try:
        action_open = OpenObject(args={'object_id': receptacle_object_id})
        success_open = act(env=env, action=action_open)
        action_put = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success_put = act(env=env, action=action_put)
        action_close = CloseObject(args={'object_id': receptacle_object_id})
        success_close = act(env=env, action=action_close)
        print(f""Successfully chilled the bread."")
    except:
        print(""Failure during cooling process."")
        return False, env_state

    # Postconditions: bread is chilled.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_613,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_912,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the credit card!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1067,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a mug!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_848,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the mug.
    if not env_state.holds(object_id):
        print(""Failure, not holding mug."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: put the mug in the fridge.
    try:
        print(""Trying to put the mug in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place mug in the fridge: {e}"")
        return False, env_state

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Successfully closed the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state
    
    # Assuming time passes for the mug to cool down or there's a mechanism to perceive the coolness.
    # Postconditions: mug is cool and in the fridge.
    final_env_state = perceive(env)
    return final_env_state.isCool(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_361,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the alarm clock!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_249,,"
    # Preconditions: None.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_946,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Execution failure..."")
            return False

        print(""Successfully picked up the lettuce."")
    except Exception as e:
        print(f""Failure while picking up lettuce: {e}"")
        return False

    # Postconditions: holding the lettuce.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
CoolObject_65,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the lettuce.
    if not env_state.holds(object_id):
        print(""Failure, not holding the lettuce."")
        return False, env_state

    # Low-level actions: open the fridge, put the lettuce in, close the fridge to cool it, and retrieve the lettuce.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)

        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        act(env=env, action=action)

        action = CloseObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)

        # Lettuce should be chilled now; open the fridge and retrieve the lettuce.
        action = OpenObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)
        
        action = PickupObject(args={'object_id':object_id})
        act(env=env, action=action)

        print(""Lettuce is chilled and picked up."")
    except Exception as e:
        print(f""Failure while chilling the lettuce: {e}"")
        return False, env_state

    # Postconditions: holding the chilled lettuce.
    final_env_state = perceive(env)
    return final_env_state.isCool(object_id) and final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_0,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the fork!"")
    except Exception as e:
        print(f""Execution failure with error {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObjectFromReceptacle_11,,"
    # Preconditions: Tomato is initially in the fridge.

    # Low-level actions: Open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Fridge is open."")
    except:
        print(""Unable to open fridge."")
        return False

    # Low-level actions: Pick up the tomato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Picked up the tomato."")
    except:
        print(""Could not pick up the tomato."")
        return False

    # Postconditions: now holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1114,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the potato."")
    except:
        print(""Execution failure: Unable to pick up the potato."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_909,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
OpenObject_39,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: None.

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the microwave is open.
    final_env_state = perceive(env)
    return (final_env_state.opened(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1116,,"
    # Preconditions: None.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
SliceObject_38,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding a slicing tool (knife).

    # If not holding a knife, attempt to pick it up - skipped for brevity.

    # Low-level actions: slice the tomato if it is not already sliced and is sliceable.
    if not env_state.isSliced(object_id) and env_state.sliceable(object_id):
        try:
            action = SliceObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Successfully sliced the tomato!"")
        except:
            print(""Execution failure..."")
            return False
    elif env_state.isSliced(object_id):
        print(""The tomato is already sliced."")
    else:
        print(""The tomato cannot be sliced."")
        return False

    # Postconditions: The tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_1118,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clock!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PutObjectInReceptacle_774,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the clock."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the clock in the dresser."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the clock in the dresser."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_519,,"
    # Preconditions: None.

    # Low-level actions: pick up the tomato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,1.5,0.7000000000000001,
PickupObject_723,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",1.05,2.5,0.42000000000000004,
FindAndPositionTowel_0,,"
    # Preconditions: The lamp is toggled on.
    if not env_state.isToggled(lamp_id):
        print(""Failure, lamp is not on."")
        return False, env_state

    # Low-level actions: Assuming the towel is not in the right position, place it somewhere the light is good.
    if not env_state.inViewOfLamp(object_id, lamp_id):
        try:
            # This is a pseudocode action, adjusting the towel's position or finding a spot under the lamp
            print(""Adjusting the towel's position for examination."")
            pseudoAction_AdjustTowelPosition(args={'object_id': object_id, 'lamp_id': lamp_id})
            print(""Towel positioned under the lamp."")
        except:
            print(""Execution failure while positioning towel..."")
            return False

    # Postconditions: Towel is in a position to be examined by the lamp.
    final_env_state = perceive(env)
    return final_env_state.inViewOfLamp(object_id, lamp_id), final_env_state
",0.05,0.5,0.1,
ExamineTowel_0,,"
    # Preconditions: Towel is positioned under the lamp.
    if not env_state.inViewOfLamp(object_id, lamp_id):
        print(""Failure, towel is not in view of lamp."")
        return False, env_state

    # Low-level actions: Examine the towel.
    try:
        # This is a pseudocode action, simulating the action of examining a towel.
        print(""Examining the towel with the lamp."")
        pseudoAction_ExamineTowel(args={'object_id': object_id, 'lamp_id': lamp_id})
        print(""Examination complete."")
    except:
        print(""Execution failure while examining towel..."")
        return False

    # Postconditions: Towel has been examined under lamp illumination.
    return True, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_459,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled mug.
    if (not (env_state.holds(object_id) and env_state.isCool(object_id))):
        print(""Failure, not holding a chilled mug."")
        return False, env_state

    # Low-level actions: put the chilled mug on the coffee machine(receptacle).
    try:
        print(""Trying to put the mug on the coffee machine."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except Exception as e:
        print(""Failure, could not place the chilled mug on the coffee machine."", e)
        return False, env_state

    # Postconditions: not holding the object and the object is on the coffee machine.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CoolObject_108,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the bottle.
    if not env_state.holds(object_id):
        print(""Failure, not holding bottle."")
        return False, env_state

    # Low-level actions: open the refrigerator.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Refrigerator opened successfully!"")
    except Exception as e:
        print(""Execution failure:"", e)
        return False

    # Low-level actions: put the bottle in the refrigerator.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Bottle is now chilling in the refrigerator."")
    except Exception as e:
        print(""Execution failure:"", e)
        return False

    # Postconditions: the bottle is in the refrigerator.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CloseObject_2,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: the refrigerator is open.

    # Low-level actions: close the refrigerator.
    try:
        action = CloseObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Refrigerator closed successfully!"")
    except Exception as e:
        print(""Execution failure:"", e)
        return False

    # Postconditions: the refrigerator is closed.
    final_env_state = perceive(env)
    return not (final_env_state.opened(object_id)), final_env_state
",0.05,0.5,0.1,
ThrowInTrashCan_0,,"
    # Preconditions: the bottle is in the refrigerator, which is now closed.

    # Intermediate actions: Open the refrigerator and retrieve the chilled bottle.
    if not env_state.holds(object_id):
        try:
            # Open fridge to retrieve the bottle.
            action = OpenObject(args={'object_id': ""fridge""})
            success = act(env=env, action=action)
            if success:
                # Pickup the bottle from fridge.
                action = PickupObject(args={'object_id': object_id})
                success = act(env=env, action=action)
                if not success:
                    print(""Failure picking up the chilled bottle."")
                    return False, env_state
            else:
                print(""Failure opening refrigerator."")
                return False, env_state
        except Exception as e:
            print(""Execution failure during retrieval:"", e)
            return False, env_state

    # Low-level actions: find the trash can near the paper towels and throw the bottle in it.
    try:
        # Assuming a FindReceptacleNearObject function gives us the correct id for trash can.
        receptacle_object_id = FindReceptacleNearObject(env_state, 'garbagecan', 'papertowelroll', relative_position)
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Bottle thrown in trash can successfully."")
    except Exception as e:
        print(""Execution Failure:"", e)
        return False, env_state

    # Postconditions: the bottle is in the trash can.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_1050,,"
    # Preconditions: microwave is open.
    
    # Checking if the mug is in the microwave.
    if not env_state.inReceptacle(object_id, 'microwave'):
        print(""Mug is not in the microwave."")
        return False, env_state

    # Low-level actions: pick up the mug from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug from the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
CloseObject_9,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: the microwave was opened previously.
    
    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the microwave!"")
    except:
        print(""Execution failure, could not close the microwave..."")
        return False

    # Postconditions: the microwave is closed.
    final_env_state = perceive(env)
    return (not final_env_state.isOpen(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_379,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: put the mug in the cabinet.
    try:
        print(""Trying to put the mug in the cabinet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the mug in the cabinet!"")
    except:
        print(""Failure, could not place the mug in the cabinet."")
        return False, env_state

    # Postconditions: not holding the mug and the mug is in the cabinet.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
OpenObject_47,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: None.

    # Low-level actions: Open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: The fridge is now open.
    final_env_state = perceive(env)
    return (final_env_state.isOpen(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_59,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced apple, and the fridge must be open.
    if (not env_state.holds(object_id)) or (not env_state.opened(receptacle_object_id)):
        print(""Failure, either not holding the apple slice or the fridge is not open."")
        return False, env_state

    # Low-level actions: put the apple slice in the fridge.
    try:
        print(""Trying to put apple slice in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place apple slice in fridge."")
        return False, env_state

    # Postconditions: not holding the apple slice and the apple slice is in the fridge.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_90,,"
    # Preconditions: None.

    # Low-level actions: pick up the mug. This is for the purpose of inspecting it comfortably.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure, couldn't pick up the mug."")
        return False, env_state

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_699,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if not env_state.holds(object_id):
        print(""Not holding the tomato, cannot put it on the countertop."")
        return False

    # Low-level actions: put the tomato on the countertop.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Placed the tomato on the countertop."")
        else:
            print(""Failed to place the tomato on the countertop."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: The tomato is on the countertop.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id)
",0.05,0.5,0.1,
SliceObject_229,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The tomato should be on the countertop and not already sliced.
    if not env_state.inReceptacle(object_id, 'countertop') or env_state.isSliced(object_id):
        print(""The tomato is not on the countertop or it is already sliced."")
        return False

    # Low-level actions: slice the tomato.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully sliced the tomato."")
        else:
            print(""Failed to slice the tomato."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: The tomato is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id)
",0.05,0.5,0.1,
SliceObject_293,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
# Preconditions: the object must not already be sliced.
if (env_state.isSliced(object_id)):
    print(""Object is already sliced."")
    return True, env_state

# Low-level actions: slice the object.
try:
    action = SliceObject(args={'object_id':object_id})
    success = act(env=env, action=action)
    print(""Successfully sliced a tomato!"")
except:
    print(""Execution failure..."")
    return False

# Postconditions: object is sliced.
final_env_state = perceive(env)
return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_30,,"
# Preconditions: the object must be sliceable and not already hot.
if (env_state.isHot(object_id) or not env_state.heatable(object_id)):
    print(""Object is already hot or not heatable."")
    return True, env_state

# Low-level actions: turn on heat source to cook the object.
try:
    action = ToggleObjectOn(args={'object_id':heat_source_id})
    success = act(env=env, action=action)
    print(""Heat source is now on, cooking the tomato slice."")
except:
    print(""Execution failure..."")
    return False

# Wait for the object to cook (this would be a time-based action in a real scenario).
# In this hypothetical API we act as if waiting is not required.
# Postconditions: object is hot.
final_env_state = perceive(env)
return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_282,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
# Preconditions: we should be holding the cooked tomato slice.
if (not env_state.holds(object_id) or not env_state.isHot(object_id)):
    print(""Failure, not holding a hot tomato slice."")
    return False, env_state

# Low-level actions: open the refrigerator.
action = OpenObject(args={'object_id':receptacle_object_id})
success = act(env=env, action=action)
if not success:
    print(""Failed to open the refrigerator."")
    return False, env_state

# Low-level actions: put the object in the receptacle.
try:
    print(""Trying to put tomato slice in the refrigerator."")
    action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
    success = act(env=env, action=action)
    print(""Result of PutObject is: {success}"")
except:
    print(""Failure, could not place in refrigerator."")
    return False, env_state

# Low-level actions: close the refrigerator.
action = CloseObject(args={'object_id':receptacle_object_id})
success = act(env=env, action=action)
if not success:
    print(""Failed to close the refrigerator."")
    return False, env_state

# Postconditions: not holding the object, and the object is in the refrigerator.
final_env_state = perceive(env)
return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_124,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object, and the object should be clean.
    if (not env_state.holds(object_id)) or (not env_state.isClean(object_id)):
        print(""Failure, not holding a clean soap bar."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the soap bar in the trash can."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the soap bar in the trash can."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle (trash can).
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_280,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the potato.
    if (not env_state.holds('potato')):
        print(""Not holding the potato, cannot put it in the sink."")
        return False, env_state

    # Low-level actions: put the potato in the sink.
    try:
        print(""Attempting to put the potato in the sink."")
        action = PutObject(args={'object_id': 'potato', 'receptacle_object_id': 'sinkbasin'})
        success = act(env=env, action=action)
        print(f""Result of PutObject (potato in sink) is: {success}"")
    except:
        print(""Could not place the potato in the sink."")
        return False, env_state

    # Postconditions: The potato is in the sink.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle('potato', 'sinkbasin')), final_env_state
",0.05,0.5,0.1,
PickupObject_405,,"
    # Preconditions: None.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id': 'knife'})
        success = act(env=env, action=action)
        print(""Successfully picked up a knife!"")
    except:
        print(""Execution failure attempting to pick up knife."")
        return False

    # Postconditions: Holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds('knife')), final_env_state
",0.05,0.5,0.1,
SliceObject_82,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The knife is held and the potato is in the sink.
    if not (env_state.holds('knife') and env_state.inReceptacle('potato', 'sinkbasin')):
        print(""Cannot slice the potato, either not holding a knife or the potato is not in the sink."")
        return False, env_state

    # Low-level actions: Slice the potato.
    try:
        print(""Attempting to slice the potato."")
        action = SliceObject(args={'object_id': 'potato'})
        success = act(env=env, action=action)
        print(f""Result of SliceObject (potato) is: {success}"")
    except:
        print(""Could not slice the potato."")
        return False, env_state

    # Postconditions: The potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced('potato')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_843,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and the object must be clean.
    if not (env_state.holds(object_id) and env_state.isClean(object_id)):
        print(""Failure, not holding a clean tomato."")
        return False, env_state

    # Low-level actions: put the object on the receptacle (counter).
    try:
        print(""Trying to place the clean tomato on the counter."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the tomato on the counter."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the counter.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_812,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object (hot potato).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the heated potato."")
        return False, env_state

    # Low-level actions: put the potato in the sink basin.
    try {
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Put the potato in the sink: {success}"")
    except:
        print(""Failure, could not place the heated potato in the sink."")
        return False, env_state

    # Postconditions: not holding the potato and heated potato is in the sink basin.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
OpenReceptacle_0,,"
    # Preconditions: None.

    # Low-level actions: open the receptacle (fridge).
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the fridge is open.
    final_env_state = perceive(env)
    return final_env_state.opened(receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_350,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the object and the fridge should be open.
    if not (env_state.holds(object_id) and env_state.opened(receptacle_object_id)):
        print(""Failure, either not holding object or fridge is not open."")
        return False, env_state

    # Low-level actions: put the object in the receptacle (fridge).
    try:
        print(""Trying to put the vase in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the vase in the fridge."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
CloseReceptacle_0,,"
    # Preconditions: The fridge should be open.
    if not env_state.opened(receptacle_object_id):
        print(""Failure, the fridge is not open."")
        return False, env_state

    # Low-level actions: close the receptacle (fridge).
    try:
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the fridge is closed.
    final_env_state = perceive(env)
    return (not final_env_state.opened(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
SliceObject_137,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
# Preconditions: Must be holding the bread object.
if (not env_state.holds(object_id)):
    print(""Failure: not holding the bread to slice."")
    return False, env_state

# If the bread isn't already sliced, slice it.
if (not env_state.isSliced(object_id)):
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the bread."")
    except:
        print(""Execution failure when attempting to slice the bread."")
        return False
else:
    print(""The bread is already sliced."")

# Postconditions: Bread is sliced.
final_env_state = perceive(env)
return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_432,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
# Preconditions: Bread should be warm and in hand.
if (not env_state.isHot(object_id) or not env_state.holds(object_id)):
    print(""Failure: bread is not warm or not being held."")
    return False, env_state

# Low-level actions: open the fridge, then put the bread in the fridge.
try:
    action = OpenObject(args={'object_id':'fridge'})
    success = act(env=env, action=action)
    print(f""Fridge opened: {success}"")
    action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
    success = act(env=env, action=action)
    print(f""Put warm bread in fridge: {success}"")
    action = CloseObject(args={'object_id':'fridge'})
    success = act(env=env, action=action)
    print(f""Fridge closed: {success}"")
except:
    print(""Execution failure when attempting to put the warm bread in the fridge."")
    return False, env_state

# Postconditions: Bread is no longer in hand and is inside the fridge, fridge is closed.
final_env_state = perceive(env)
return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, 'fridge')), final_env_state
",0.05,0.5,0.1,
PickupObject_819,,"
    # Preconditions: the object is hot and cooked.
    if (not env_state.isHot(object_id)):
        print(""Failure, egg is not cooked."")
        return False, env_state

    # Low-level actions: pick up the cooked egg.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooked egg!"")
    except:
        print(""Execution failure, could not pick up the cooked egg..."")
        return False

    # Postconditions: holding the cooked egg.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_235,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooked egg.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the cooked egg."")
        return False, env_state

    # Low-level actions: put the cooked egg in the sink.
    try:
        print(""Trying to drop the cooked egg in the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the cooked egg in the sink."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_167,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the lettuce.
    if (not env_state.holds('lettuce')):
        print(""Failure, not holding lettuce."")
        return False, env_state

    # Low-level actions: put the lettuce on the table.
    try:
        print(""Trying to put lettuce on the table."")
        action = PutObject(args={'object_id': 'lettuce', 'receptacle_object_id': 'diningtable'})
        success = act(env=env, action=action)
        print(""Lettuce is now on the table!"")
    except Exception as e:
        print(f""Failure, could not place lettuce on the table: {e}"")
        return False, env_state

    # Postconditions: lettuce is on the table.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle('lettuce', 'diningtable')), final_env_state
",0.05,0.5,0.1,
PickupObject_1105,,"
    # Preconditions: None.

    # Low-level actions: pick up the knife.
    try:
        action = PickupObject(args={'object_id': 'knife'})
        success = act(env=env, action=action)
        print(""Successfully picked up knife!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds('knife')), final_env_state
",0.05,0.5,0.1,
SliceObject_307,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the knife and the lettuce should be on the table.
    if (not env_state.holds('knife')) or (not env_state.inReceptacle('lettuce', 'diningtable')):
        print(""Failure, not holding knife or lettuce is not on the table."")
        return False, env_state

    # Low-level actions: slice the lettuce with the knife.
    try:
        print(""Trying to slice the lettuce."")
        action = SliceObject(args={'object_id': 'lettuce'})
        success = act(env=env, action=action)
        print(""Lettuce has been sliced!"")
    except Exception as e:
        print(f""Failure, could not slice the lettuce: {e}"")
        return False, env_state

    # Postconditions: lettuce should be sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced('lettuce')), final_env_state
",0.05,0.5,0.1,
CoolObject_94,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: We need to check if the potato slice is cool already, or if it is coolable.
    if not (env_state.isCool(object_id) or env_state.coolable(object_id)):
        print(""Failure, object not cool and not coolable."")
        return False, env_state

    # Preconditions: If the object isn't already cool, the object should be placed in the fridge to cool.
    if not env_state.isCool(object_id):
        # Open the fridge if it's not open.
        if not env_state.opened('fridge'):
            try:
                action = OpenObject(args={'object_id': 'fridge'})
                success = act(env=env, action=action)
                if not success:
                    print(""Failure, could not open fridge."")
                    return False
            except:
                print(""Execution failure..."")
                return False

        # Put the potato slice into the fridge.
        try:
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
            success = act(env=env, action=action)
            if not success:
                print(""Failure, could not place object in fridge."")
                return False
        except:
            print(""Execution failure..."")
            return False

        # Assuming there's a wait for the object to cool down. This is simplified as immediate.

        # Take the potato slice out of the fridge.
        try:
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            if not success:
                print(""Failure, could not pick up object from fridge."")
                return False
        except:
            print(""Execution failure..."")
            return False

        # Close the fridge.
        try:
            action = CloseObject(args={'object_id': 'fridge'})
            success = act(env=env, action=action)
        except:
            print(""Execution failure..."")

    # Postconditions: the potato slice is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_259,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The object must be a cool potato slice, and we should be holding the object.
    if not (env_state.isSliced(object_id) and env_state.isCool(object_id) and env_state.holds(object_id)):
        print(""Failure, preconditions not met: object must be a sliced, cool potato, and must be held."")
        return False, env_state

    # Low-level actions: put the object in the sinkbasin.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure, could not place object in sinkbasin."")
            return False
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: the object is in the sinkbasin.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_64,,"
    # Preconditions: None.

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Stove burner turned on successfully!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: stove burner is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
PutObject_18,,"
    # Preconditions: holding the sliced tomato.
    if not env_state.holds(object_id):
        print(""Failure, not holding the sliced tomato."")
        return False, env_state

    # Low-level actions: put the sliced tomato on the stove burner.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Put sliced tomato on the stove burner successfully!"")
    except:
        print(""Failure, could not place the sliced tomato on the stove burner."")
        return False, env_state

    # Postconditions: sliced tomato is being heated on the stove burner.
    final_env_state = perceive(env)
    return (env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_27,,"
    # Preconditions: The tomato slice has been heated.

    # Low-level actions: pick up the heated tomato slice.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated tomato slice!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the heated tomato slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObject_100,,"
    # Preconditions: holding the heated tomato slice.
    if not env_state.holds(object_id):
        print(""Failure, not holding the heated tomato slice."")
        return False, env_state

    # Low-level actions: put the heated tomato slice in the sink.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the heated tomato slice in the sink successfully!"")
    except:
        print(""Failure, could not place the heated tomato slice in the sink."")
        return False, env_state

    # Postconditions: heated tomato slice is in the sink.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_116,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: the knife must be clean.
    if (not env_state.isClean(object_id)):
        print(""Failure, the knife is not clean."")
        return False, env_state

    # Low-level actions: pick up the knife if not already holding it.
    if (not env_state.holds(object_id)):
        try:
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up a knife!"")
        except:
            print(""Failure, could not pick up the knife."")
            return False, env_state

    # Low-level actions: put the clean knife in the receptacle 'large sink' or 'sinkbasin'.
    try:
        print(""Trying to place the clean knife in the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the knife in the sink."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_158,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object, and the object should be identified as an empty roll.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Assuming an empty roll means that the toilet paper roll is not slicable (i.e., has no more toilet paper on it),
    # and thus is an empty core.
    if (env_state.sliceable(object_id)):
        print(""Failure, the roll is not empty."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put in receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in receptacle."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_68,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: The object must be coolable and not cold yet.
    if env_state.coolable(object_id) and not env_state.isCool(object_id):
        # Further actions might be needed to cool the object, like putting it in the fridge.
        # Since this action is not defined in the API, we'll presume it's cool.
        pass
    return (True), env_state
",0.05,0.5,0.1,
OpenObject_41,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: The microwave must be closed.
    if not env_state.isToggled(receptacle_object_id):
        # Low-level actions: open the microwave.
        try:
            action = OpenObject(args={'object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(f""Result of OpenObject is: {success}"")
        except:
            print(""Failure, could not open the microwave."")
            return False, env_state
        # Postconditions: the microwave is open.
        final_env_state = perceive(env)
        return final_env_state.isToggled(receptacle_object_id), final_env_state
    else:
        print(""Microwave already open or not a toggleable object."")
        return False, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_48,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the sliced potato and the microwave should be open.
    if env_state.holds(object_id) and env_state.isToggled(receptacle_object_id):
        # Low-level actions: put the cold potato slice in the microwave.
        try:
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(f""Result of PutObject is: {success}"")
        except:
            print(""Failure, could not place the potato slice in the microwave."")
            return False, env_state
        # Postconditions: Not holding the potato slice and it's in the microwave.
        final_env_state = perceive(env)
        return ((not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state)
    else:
        print(""Preconditions not met for putting potato slice in the microwave."")
        return False, env_state
",0.05,0.5,0.1,
PickupObject_385,,"
    # Preconditions: the apple is hot.
    if (not env_state.isHot(object_id)):
        print(""Failure, the apple is not hot."")
        return False, env_state

    # Low-level actions: pick up the apple again.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the hot apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_24,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the hot apple.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the hot apple."")
        return False, env_state

    # Low-level actions: put the hot apple in the sink.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the hot apple in the sink."")
    except:
        print(""Failure, could not place the hot apple in the sink."")
        return False, env_state

    # Postconditions: not holding the hot apple and the apple is in the sink.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_106,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure while trying to open the fridge..."")
        return False, env_state

    # Low-level actions: put the mug in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the mug in the fridge."")
    except:
        print(""Failure while trying to place the mug in the fridge."")
        return False, env_state

    # Waiting period for chilling could go here, but assuming instant cooling for simplicity.

    # Low-level actions: open the fridge again to retrieve the mug.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Re-opened the fridge to retrieve the mug."")
    except:
        print(""Execution failure while trying to re-open the fridge..."")
        return False, env_state

    # Pick up the mug after it has been chilled.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Picked up the chilled mug!"")
    except:
        print(""Execution failure while trying to pick up the chilled mug..."")
        return False, env_state

    # Postconditions: holding the chilled mug.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id) and final_env_state.isCool(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_477,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the chilled mug.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding a chilled mug."")
        return False, env_state

    # Low-level actions: put the chilled mug in the cabinet.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the chilled mug in the cabinet."")
    except:
        print(""Failure while trying to put the chilled mug in the cabinet."")
        return False, env_state

    # Postconditions: the chilled mug is in the cabinet.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
SliceObject_232,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding the apple.
    if not env_state.holds(object_id):
        print(""Failure, not holding object."")
        return False

    # Low-level actions: slice the apple.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except Exception as e:
        print(""Execution failure: "", str(e))
        return False
    return True
",0.05,0.5,0.1,
ToggleObjectOn_160,,"
    # Preconditions: None.

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner!"")
    except Exception as e:
        print(""Execution failure: "", str(e))
        return False
    return True
",0.05,0.5,0.1,
PutObject_90,,"
    # Preconditions: holding the sliced apple.
    if not env_state.holds(object_id):
        print(""Failure, not holding the object."")
        return False

    # Low-level actions: put the sliced apple on the hot stove burner to heat it up.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the apple on the stove burner!"")
    except Exception as e:
        print(""Execution failure: "", str(e))
        return False

    # Simulating heating time.
    time.sleep(5)

    return True
",0.05,0.5,0.1,
PickupObject_963,,"
    # Preconditions: The apple chunk is hot.

    # Low-level actions: pick up the hot chunk of apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot chunk of apple!"")
    except Exception as e:
        print(""Execution failure: "", str(e))
        return False

    return True
",0.05,0.5,0.1,
PutObjectInReceptacle_440,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the hot chunk of apple.
    if not env_state.holds('apple'):
        print(""Failure, not holding the hot chunk of apple."")
        return False

    # Low-level actions: put the hot chunk of apple in the fridge (acting as a freezer).
    try:
        action = PutObject(args={'object_id':'apple', 'receptacle_object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully put the hot chunk of apple in the fridge/freezer!"")
    except Exception as e:
        print(""Execution failure: "", str(e))
        return False

    return True
",0.05,0.5,0.1,
HeatObject_131,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object and the microwave must be able to heat the object.
    if (not env_state.holds(object_id)) or (not env_state.heatable(object_id)):
        print(""Failure, not holding the cup or the cup is not heatable."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: put the object in the microwave (heating receptacle).
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Cup placed in the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave closed."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: turn on the microwave.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave turned on."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: turn off the microwave after heating.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave turned off."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: open the microwave again.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave opened."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: retrieve the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Heated cup picked up from the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: object is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_393,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: object should be hot and we should be holding it.
    if not env_state.holds(object_id) or not env_state.isHot(object_id):
        print(""Failure, not holding a hot cup."")
        return False, env_state

    # Low-level actions: put the object on the shelf.
    try:
        print(""Trying to put the heated cup on the shelf."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Heated cup placed on the shelf."")
    except Exception as e:
        print(f""Failure, could not place the cup on the shelf: {e}"")
        return False, env_state

    # Postconditions: not holding the object and the object is on the shelf.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_756,,"
    # Preconditions: apple is not already being held and it's in the fridge.
    if (env_state.holds(object_id)):
        print(""Object is already being held."")
        return False, env_state

    if (not env_state.inReceptacle(object_id, 'fridge')):
        print(""Apple is not in the fridge."")
        return False, env_state

    # Low-level actions: pick up the apple from the fridge.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: apple is being held.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
SliceObject_48,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: apple is being held and is sliceable.
    if (not env_state.holds(object_id)):
        print(""Not holding the apple."")
        return False, env_state
    
    if (not env_state.sliceable(object_id)):
        print(""Apple can't be sliced."")
        return False, env_state

    # Low-level actions: slice the apple.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: apple is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_119,,"
    # Preconditions: stove burner is available to heat the apple.
    if (env_state.isToggled(object_id)):
        print(""Stove burner is already on."")
        return False, env_state
    
    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: stove burner is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
PutObject_81,,"
    # Preconditions: apple is sliced and we're holding it.
    if (not env_state.holds(object_id)):
        print(""Not holding the sliced apple."")
        return False, env_state
    
    if (not env_state.isSliced(object_id)):
        print(""Apple is not sliced."")
        return False, env_state

    # Low-level actions: put the sliced apple on the stove burner to heat.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced apple on the stove burner!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: apple is on the stove burner.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_970,,"
    # Preconditions: apple is now hot and sliceable.
    if (not env_state.isHot(object_id)):
        print(""Apple is not heated yet."")
        return False, env_state

    if (not env_state.isSliced(object_id)):
        print(""Apple is not sliced."")
        return False, env_state

    # Low-level actions: pick up the heated, sliced apple.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated, sliced apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: apple is being held.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_842,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: apple is hot and being held.
    if (not env_state.holds(object_id)):
        print(""Not holding the heated apple."")
        return False, env_state

    if (not env_state.isHot(object_id)):
        print(""Apple is not heated."")
        return False, env_state

    # Low-level actions: put the heated, sliced apple on the table.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the heated, sliced apple on the table!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: apple is on the table.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
HeatObject_136,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: The apple should be sliced.
    if not env_state.isSliced(object_id):
        print(""Failure, apple is not yet sliced."")
        return False, env_state

    # Low-level actions: Open the microwave.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave opened."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: Put the apple inside the microwave.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Apple placed inside the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: Close the microwave.
    try:
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave closed."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: Turn on the microwave.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave turned on."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Simulate heating time or check periodically until the apple is hot.

    # Low-level actions: Turn off the microwave.
    try:
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave turned off."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: The apple has been heated.
    final_env_state = perceive(env)
    return final_env_state.isHot(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_626,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The apple should be hot and inside the microwave.
    if not (env_state.isHot(object_id) and env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Failure, apple is not hot or not inside the microwave."")
        return False, env_state

    # Low-level actions: Open the microwave.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave opened."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False  

    # Low-level actions: Pick up the hot apple from the microwave.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Picked up the hot apple."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: Close the microwave.
    try {
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Microwave closed after retrieving the apple."")
    } except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: Place the heated apple slice on the end of the dining table.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'diningtable'})
        success = act(env=env, action=action)
        print(""Hot apple slice placed on the end of the dining table."")
    } except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: The apple is no longer held and is on the dining table.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, 'diningtable'), final_env_state
",0.05,0.5,0.1,
PickupObject_976,,"
    # Preconditions: The spoon must be clean.
    if(not env_state.isClean(object_id)):
        print(""Cannot pick up, the spoon is not clean."")
        return False, env_state

    # Low-level actions: pick up the clean spoon.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean spoon!"")
    except:
        print(""Execution failure when trying to pick up the clean spoon..."")
        return False

    # Postconditions: holding the clean spoon.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacleWithObject_0,,"
    # Preconditions: we should be holding the clean spoon and the drawer should contain the fork.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the clean spoon."")
        return False, env_state

    if (not env_state.inReceptacle('fork', receptacle_object_id)):
        print(""The drawer does not contain a fork."")
        return False, env_state

    # Low-level actions: put the spoon in the drawer.
    try:
        print(""Trying to put the clean spoon in the drawer with the fork."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the clean spoon in the drawer with the fork."")
    except:
        print(""Failure, could not place the spoon in the drawer with the fork."")
        return False, env_state

    # Postconditions: not holding the spoon and the spoon is in the drawer with the fork.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)) and (env_state.inReceptacle('fork', receptacle_object_id)):
        return True, final_env_state
    else:
        return False, final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_92,,"
    # Preconditions: stove burner must be toggleable and tomato must be sliced.
    if (not env_state.toggleable(object_id)) or (not env_state.isSliced('tomato')):
        print(""Failure, cannot toggle stove burner or tomato is not sliced."")
        return False, env_state

    # Low-level actions: turn the stove burner on.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: stove burner is on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,0.5,0.1,
PutObject_10,,"
    # Preconditions: object must be sliced and stove burner must be on.
    if (not env_state.isSliced(object_id)) or (not env_state.isToggled('stoveburner')):
        print(""Failure, tomato is not sliced or stove burner is not on."")
        return False, env_state

    # Low-level actions: put the object on the stove burner to heat.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the sliced tomato on the stove burner to heat!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is on the stove burner.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObject_83,,"
    # Preconditions: object must be heated and sliced.
    if (not env_state.isHot(object_id)) or (not env_state.isSliced(object_id)):
        print(""Failure, tomato is not hot or not sliced."")
        return False, env_state

    # Low-level actions: put the heated, sliced object in the sink.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the heated, sliced tomato in the sink!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is in the sink.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_539,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds('mug')):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: put the mug in the coffee machine.
    try:
        print(""Trying to put the mug in the coffee machine."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the mug in the coffee machine."")
        return False, env_state

    # Postconditions: not holding the mug and the mug is in the coffee machine.
    final_env_state = perceive(env)
    if (not final_env_state.holds('mug')) and (final_env_state.inReceptacle('mug', 'coffeemachine')):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_640,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced tomato.
    if not env_state.holds(object_id) or not env_state.isSliced(object_id):
        print(""Failure, not holding a sliced tomato."")
        return False, env_state

    # Low-level actions: put the sliced tomato in the fridge.
    try:
        print(""Trying to put the sliced tomato in the fridge."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place sliced tomato in the fridge: {e}"")
        return False, env_state

    # Postconditions: not holding the sliced tomato and the tomato is in the fridge.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_1051,,"
    # Preconditions: None.

    # Low-level actions: pick up the laptop to examine it.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the laptop for examination."")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: holding the laptop.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
HeatObject_94,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: object is heatable. We assume we are still holding the object.
    if (not env_state.heatable(object_id)) or (not env_state.holds(object_id)):
        print(""Object cannot be heated or is not being held."")
        return False

    # Low-level actions: toggle the heat source on.
    try:
        action = ToggleObjectOn(args={'object_id':heat_source_id})
        success = act(env=env, action=action)
        print(""Successfully toggled on the heat source!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: place the object on heat source.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':heat_source_id})
        success = act(env=env, action=action)
        print(""Successfully placed the object on the heat source!"")
    except:
        print(""Failure, could not place on heat source."")
        return False

    # Low-level actions: toggle the heat source off.
    # We will assume that the bread needs some time to heat and that this is simulated automatically.
    try:
        action = ToggleObjectOff(args={'object_id':heat_source_id})
        success = act(env=env, action=action)
        print(""Successfully toggled off the heat source!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is hot and not being held.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_575,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_816,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: the object is heated and we are holding the object.
    # The goal does not make clear whether the heat should be maintained, 
    # but we will assume that it does not matter once the object is in the bin.
    if (not env_state.isHot(object_id)) or (not env_state.holds(object_id)):
        print(""Failure, object not hot or not being held."")
        return False, env_state

    # Low-level actions: put the heated object in the receptacle.
    try:
        print(""Trying to put in the receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in receptacle."")
        return False, env_state

    # Postconditions: not holding the heated object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_653,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooled pot.
    if (not env_state.holds(object_id) || !env_state.isCool(object_id)):
        print(""Failure, not holding the cooled pot."")
        return False, env_state

    # Low-level actions: place the cooled pot on the countertop.
    try:
        print(""Placing the cooled pot on the countertop."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Cooled pot is now on the countertop."")
    except:
        print(""Failure, could not place the cooled pot on the countertop."")
        return False, env_state

    # Postconditions: not holding the pot and the pot is on the countertop.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_64,,"
    # Preconditions: The stove burner must be toggleable.
    if not env_state.toggleable(object_id):
        print(""Failure, the stove burner can't be toggled."")
        return False, env_state

    # Low-level actions: Turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner!"")
    except:
        print(""Execution failure while trying to turn on the stove burner..."")
        return False, env_state

    # Postconditions: The stove burner is now on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,0.5,0.1,
CookSliceOfBread_0,,"
    # Preconditions: We should be holding a slice of bread, and the stove burner should be on.
    if not (env_state.isSliced(slice_object_id) and env_state.isToggled(stoveburner_id)):
        print(""Failure, bread is not sliced or stove burner is not on."")
        return False, env_state

    # Low-level actions: Simulate cooking the bread slice on the stove burner
    # Note: In a real environment, this might involve more actions or checks.
    print(""Simulate cooking the slice of bread."")
    
    # Postconditions: The bread slice is cooked.
    # This is a placeholder since the ""cook"" action is not defined in the API.
    # Assume the cooking step is successful.
    return True, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_129,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: should have a cooked slice of bread.
    # Note: We would normally check a predicate like `env_state.isCooked(object_id)`, if available.
    if not env_state.isSliced(slice_object_id):
        print(""Failure, bread is not sliced or not cooked."")
        return False, env_state

    # Low-level actions: put the cooked bread slice on the table.
    try:
        print(""Trying to put the cooked slice of bread on the table."")
        action = PutObject(args={'object_id': slice_object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the cooked bread slice on the table."")
        return False, env_state

    # Postconditions: not holding the bread slice and the bread slice is on the table.
    final_env_state = perceive(env)
    return (not final_env_state.holds(slice_object_id)) and (final_env_state.inReceptacle(slice_object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_692,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the CD.
    if not env_state.holds(object_id):
        print(""Failure, not holding the CD."")
        return False, env_state

    # Low-level actions: Place the CD on top of the dresser.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully placed the CD on the dresser."")
        else:
            print(""Failed to place the CD on the dresser."")
            return False, env_state
    except Exception as e:
        print(f""Failure, could not place the CD on the dresser: {e}"")
        return False, env_state

    # Postconditions: CD is on top of the dresser.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
SliceObject_238,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Tomato needs to be sliceable and held.
    if not env_state.holds(object_id) or not env_state.sliceable(object_id):
        print(""Cannot slice. Either not holding the tomato or it is not sliceable."")
        return False, env_state

    # Low-level actions: Slice the tomato.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not slice the tomato."")
            return False, env_state

        # Postconditions: The tomato has been sliced.
        final_env_state = perceive(env)
        if final_env_state.isSliced(object_id):
            print(""The tomato has been sliced."")
            return True, final_env_state
        else:
            print(""The tomato is still not sliced."")
            return False, final_env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_478,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the tomato slice.
    if not env_state.holds(object_id):
        print(""Failure, not holding object."")
        return False, env_state
    if not env_state.isSliced(object_id):
        print(""Failure, object is not sliced."")
        return False, env_state

    # Low-level actions: put the sliced and chilled tomato on the table.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not place the tomato slice on the table."")
            return False, env_state

        # Postconditions: not holding the object and the object is on the table.
        final_env_state = perceive(env)
        if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
            print('Successfully placed the tomato slice on the table.')
            return True, final_env_state
        else:
            print(""The tomato slice is either not on the table or still being held."")
            return False, final_env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state
",0.05,0.5,0.1,
CloseObject_9,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: the microwave needs to be closed in order to operate.

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the microwave!"")
    except:
        print(""Execution failure in closing the microwave..."")
        return False

    # Postconditions: microwave is closed.
    final_env_state = perceive(env)
    return (not env_state.isToggled(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
OpenObject_40,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: microwave needs to be opened to retrieve the apple.

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure in opening the microwave..."")
        return False

    # Postconditions: microwave is open.
    final_env_state = perceive(env)
    return final_env_state.isToggled(receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_287,,"
    # Preconditions: None.

    # Low-level actions: pick up the apple from the microwave.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple from the microwave!"")
    except:
        print(""Execution failure in picking up the apple..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
SliceObject_172,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the apple, and it has to be sliceable.

    # Validating preconditions.
    if not (env_state.holds(object_id) and env_state.sliceable(object_id)):
        print(""Cannot slice the apple: either not holding it or it's not sliceable."")
        return False, env_state

    # Low-level actions: slice the apple.
    # Note: The goal specifies to cut it into three slices, but the API only provides a single slice action.
    # We assume each slice operation cuts one slice, and we need to perform the action three times.
    try:
        for _ in range(3):  # Repeating the slice action three times.
            action = SliceObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            if not success:
                raise Exception(""Failed to slice the apple."")
            print(""Successfully sliced the apple!"")
    except:
        print(""Execution failure in slicing the apple..."")
        return False

    # Postconditions: apple is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,0.5,0.1,
HeatObject_97,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Opened the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: put the mug in the microwave.
    try:
        action = PutObject(args={'object_id': 'mug', 'receptacle_object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Placed the mug in the microwave."")
    except Exception as e:
        print(f""Failure, could not place mug in microwave: {e}"")
        return False, env_state

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Closed the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: toggle the microwave on to heat the mug.
    try:
        action = ToggleObjectOn(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        # Wait for the mug to heat up (not shown here).
        print(""Heating up the mug in the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: toggle the microwave off after heating the mug.
    try:
        action = ToggleObjectOff(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Turned off the microwave."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: open the microwave to take out the mug.
    try:
        action = OpenObject(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Opened the microwave to take out the mug."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: take the mug out of the microwave.
    try:
        action = PickupObject(args={'object_id': 'mug'})
        success = act(env=env, action=action)
        print(""Took out the heated mug."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the mug is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(""mug"")), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_231,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the hot mug.
    if (not (env_state.holds(""mug"") and env_state.isHot(""mug""))):
        print(""Failure, not holding hot mug."")
        return False, env_state

    # Low-level actions: put the hot mug in the cabinet.
    try:
        print(""Trying to put the mug in the cabinet."")
        action = PutObject(args={'object_id': 'mug', 'receptacle_object_id': 'cabinet'})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place mug in the cabinet: {e}"")
        return False, env_state

    # Postconditions: not holding the object and the mug is in the cabinet.
    final_env_state = perceive(env)
    if (not final_env_state.holds(""mug"")) and (final_env_state.inReceptacle(""mug"", ""cabinet"")):
        return True, final_env_state
",0.05,0.5,0.1,
HeatObject_100,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: holding the potato and stove burner is on.

    # Make sure the stove burner is on.
    if not env_state.isToggled(""stoveburner""):
        print(""Stove burner is not on."")
        return False, env_state

    # Low-level actions: put the potato on the stove burner to heat up.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Potato is now on the stove burner."")
    except:
        print(""Can't place the potato on the stove burner."")
        return False, env_state

    # Wait for object to heat up (Simulation of waiting not shown).

    # Postconditions: the object (potato) is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_508,,"
    # Preconditions: The potato is hot.

    if not env_state.isHot(""potato""):
        print(""The potato is not hot."")
        return False, env_state
    
    # Low-level actions: pick up the heated potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the hot potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_577,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the hot potato.

    # Verify you're holding the potato.
    if not env_state.holds(""potato""):
        print(""Not holding the potato."")
        return False, env_state

    # Low-level actions: put the hot potato in the sink basin.
    try:
        print(""Putting hot potato in the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the hot potato in the sink."")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: not holding the hot potato and the potato is in the sink.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_738,,"
    # Preconditions: None.

    # Low-level actions: pick up the kettle.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the kettle!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the kettle.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_541,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the clean kettle.
    if (not env_state.holds(object_id)) or (not env_state.isClean(object_id)):
        print(""Failure, either not holding kettle or it is not clean."")
        return False, env_state

    # Low-level actions: put the kettle on the countertop.
    try:
        print(""Trying to put the kettle on the countertop."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the kettle on the countertop."")
        return False, env_state

    # Postconditions: not holding the kettle and the kettle is on the countertop.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and        (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
HeatObject_37,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the sliced bread.
    if (not env_state.holds(object_id) or not env_state.isSliced(object_id)):
        print(""Failure, not holding sliced bread."")
        return False, env_state

    # Low-level actions: turn on the stove burner to heat the object.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Stove burner turned on: {success}"")
    except:
        print(""Failure, could not turn on stove burner."")
        return False

    # Low-level actions: wait for the bread to heat.
    # This is a simulated wait, there should be a mechanism to check if the bread is hot enough.
    # For simplicity, we're not implementing that logic here.
    print(""Heating the sliced bread..."")

    # Low-level actions: turn off the stove burner after heating.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Stove burner turned off: {success}"")
    except:
        print(""Failure, could not turn off stove burner."")
        return False

    # Postconditions: bread is hot and sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id) and final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_861,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding a hot, sliced bread.
    if (not env_state.holds(object_id) or not env_state.isHot(object_id)):
        print(""Failure, not holding hot, sliced bread."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put in receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in receptacle."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_72,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_270,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the object, and it should be clean.
    if not env_state.holds(object_id):
        print(""Failure, not holding the object."")
        return False, env_state
    if not env_state.isClean(object_id):
        print(""Failure, the object is not clean."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the knife on the countertop."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the knife on the countertop."")
        return False, env_state

    # Postconditions: not holding the object, and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        print(""The knife is successfully placed on the countertop."")
        return True, final_env_state
    else:
        print(""The knife placement on the countertop failed."")
        return False, final_env_state
",0.05,0.5,0.1,
PickupObject_186,,"
    # Preconditions: The tomato is hot.

    # Low-level actions: pick up the hot tomato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot tomato!"")
    except:
        print(""Failed to pick up the hot tomato."")
        return False

    # Postconditions: holding the hot tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_817,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the hot tomato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding hot tomato."")
        return False, env_state

    # Low-level actions: put the hot tomato on the sidetable.
    try:
        print(""Trying to put the hot tomato on the sidetable."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the hot tomato on the sidetable."")
        return False, env_state

    # Postconditions: not holding the tomato and the tomato is on the sidetable.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_953,,"
    # Preconditions: the mug should be clean.

    if (not env_state.isClean(object_id)):
        print(""The mug is not clean, cannot be picked up for return."")
        return False, env_state

    # Low-level actions: pick up the clean mug.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean mug!"")
    except:
        print(""Execution failure when trying to pick up the clean mug..."")
        return False

    # Postconditions: holding the clean mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_611,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the clean mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the clean mug."")
        return False, env_state

    # Low-level actions: put the mug in the receptacle (coffee maker).
    try:
        print(""Trying to return the mug to the coffee maker."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the mug in the coffee maker."")
        return False, env_state

    # Postconditions: the clean mug is in the coffee maker.
    final_env_state = perceive(env)
    if (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
SliceObject_270,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Only slice the bread if it hasn't been sliced yet
    if not env_state.isSliced(object_id):
        try:
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully sliced the bread."")
            return True
        except:
            print(""Could not slice the bread."")
            return False
    else:
        print(""Bread is already sliced."")
        return True
",0.05,0.5,0.1,
ToggleObjectOn_159,,"
    try:
        # Assuming the toaster can heat the bread. Inserting it is abstracted away.
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        
        if not success:
            raise Exception(""Toaster couldn't be turned on or isn't available."")
        
        # Need to wait for the bread to get hot and the toaster to pop.
        # This could be abstracted in the environment simulation. Checking state until bread is hot.
        while not env_state.isHot(""bread""):
            continue
        
        print(""Bread is now hot."")
        return True
    except:
        print(""Could not heat the bread."")
        return False
",0.05,0.5,0.1,
PutObject_93,,"
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the hot slice of bread in the bin."")
        return True
    except:
        print(""Could not put the bread in the bin."")
        return False
",0.05,0.5,0.1,
PickupObject_150,,"
    # Preconditions: The pan should be chilled and not hot.

    # Checking if the pan is chilled and not hot before trying to pick it up.
    if (not env_state.isCool(object_id) or env_state.isHot(object_id)):
        print(""The pan is not chilled or it's still hot."")
        return False, env_state

    # Low-level actions: pick up the chilled pan.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled pan!"")
    except:
        print(""Execution failure in picking up the chilled pan..."")
        return False

    # Postconditions: holding the chilled pan.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_586,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled pan.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the chilled pan."")
        return False, env_state

    # Low-level actions: put the chilled pan on the counter.
    try:
        print(""Trying to put the chilled pan on the counter."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject (chilled pan on counter) is: {success}"")
    except:
        print(""Failure, could not place the chilled pan on the counter."")
        return False, env_state

    # Postconditions: not holding the object and the chilled pan is on the counter.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_228,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the lettuce and it must be sliced.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id)):
        print(""Failure, not holding the sliced lettuce."")
        return False, env_state

    # Low-level actions: put the lettuce in the fridge to cool.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the lettuce in the fridge to cool."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the lettuce is in the fridge.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
CoolObject_109,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: The lettuce must be in the fridge.
    if not env_state.inReceptacle(object_id, 'fridge'):
        print(""Failure, the lettuce is not in the fridge."")
        return False, env_state

    # Dummy action: We presume the environment automatically cools the object in the fridge over time. 
    # Here we would include the necessary steps for the cool down process, which may not be modelled in a simplified environment.

    # Postconditions: The lettuce should now be chilled.
    # In a real-world scenario, we'd wait or check until the lettuce is chilled.
    return env_state.isCool(object_id), env_state
",0.05,0.5,0.1,
PickupObject_799,,"
    # Preconditions: The lettuce must be chilled/sliced first.

    # Low-level actions: pick up the lettuce from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up chilled sliced lettuce!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the chilled sliced lettuce.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_524,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the chilled sliced lettuce.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding the chilled sliced lettuce."")
        return False, env_state

    # Low-level actions: put the cooled, sliced lettuce in the green bin (garbagecan).
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed chilled sliced lettuce in the green bin."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the lettuce is in the green bin.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
ExamineObject_10,,"
    # Preconditions: We should be holding the object and found the location with dim light.
    if not (env_state.holds(object_id) and location_id):
        print(""Failure, not holding the object or no location with dim light found."")
        return False, env_state

    # Low-level actions: Examine the object by the dim natural light.
    # Assuming examine to be a manual action looking at the object, since no API method is available.
    print(""Examining the keychain by the dim natural light of the living room."")
    # We assume examination issuccessful. In a real scenario, this would likely involve some vision system analysis.

    # Postconditions: Assumed successful examination.
    return True, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_648,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The lettuce should be sliced already and not held.
    if env_state.holds(""lettuce""):
        print(""Failure, cannot put down lettuce while holding it."")
        return False, env_state

    if not env_state.isSliced(""lettuce""):
        print(""Failure, lettuce is not sliced."")
        return False, env_state

    # Low-level actions: put the sliced lettuce on the dining table.
    try:
        print(""Trying to put on dining table."")
        action = PutObject(args={'object_id':""lettuce"", 'receptacle_object_id':""diningtable""})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place on dining table."")
        return False, env_state

    # Postconditions: sliced lettuce is on the dining table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(""lettuce"")) and (final_env_state.inReceptacle(""lettuce"", ""diningtable"")):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_12,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be cool.
    if (not env_state.holds(object_id)) or (not env_state.isCool(object_id)):
        print(""Failure, not holding object or object is not cool."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put in receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in receptacle."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_629,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The object should be hot and the agent should be holding the object.
    if not (env_state.isHot(object_id) and env_state.holds(object_id)):
        if not env_state.holds(object_id):
            # Pick up the object if not already held.
            try:
                action = PickupObject(args={'object_id': object_id})
                success = act(env=env, action=action)
            except:
                print(""Failure to pick up hot potato."")
                return False, env_state

        if not env_state.isHot(object_id):
            print(""Failure, the potato is not cooked."")
            return False, env_state

    # Low-level actions: put the cooked object in the trash can.
    try:
        print(""Trying to put the potato in the trash can."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the potato in the trash can."")
        return False, env_state

    # Postconditions: The cooked object is in the trash can and we are no longer holding it.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CoolObject_21,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: potato is sliced.
    if (not env_state.isSliced(object_id)):
        print(""Failure, potato is not sliced."")
        return False, env_state
    
    # Low-level actions: cool the sliced potato by placing it in the fridge.
    try:
        # Assuming 'fridge' is the ID for the fridge.
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced potato in the fridge to cool!"")
    except:
        print(""Execution failure..."")
        return False
    # Postconditions: potato is cooled.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_572,,"
    # Preconditions: potato is sliced and cooled.
    if (not env_state.isSliced(object_id) or not env_state.isCool(object_id)):
        print(""Failure, potato is not prepared correctly."")
        return False, env_state
    
    # Low-level actions: pick up the sliced, cooled potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the sliced, cooled potato!"")
    except:
        print(""Execution failure..."")
        return False
    # Postconditions: holding the sliced, cooled potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_682,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the sliced, cooled potato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the sliced, cooled potato."")
        return False, env_state
    
    # Low-level actions: place the sliced, cooled potato on the table.
    try {
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced, cooled potato on the table!"")
    except:
        print(""Execution failure..."")
        return False
    # Postconditions: sliced, cooled potato is on the table.
    final_env_state = perceive(env)
    if (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
SliceObject_4,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if not env_state.holds(object_id):
        print(""Failure, not holding tomato."")
        return False, env_state

    # Check if the tomato is sliceable.
    if not env_state.sliceable(object_id):
        print(""Failure, tomato is not sliceable."")
        return False, env_state

    # Low-level actions: slice the tomato.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding a sliced tomato.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_116,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced tomato.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id)):
        print(""Failure, not holding sliced tomato."")
        return False, env_state

    # Low-level actions: put the sliced tomato on the stove burner.
    try:
        print(""Trying to put sliced tomato on stove burner."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place on stove burner."")
        return False, env_state

    # Postconditions: the sliced tomato is on the stove burner.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_48,,"
    # Preconditions: the sliced tomato is on the stove burner.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Failure, sliced tomato is not on stove burner."")
        return False, env_state

    # Low-level actions: turn on the stove burner to cook the tomato slice.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stove burner is now on!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the stove burner is on and the tomato slice will be cooking (getting hot).
    final_env_state = perceive(env)
    return (final_env_state.isToggled(receptacle_object_id)and final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOff_26,,"
    # Preconditions: the tomato slice has been heated (cooked).
    if not env_state.isHot(object_id):
        print(""Failure, tomato slice is not hot."")
        return False, env_state

    # Low-level actions: turn off the stove burner after cooking the tomato slice.
    try {
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stove burner is now off!"")
    } except {
        print(""Execution failure..."")
        return False
    }

    # Postconditions: the stove burner is off.
    final_env_state = perceive(env)
    return (not final_env_state.isToggled(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_876,,"
    # Preconditions: the tomato slice is cooked and the stove burner is off.

    # Low-level actions: pick up the cooked tomato slice.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a cooked tomato slice!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cooked tomato slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_454,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooked tomato slice.
    if not env_state.holds(object_id):
        print(""Failure, not holding cooked tomato slice."")
        return False, env_state

    # Low-level actions: put the cooked tomato slice in the refrigerator (fridge).
    try:
        print(""Trying to put cooked tomato slice in the refrigerator."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in the refrigerator."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the refrigerator.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_311,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the lettuce.
    if not env_state.holds(object_id):
        print(""Failure, not holding the lettuce."")
        return False, env_state

    # Low-level actions: put the lettuce on the table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the lettuce on the table."")
    except Exception as e:
        print(f""Failure, could not place the lettuce on the table: {e}"")
        return False, env_state

    # Postconditions: lettuce is on the table.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
SliceObject_216,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: the lettuce should be on the table, and the agent should have the knife.
    if not env_state.inReceptacle(object_id, 'diningtable') or not env_state.holds('knife'):
        print(""Failure, conditions not met for slicing."")
        return False, env_state

    # Low-level actions: slice the lettuce.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the lettuce."")
    except Exception as e:
        print(f""Failure, could not slice the lettuce: {e}"")
        return False

    # Postconditions: lettuce is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
PickupBowl_0,,"
    # Preconditions: None.

    # Low-level actions: pick up the bowl.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a bowl."")
        final_env_state = perceive(env)
    except:
        print(""Execution failure: Error picking up the bowl."")
        final_env_state = perceive(env)
        success = False

    # Postconditions: holding the bowl.
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PlaceBowlUnderLamp_0,,"
    # Preconditions: The bowl is held by the robot and the lamp is on.
    if (not env_state.holds(object_id)):
        print(""Failure: Not holding bowl."")
        return False, env_state
    if (not env_state.isToggled(""floorlamp"")):
        print(""Failure: Lamp is not on."")
        return False, env_state

    # Low-level actions: put the bowl under the lamp on a surface like a coffee table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed bowl under the lamplight."")
        final_env_state = perceive(env)
    except:
        print(""Execution failure: Error placing the bowl under the lamp."")
        final_env_state = perceive(env)
        success = False

    # Postconditions: The bowl is under the lamp.
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)) and (env_state.isToggled(""floorlamp"")), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_25,,"
    # Preconditions: the stove burner should be toggleable and off.
    if not (env_state.toggleable(object_id) and not env_state.isToggled(object_id)):
        print(""Failure, stove burner is either not toggleable or already on."")
        return False, env_state

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on a toggleable object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the stove burner is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
HeatObject_67,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: the tomato slice should be heatable and put on the stove burner.
    if not (env_state.heatable(object_id)):
        print(""Failure, object is not heatable."")
        return False, env_state

    # Assuming the system heats the object when placed on stoveburner
    # This block simulates the cooking process.
    # In a real system, you may have to wait for some time or check for 'isHot' status in a loop
    # Here we just set it as cooked for simplicity.
    env_state.setCooked(object_id)

    final_env_state = perceive(env)

    # Postconditions: the object is cooked.
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_112,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooked tomato slice.
    if not (env_state.holds(object_id) and env_state.isHot(object_id)):
        print(""Failure, not holding a cooked object."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put in receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place cooked tomato slice in the fridge."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
HeatObject_51,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the glass.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the glass."")
        return False, env_state

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure when attempting to open the microwave."")
        return False

    # Low-level actions: put the glass in the microwave to warm it.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the glass in the microwave!"")
    except:
        print(""Execution failure when attempting to place the glass in the microwave."")
        return False

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the microwave!"")
    except:
        print(""Execution failure when attempting to close the microwave."")
        return False

    # Low-level actions: turn on the microwave to warm the glass.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the microwave!"")
    except:
        print(""Execution failure when attempting to turn on the microwave."")
        return False

    # Low-level actions: turn off the microwave after a short duration.
    # Assume there is a wait function that creates a delay for the glass to warm.
    wait(duration=10)  # Wait for 10 seconds.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned off the microwave!"")
    except:
        print(""Execution failure when attempting to turn off the microwave."")
        return False

    # Postconditions: glass is warm.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
RetrieveObjectFromMicrowave_0,,"
    # Preconditions: glass should be in the microwave and microwave should be off.

    # Low-level actions: open the microwave if it's not already open.
    if not env_state.opened(receptacle_object_id):
        try:
            action = OpenObject(args={'object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(""Successfully opened the microwave to retrieve the glass!"")
        except:
            print(""Execution failure when attempting to open the microwave to retrieve the glass."")
            return False

    # Low-level actions: Pick up the warmed glass from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully retrieved the warmed glass from the microwave!"")
    except:
        print(""Execution failure when attempting to retrieve the glass from the microwave."")
        return False

    # Postconditions: holding the warmed glass.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_598,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the warmed glass.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the warmed glass."")
        return False, env_state

    # Low-level actions: put the warmed glass in the cabinet.
    try {
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the warmed glass in the cabinet!"")
    except:
        print(""Failure, could not place the warmed glass in the cabinet."")
        return False, env_state

    # Postconditions: not holding the glass and the glass is in the cabinet.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
OpenObject_28,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: None.

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Microwave is opened for bread."")
    except:
        print(""Execution failure when trying to open microwave..."")
        return False

    # Postconditions: microwave is open.
    final_env_state = perceive(env)
    return final_env_state
",0.05,0.5,0.1,
PutObject_43,,"
    # Preconditions: We should be holding the bread, and the microwave should be open.
    if not (env_state.holds(object_id) and env_state):
        print(""Not holding bread or microwave is not open."")
        return False, env_state

    # Low-level actions: put the bread in the microwave.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the bread in the microwave."")
    except:
        print(""Execution failure when trying to put bread in the microwave..."")
        return False, env_state

    # Postconditions: Bread is in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CloseObject_13,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: Bread should be in the microwave.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Bread is not in the microwave."")
        return False, env_state

    # Low-level actions: close the microwave.
    try:
        action = CloseObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Closed the microwave with bread inside."")
    except Exception as e:
        print(""Execution failure when trying to close microwave..."", str(e))
        return False, env_state

    # Postconditions: Microwave closed with bread inside.
    final_env_state = perceive(env)
    return final_env_state
",0.05,0.5,0.1,
SliceObject_284,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: We should be holding the object.
    if (not env_state.holds('tomato')):
        print(""Failure, not holding tomato."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': 'tomato'})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure slicing the tomato..."")
        return False

    # Postconditions: the object is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced('tomato'), final_env_state
",0.05,0.5,0.1,
HeatObject_23,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: The sliced object should be put on a heatable receptacle.
    if (not env_state.isSliced('tomato')):
        print(""Failure, the tomato is not sliced."")
        return False, env_state

    # Low-level actions: put the object on the stove burner.
    try:
        action = PutObject(args={'object_id': 'tomato', 'receptacle_object_id': 'stoveburner'})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced tomato on the stove burner!"")
    except:
        print(""Execution failure placing the tomato on the stove burner..."")
        return False

    # Low-level actions: turn on the stove burner to heat the object.
    try:
        action = ToggleObjectOn(args={'object_id': 'stoveburner'})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner to heat the tomato slice!"")
    except:
        print(""Execution failure turning on the stove burner..."")
        return False

    # Assuming some time has passed and the tomato is now hot,
    # the robot should turn off the stove burner.
    try:
        action = ToggleObjectOff(args={'object_id': 'stoveburner'})
        success = act(env=env, action=action)
        print(""Successfully turned off the stove burner!"")
    except:
        print(""Execution failure turning off the stove burner..."")
        return False

    # Postconditions: the object is hot.
    final_env_state = perceive(env)
    return final_env_state.isHot('tomato'), final_env_state
",0.05,0.5,0.1,
ThrowAwayObject_3,,"
    # Preconditions: We should be holding the object, and it should be hot and sliced.
    if (not env_state.isHot('tomato') or not env_state.isSliced('tomato')):
        print(""Failure, tomato is not properly prepared (hot and sliced)."")
        return False, env_state

    # Low-level actions: pick up the object again if it was put down to heat.
    if (not env_state.holds('tomato')):
        try:
            action = PickupObject(args={'object_id': 'tomato'})
            success = act(env=env, action=action)
            print(""Successfully picked up the heated, sliced tomato!"")
        except:
            print(""Execution failure picking up the heated, sliced tomato..."")
            return False

    # Low-level actions: put the object in the garbage can.
    try:
        action = PutObject(args={'object_id': 'tomato', 'receptacle_object_id': 'garbagecan'})
        success = act(env=env, action=action)
        print(""Successfully threw away the heated, sliced tomato in the trash bin!"")
    except:
        print(""Execution failure throwing away the heated, sliced tomato..."")
        return False

    # Postconditions: not holding the object and the object is in the trash bin.
    final_env_state = perceive(env)
    return (not final_env_state.holds('tomato')) and final_env_state.inReceptacle('tomato', 'garbagecan'), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_176,,"
    # Preconditions: The floor lamp should not already be on.
    if env_state.isToggled('floorlamp'):
        print(""Floor lamp is already on."")
        return False, env_state

    # Low-level actions: Turn on the floor lamp.
    try:
        action = ToggleObjectOn(args={'object_id': 'floorlamp'})
        success = act(env=env, action=action)
        print(""Turned on the floor lamp."")
    except Exception as e:
        print(f""Failed to turn on floor lamp: {e}."")
        return False, env_state

    # Postconditions: The floor lamp is on.
    final_env_state = perceive(env)
    return final_env_state.isToggled('floorlamp'), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_36,,"
    # Preconditions: The stoveburner needs to be toggled off initially.
    if env_state.isToggled(object_id):
        print(""Stove is already on."")
        return True

    # Low-level actions: toggle the stoveburner on to simulate heating up the potato.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Stoveburner is turned on."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Assuming an arbitrary amount of time passes for the cooking simulation.
    time.sleep(5)  # Wait for the 'cooking' to happen (this is a simulation placeholder).

    # Postconditions: the potato is now hot.
    final_env_state = perceive(env)
    if final_env_state.isHot(object_id):
        # Turn off the stove after cooking.
        try:
            action_toggle_off = ToggleObjectOff(args={'object_id': object_id})
            success_toggle_off = act(env=env, action=action_toggle_off)
            print(""Stoveburner is turned off."")
        except Exception as e:
            print(f""Execution failure when trying to turn off the stove: {e}"")
            # Even if the stove fails to turn off, the potato is still hot and can be placed in the sink.
        return True, final_env_state
    else:
        return False
",0.05,0.5,0.1,
PutObject_1,,"
    # Preconditions: potato is supposed to be hot and sliced.
    if not (env_state.isHot(object_id) and env_state.isSliced(object_id)):
        print(""Potato is not properly prepared (either not hot or not sliced)."")
        return False

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Potato is placed in the {receptacle_object_id}."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: potato is in the sink.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_580,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The mug must be clean and held.
    if (not env_state.isClean(object_id)) or (not env_state.holds(object_id)):
        print(""Failure, mug is not clean or not being held."")
        return False, env_state

    # Low-level actions: put the clean mug in the coffee machine.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully put the mug in the coffee machine."")
        else:
            print(""Failed to put the mug in the coffee machine."")
            return False, env_state
    except Exception as e:
        print(""Execution failure while putting the mug in the coffee machine."")
        print(str(e))
        return False, env_state

    # Postconditions: Mug is not held and is in the coffee machine.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_112,,"
    # Preconditions: Potato should be cooked and sliced.
    if not env_state.holds(object_id) and env_state.isHot(object_id) and env_state.isSliced(object_id):
        print(""Ready to pick up the cooked and sliced potato."")

        # Low-level actions: pick up the potato.
        try:
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
        except:
            print(""Execution failure..."")
            return False, env_state
            
        # Postconditions: holding the potato.
        final_env_state = perceive(env)
        return (final_env_state.holds(object_id)), final_env_state
    else:
        print(""Preconditions not met."")
        return False, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_126,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the sliced, cooked potato.
    if not env_state.holds(object_id):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: put the sliced, cooked potato in the garbagecan.
    try {
        print(""Attempting to throw away the potato."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
    } except:
        print(""Failure, could not dispose of the potato."")
        return False, env_state

    # Postconditions: not holding the potato and the potato is in the garbagecan.
    final_env_state = perceive(env)
    disposed = final_env_state.inReceptacle(object_id, receptacle_object_id)
    return (not final_env_state.holds(object_id) and disposed), final_env_state
",0.05,0.5,0.1,
PickupKnifeIfNotYet_0,,"
    # Preconditions: Knife must be picked up if not already being held or not at the countertop.
    if not (env_state.holds(object_id) or env_state.inReceptacle(object_id, receptacle_object_id)):
        try:
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up an object!"")
        except:
            print(""Execution failure..."")
            return False, env_state
    
    # Postconditions: Knife is held by the agent.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PlaceKnifeOnCountertopIfElsewhere_0,,"
    # Preconditions: Knife must be placed on the counter if it's not already there.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        try:
            action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Successfully placed the knife on the countertop!"")
        except:
            print(""Execution failure..."")
            return False, env_state
    
    # Postconditions: Knife is on the countertop.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupTomato_0,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
SliceTomato_0,,"
    # Preconditions: The knife should be at the countertop and the tomato should be held by the agent.
    if not env_state.inReceptacle('knife', 'countertop') or not env_state.holds(object_id):
        print(""Failed to meet preconditions to slice the tomato."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
SliceObject_162,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding a knife.
    if (not env_state.holds('knife')):
        print(""Cannot slice. Not holding a knife."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully cut the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced('tomato')), final_env_state
",0.05,0.5,0.1,
PickupObject_868,,"
    # Preconditions: tomato is sliced.
    if (not env_state.isSliced('tomato')):
        print(""Cannot pick up. The tomato is not sliced."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the sliced tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds('tomato')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_135,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced tomato.
    if (not env_state.holds('tomato')):
        print(""Failure, not holding the sliced tomato."")
        return False, env_state

    # Low-level actions: put the object in the fridge.
    try:
        print(""Trying to put the sliced tomato in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the sliced tomato in the fridge."")
        return False, env_state

    # Postconditions: the sliced tomato is in the fridge.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle('tomato', 'fridge')), final_env_state
",0.05,0.5,0.1,
PickupObject_144,,"
    # Preconditions: sliced tomato is in the fridge.
    if (not env_state.inReceptacle('tomato', 'fridge')):
        print(""Cannot pick up. The sliced tomato is not in the fridge."")
        return False, env_state

    # Low-level actions: pick up the object from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the sliced tomato from the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds('tomato')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_728,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced tomato.
    if (not env_state.holds('tomato')):
        print(""Failure, not holding the sliced tomato."")
        return False, env_state

    # Low-level actions: put the object on the table.
    try:
        print(""Trying to put the sliced tomato on the table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the sliced tomato on the table."")
        return False, env_state

    # Postconditions: the sliced tomato is on the table.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle('tomato', 'diningtable')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_149,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the tomato which is cool.
    if (not env_state.holds(object_id)) or (not env_state.isCool(object_id)):
        print(""Failure, not holding a cool tomato."")
        return False, env_state

    # Low-level actions: put the cool tomato on the dining table.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Cool tomato placed on the dining table."")
    except:
        print(""Failure, could not place cool tomato on the table."")
        return False, env_state

    # Postconditions: cool tomato is on the table and not being held anymore.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_199,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooled potato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the cooled potato."")
        return False, env_state

    # Low-level actions: put the cooled potato in the garbage bin.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'garbagecan'})
        success = act(env=env, action=action)
        print(""Successfully placed the cooled potato in the garbage bin!"")
    except:
        print(""Failure, could not place the cooled potato in the garbage bin."")
        return False, env_state

    # Postconditions: the cooled potato is in the garbage bin.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, 'garbagecan')), final_env_state
",0.05,0.5,0.1,
HeatObjectInMicrowave_0,,"
    # Preconditions: We should be holding the sliced apple.
    if not env_state.holds(object_id) or not env_state.isSliced(object_id):
        print(""Failure, not holding sliced apple."")
        return False, env_state

    # Low-level actions: Open the microwave.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure while opening microwave..."")
        return False, env_state

    # Low-level actions: Place the apple slice in the microwave.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the apple slice in the microwave!"")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: Close the microwave.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the microwave!"")
    except:
        print(""Execution failure while closing microwave..."")
        return False, env_state

    # Low-level actions: Turn on the microwave to heat the apple slice.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the microwave!"")
    except:
        print(""Execution failure while turning on the microwave..."")
        return False, env_state

    # Low-level actions: Turn off the microwave after heating.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned off the microwave!"")
    except:
        print(""Execution failure while turning off the microwave..."")
        return False, env_state

    # Postconditions: The apple slice is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_748,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The apple slice should be hot and microwaved.
    if not env_state.isHot(object_id):
        print(""Failure, the apple slice is not hot."")
        return False, env_state

    # Low-level actions: Open the microwave (if not already open) to get the apple slice.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave to retrieve the apple slice!"")
    except:
        print(""Execution failure while opening microwave..."")
        return False, env_state

    # Low-level actions: Pick up the hot apple slice from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot apple slice!"")
    except:
        print(""Execution failure while trying to pick up the hot apple slice..."")
        return False, env_state

    # Low-level actions: Put the hot apple slice on the dining table.
    try:
        print(""Trying to put the hot apple slice on the dining table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the apple slice on the dining table."")
        return False, env_state

    # Postconditions: The hot apple slice is on the dining table.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
OpenObject_36,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: The fridge is not already open.

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Fridge is now open!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: Fridge is open.
    final_env_state = perceive(env)
    return final_env_state.opened('fridge'), final_env_state
",0.05,0.5,0.1,
PutObject_86,,"
    # Preconditions: The fridge is open, and the object is being held.

    # Low-level actions: put the lettuce in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Lettuce placed in the fridge!"")
    except:
        print(""Failure, could not place lettuce in the fridge."")
        return False

    # Postconditions: Lettuce is in the fridge.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle('lettuce', 'fridge'), final_env_state
",0.05,0.5,0.1,
CloseObject_10,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: The fridge is open.

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Fridge is now closed!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: Fridge is closed.
    final_env_state = perceive(env)
    return not final_env_state.opened('fridge'), final_env_state
",0.05,0.5,0.1,
PickupObject_511,,"
    # Preconditions: Lettuce is cool and in the fridge.

    # Low-level actions: pick up the lettuce from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Lettuce picked up from fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds('lettuce'), final_env_state
",0.05,0.5,0.1,
PutObject_76,,"
    # Preconditions: Lettuce is being held.

    # Low-level actions: put the object back on the table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Lettuce is now back on the dining table!"")
    except:
        print(""Failure, could not place lettuce back on the dining table."")
        return False

    # Postconditions: Lettuce is on the dining table.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle('lettuce', 'diningtable'), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_50,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled bowl.
    if (not env_state.holds(object_id)):
        print(""Not holding the chilled bowl, cannot proceed."")
        return False

    # Low-level actions: put the chilled bowl in the cabinet receptacle.
    try:
        print(""Trying to put the chilled bowl in the cabinet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the chilled bowl inside the cabinet."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: not holding the object and the bowl is in the cabinet.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_567,,"
    # Preconditions: apple is sliced.

    # Low-level actions: pick up the sliced apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not pick up the sliced apple."")
        print(""Successfully picked up a slice of apple."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the slice of apple.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_152,,"
    # Preconditions: Needs to put the sliced apple into the microwave first.

    # Low-level actions: Turns on the microwave with apple inside to cook.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'microwave'})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not put apple in microwave."")
        print(""Sliced apple placed inside the microwave."")
        action = ToggleObjectOn(args={'object_id':'microwave'})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not start the microwave."")
        print(""Microwave started."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: The apple slice is microwaved.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id) and not final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_589,,"
    # Preconditions: The apple slice is microwaved and microwave is off.

    # Low-level actions: Pick up the microwaved apple slice.
    try:
        action = ToggleObjectOff(args={'object_id':'microwave'})  # Ensure the microwave is off
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not turn off the microwave."")
        print(""Microwave turned off."")
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not pick up the microwaved apple slice."")
        print(""Successfully picked up the microwaved apple slice."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: Holding the microwaved apple slice.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_491,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the microwaved apple slice.

    # Low-level actions: Put the microwaved apple slice in the sink.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not place the microwaved apple slice in the sink."")
        print(""Microwaved apple slice has been placed in the sink."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: Microwaved apple slice is in the sink.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_299,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the heated mug."")
        return False, env_state

    # Low-level actions: put the heated mug in the cabinet.
    try:
        print(""Trying to put the heated mug in the cabinet."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the heated mug in the cabinet."")
        return False, env_state

    # Postconditions: not holding the mug and the mug is in the cabinet.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_610,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the pan, and the fridge should be open.
    if not env_state.holds(object_id):
        print(""Failure, not holding pan."")
        return False, env_state

    try:
        action = OpenObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Fridge is now open."")
    except:
        print(""Failure, could not open the fridge."")
        return False, env_state

    # Low-level actions: put the pan in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully placed the pan in the fridge!"")
    except:
        print(""Failure, could not place pan in the fridge."")
        return False, env_state

    # Postconditions: Pan is in the fridge.
    final_env_state = perceive(env)
    if not final_env_state.inReceptacle(object_id, 'fridge'):
        print(""Failure, pan is not in the fridge."")
        return False, final_env_state
    else:
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_72,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: Pan must be in the fridge.

    if not env_state.inReceptacle(object_id, 'fridge'):
        print(""Failure, pan is not in the fridge."")
        return False, env_state

    # The environment itself simulates the cooling process once the pan is in the fridge, 
    # so we just need to confirm that the pan becomes cool.
    final_env_state = perceive(env)
    if not final_env_state.isCool(object_id):
        print(""Failure, pan is not cool."")
        return False, final_env_state
    else:
        print(""Pan is now cool."")
        return True, final_env_state
",0.05,0.5,0.1,
PickupObjectFromReceptacle_2,,"
    # Preconditions: Pan must be in the fridge and cool.

    if not (env_state.inReceptacle(object_id, 'fridge') and env_state.isCool(object_id)):
        print(""Failure, pan is not cool or not in the fridge."")
        return False, env_state

    # Low-level actions: fetch the pan from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully fetched the cool pan from the fridge!"")
        # Close the fridge after taking the pan out.
        action = CloseObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Fridge is now closed."")
    except:
        print(""Failure, could not fetch the pan from the fridge."")
        return False, env_state

    # Postconditions: holding the cool pan.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id):
        print(""Failure, not holding the cool pan."")
        return False, final_env_state
    else:
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_463,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the cool pan.

    if not env_state.holds(object_id):
        print(""Failure, not holding the cool pan."")
        return False, env_state

    # Low-level actions: put the pan on the dining table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'diningtable'})
        success = act(env=env, action=action)
        print(""Successfully placed the cool pan on the dining table!"")
    except:
        print(""Failure, could not place the cool pan on the dining table."")
        return False, env_state

    # Postconditions: cool pan is on the dining table.
    final_env_state = perceive(env)
    if not final_env_state.inReceptacle(object_id, 'diningtable'):
        print(""Failure, cool pan is not on the dining table."")
        return False, final_env_state
    else:
        return True, final_env_state
",0.05,0.5,0.1,
HeatObject_29,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object and it should be heatable.
    if not env_state.holds(object_id) or not env_state.heatable(object_id):
        print(""Cannot heat the object: Not holding object or object isn't heatable."")
        return False, env_state

    # Low-level actions: turn on the stove burner to heat the glass bottle.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Unable to turn on the stove burner."")
            return False, env_state
        
        # Assuming heating is instantaneous for simplicity; otherwise, a wait action would be required.
        
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Unable to put the glass bottle on the stove burner."")
            return False, env_state
        
        # Turn off the stove burner after a while to simulate the bottle being warmed.
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Unable to turn off the stove burner."")
            return False, env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: object should be hot.
    final_env_state = perceive(env)
    return final_env_state.isHot(object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_858,,"
    # Preconditions: The object should be warm and on the stove burner.

    if not env_state.isHot(object_id):
        print(""Object is not warm."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the warm glass bottle."")
        else:
            print(""Unable to pick up the warm glass bottle."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: holding the object and it should still be warm.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id) and final_env_state.isHot(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_788,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the warm object.
    if not env_state.holds(object_id) or not env_state.isHot(object_id):
        print(""Cannot put object in the receptacle: Not holding object or object isn't warm."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully placed warm glass bottle in the cabinet."")
        else:
            print(""Unable to place warm glass bottle in the cabinet."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: not holding the object and the object is in the cabinet.
    final_env_state = perceive(env)
    return ((not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id))), final_env_state
",0.05,0.5,0.1,
PickupObject_92,,"
    # Preconditions: the white cup is hot and in the microwave.

    # Low-level actions: pick up the white cup from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the hot white cup from the microwave."")
        else:
            print(""Failed to pick up the hot white cup from the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the hot white cup.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_430,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the hot white cup.

    # Low-level actions: put the hot white cup on the shelf.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully placed the hot white cup on the shelf."")
        else:
            print(""Failed to place the hot white cup on the shelf."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the hot white cup is on the shelf.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_106,,"
    # Preconditions: pot must be cool.
    if not env_state.isCool(object_id):
        print(""Failure, the pot is not cool."")
        return False, env_state

    # Low-level actions: pick up the pot if not already holding.
    if not env_state.holds(object_id):
        try:
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up the pot!"")
        except:
            print(""Execution failure... Unable to pick up the pot."")
            return False, env_state

    # Postconditions: Holding the cool pot.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id), final_env_state)
",0.05,0.5,0.1,
PutObjectInReceptacle_122,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the pot.
    if not env_state.holds(object_id):
        print(""Failure, not holding the pot."")
        return False, env_state

    # Low-level actions: put the cool pot in the cabinet.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject (pot in cabinet) is: {success}"")
    except:
        print(""Failure, could not place pot in cabinet."")
        return False, env_state

    # Postconditions: pot is no longer being held and the pot is in the cabinet.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state)
",0.05,0.5,0.1,
EnsureObjectIsCool_0,,"
    # Preconditions: None.

    # Low-level actions: check if the bread is not hot (implying it is cool).
    if (env_state.isHot(object_id) or not env_state.isCool(object_id)):
        print(""Bread is hot; cannot be placed in the trash can yet."")
        return False, env_state
    else:
        print(""Bread is cool."")
        return True, env_state

    # Postconditions: bread is cool.
    final_env_state = perceive(env)
    return True, final_env_state
",0.05,0.5,0.1,
PickupObject_434,,"
    # Preconditions: None.

    # Low-level actions: pick up the bread slice.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bread slice."")
    except:
        print(""Could not pick up the bread slice."")
        return False, env_state

    # Postconditions: holding the bread slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_105,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the bread slice.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding bread slice."")
        return False, env_state

    # Low-level actions: put the bread slice in the trash can.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the bread slice in the trash can."")
    except:
        print(""Could not place the bread slice in the trash can."")
        return False, env_state

    # Postconditions: not holding the bread slice and the bread slice is in the trash can.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_342,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced bread.
    if (not env_state.holds(object_id)) or (not env_state.isSliced(object_id)):
        print(""Cannot put bread on a stand: either not holding the bread or it's not sliced."")
        return False, env_state

    # Low-level actions: put the object on the receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(f""Successfully put the bread on the {receptacle_object_id}."")
        else:
            print(f""Failed to put the bread on the {receptacle_object_id}."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: bread is not held and is on the stand (countertop).
    final_env_state = perceive(env)
    return ((not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id))), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_29,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the cloth to put it in the sink basin.
    if not env_state.holds(object_id):
        print(""Not holding the cloth. Cannot put it in the sink."")
        return False, env_state

    # Low-level actions: put the cloth in the sink basin.
    try:
        print(""Attempting to put the cloth in the sink basin."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place the cloth in the sink basin: {e}"")
        return False, env_state

    # Postconditions: not holding the cloth and the cloth is in the sink basin.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
WarmObject_1,,"
    if not env_state.holds(object_id):
        print(""Not holding the apple."")
        return False, env_state

    if not env_state.isHot(object_id):
        try:
            action = ToggleObjectOn(args={'object_id': receptacle_object_id})
            act(env=env, action=action)
            print(""Stove burner turned on to warm the apple."")
            # Assuming the warming process is instantaneous for this example.
            # In a real scenario, we might need to wait for the object to become warm.
        except:
            print(""Could not turn on the stove burner."")
            return False, env_state

    final_env_state = perceive(env)
    return final_env_state.isHot(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_703,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    if not env_state.holds(object_id):
        print(""Not holding the apple."")
        return False, env_state

    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Apple placed in the trash can."")
    except:
        print(""Could not put the apple in the trash can."")
        return False, env_state
 
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
RinseObject_0,,"
    # Preconditions: we should be holding the object.
    if (not env_state.holds('tomato')):
        print(""Failure, not holding the tomato."")
        return False, env_state
    
    # Low-level actions: put the object in the receptacle (sink) to rinse it.
    try:
        print(""Trying to rinse the tomato."")
        action = PutObject(args={'object_id':'tomato', 'receptacle_object_id':'sinkbasin'})
        success = act(env=env, action=action)
        print(f""Result of PutObject (sinkbasin) is: {success}"")

        # Simulate rinsing
        # Assuming rinsing is an instantaneous action here
        env_state.setClean('tomato', True)
    except:
        print(""Failure, could not rinse the tomato."")
        return False, env_state

    # Low-level actions: pick up the object again after rinsing.
    try:
        action = PickupObject(args={'object_id':'tomato'})
        success = act(env=env, action=action)
        print(""Successfully picked up the rinsed tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is clean and we are holding it.
    final_env_state = perceive(env)
    return (final_env_state.isClean('tomato')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_466,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding a rinsed tomato.
    if (not env_state.holds('tomato') or not env_state.isClean('tomato')):
        print(""Failure, not holding a rinsed tomato."")
        return False, env_state

    # Low-level actions: put the rinsed tomato on the table.
    try:
        print(""Trying to place the rinsed tomato on the table."")
        action = PutObject(args={'object_id':'tomato', 'receptacle_object_id':'diningtable'})
        success = act(env=env, action=action)
        print(""Result of PutObject (diningtable) is: {success}"")
    except:
        print(""Failure, could not place the tomato on the table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the table.
    final_env_state = perceive(env)
    if (not final_env_state.holds('tomato')) and (final_env_state.inReceptacle('tomato', 'diningtable')):
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_79,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: apple should be sliced but not necessary to be holding it.
    if (not env_state.isSliced(object_id)):
        print(""Failure, the apple is not sliced."")
        return False, env_state

    # Additional precondition: we should have a fridge to cool the apple.
    if not ('fridge' in RECEPTACLE_TYPES):
        print(""Failure, no fridge available to cool the apple."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the sliced apple in the fridge.
    try:
        print(""Trying to cool the sliced apple in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the sliced apple in the fridge to cool."")
    except:
        print(""Failure, could not put the sliced apple in the fridge."")
        return False, env_state

    # Assuming some time has passed for the apple to cool down, we can take it out of the fridge now.

    # Low-level actions: take the sliced and cooled apple out of the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Took the sliced and cooled apple out of the fridge."")
    except:
        print(""Failure, could not take the sliced apple out of the fridge."")
        return False, env_state

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Closed the fridge."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: apple is cooled.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_302,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be cooled.
    if not env_state.holds(object_id):
        print(""Failure, not holding the apple."")
        return False, env_state
    if not env_state.isCool(object_id):
        print(""Failure, the apple is not cool."")
        return False, env_state

    # Low-level actions: put the cooled piece of apple on the dining table.
    try:
        print(""Trying to put the cooled apple on the dining table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the cooled apple on the dining table."")
        return False, env_state

    # Postconditions: the cooled piece of apple is on the dining table.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        print(""The cooled piece of apple is now on the dining table."")
        return True, final_env_state
    else:
        return False, final_env_state
",0.05,0.5,0.1,
CookObject_7,,"
    # Preconditions: holding the apple and apple is not hot.
    if not env_state.holds(object_id) or env_state.isHot(object_id):
        print(""Failure, not holding apple or apple is already hot."")
        return False, env_state

    # Low-level actions: turn on the stove, put the apple on it, and cook it.
    try:
        # Turn on the stove burner
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner."")

        # Put the apple on the stove
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the apple on the stove burner to cook."")

        # Assume some time for cooking and then turn off the stove burner
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned off the stove burner."")
    except:
        print(""Execution failure, unable to cook the apple."")
        return False, env_state

    # Postconditions: apple is hot.
    final_env_state = perceive(env)
    return final_env_state.isHot(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_263,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the slice of cooked apple.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id) and env_state.isHot(object_id)):
        print(""Failure, not holding a slice of cooked apple."")
        return False, env_state

    # Low-level actions: put the slice of cooked apple in the sink.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the slice of cooked apple in the sink."")
    except:
        print(""Failure, could not place the apple slice in the sink."")
        return False, env_state

    # Postconditions: slice of cooked apple is in the sink.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_482,,"
    # Preconditions: object should be clean.
    if (not env_state.isClean(object_id)):
        print(""Failure, the object is not clean."")
        return False, env_state

    # Low-level actions: pick up the object again after cleaning.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to pick up the object."")
        print(""Successfully picked up the cleaned object!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_308,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cleaned object.
    if (not env_state.holds(object_id) or not env_state.isClean(object_id)):
        print(""Failure, not holding clean object."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to open the fridge."")
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Failure, could not open the fridge: {e}"")
        return False, env_state

    # Low-level actions: put the object in the receptacle (fridge).
    try {
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to put the object in the fridge."")
        print(""Successfully put the object in the fridge."")
    } except Exception as e {
        print(f""Failure, could not place in fridge: {e}"")
        return False, env_state
    }

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to close the fridge."")
        print(""Successfully closed the fridge."")
    except Exception as e:
        print(f""Failure, could not close the fridge: {e}"")
        return False, env_state

    # Postconditions: not holding the object and the object is in the fridge.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_275,,"
    # Preconditions: The glass bottle must be hot but not currently held.
    if (env_state.holds(object_id)) or (not env_state.isHot(object_id)):
        print(""Failure, already holding object or object is not hot."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot glass bottle."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the hot object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_78,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the hot object.
    if (not env_state.holds(object_id)) or (not env_state.isHot(object_id)):
        print(""Failure, not holding object or object is not hot."")
        return False, env_state

    # Low-level actions: put the hot object in the receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the hot object in the cabinet."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_135,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: The object should be coolable and sliced.
    if not (env_state.coolable(object_id) and env_state.isSliced(object_id)):
        print(""The object is either not coolable or not sliced."")
        return False, env_state

    # Low-level actions: open the fridge to prepare to cool the apple piece.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Fridge opened successfully."")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Low-level actions: put the apple piece in the fridge for cooling.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully put the apple piece in the fridge."")
    except:
        print(""Execution failure..."")
        return False, env_state
    
    # Low-level actions: close the fridge and wait for the apple piece to cool.
    try:
        action = CloseObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Fridge closed successfully."")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: open the fridge again to get the apple piece.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Fridge opened successfully."")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: pick up the cooled apple piece.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooled apple piece."")
    except:
        print(""Execution failure, unable to pick up the apple piece."")
        return False

    # Postconditions: The object is cooled.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state    
",0.05,0.5,0.1,
PutObjectInReceptacle_303,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the object and it should be cool.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""We are either not holding the cool apple piece or it's not cool."")
        return False, env_state

    # Low-level actions: open the microwave to prepare to put the apple piece inside.
    try:
        action = OpenObject(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Microwave opened successfully."")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the cool apple piece in the microwave.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'microwave'})
        success = act(env=env, action=action)
        print(""Successfully put the cool apple piece in the microwave."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: The apple piece is in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, 'microwave')), final_env_state
",0.05,0.5,0.1,
HeatObject_138,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: toggle the object if it is toggleable (like a stoveburner) to heat it.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stoveburner is turned on!"")
    except:
        print(""Failure, could not toggle on."")
        return False

    # Low-level actions: put the object on the receptacle to heat.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the mug on the stoveburner."")
    except:
        print(""Failure, could not place on the stoveburner."")
        return False, env_state

    # Assuming some time must pass for the object to get heated.
    print(""Waiting for the mug to get heated..."")
    # The waiting action is not in the API, it's a placeholder to indicate waiting time. In real implementation, this would be done differently.

    # Low-level actions: turn off the stoveburner.
    try:
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stoveburner is turned off!"")
    except:
        print(""Failure, could not toggle off."")
        return False

    # Low-level actions: pick up the heated object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Picked up the heated mug."")
    except:
        print(""Failure, could not pick up the heated mug."")
        return False

    # Postconditions: object is heated and we are holding it.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_780,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object, and it should be heated.
    if (not env_state.holds(object_id)) or (not env_state.isHot(object_id)):
        print(""Failure, not holding the heated mug."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the heated mug in the coffeemachine."")
    except:
        print(""Failure, could not place in the coffeemachine."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_176,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the apple and it should be cool.
    if (not env_state.holds(object_id)) or (not env_state.isCool(object_id)):
        print(""Failure, not holding a cool apple."")
        return False, env_state

    # Low-level actions: open the microwave if it's not already open.
    if not env_state.isOpened(receptacle_object_id):
        try:
            open_action = OpenObject(args={'object_id': receptacle_object_id})
            open_success = act(env=env, action=open_action)
            print(""Microwave is opened!"")
        except:
            print(""Execution failure: unable to open the microwave."")
            return False, env_state

    # Low-level actions: put the cool apple in the microwave.
    try:
        print(""Trying to put the cool apple in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the cool apple in the microwave."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the microwave.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_860,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The knife is being held.
    if not env_state.holds(object_id):
        print(""Failure, not holding the knife."")
        return False, env_state

    # Low-level actions: Put the knife in the drawer.
    try:
        print(""Trying to put the knife in the drawer."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully put the knife in the drawer."")
        else:
            print(""Failed to put the knife in the drawer."")
            return False, env_state
    except Exception as e:
        print(f""Failure, could not place the knife in the drawer due to: {e}"")
        return False, env_state

    # Postconditions: The knife should no longer be held and it should be in the drawer.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_386,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled wine bottle.
    if (not env_state.holds(object_id)):
        print(""Not holding the wine bottle, cannot place it in cabinet."")
        return False, env_state

    # Low-level actions: put the wine bottle in the cabinet.
    try {
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Wine bottle placed in cabinet."")
    except:
        print(""Failure placing wine bottle in cabinet."")
        return False, env_state

    # Postconditions: wine bottle is no longer being held and is in the cabinet.
    final_env_state = perceive(env)
    not_holding_wine = not final_env_state.holds(object_id)
    wine_in_cabinet = final_env_state.inReceptacle(object_id, receptacle_object_id)
    return (not_holding_wine and wine_in_cabinet), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_140,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the knife and it should be clean.
    if not env_state.holds(object_id) or not env_state.isClean(object_id):
        print(""Failure, not holding a clean knife."")
        return False, env_state

    # Low-level actions: open the drawer if needed.
    try:
        if not env_state.opened('drawer'):
            action = OpenObject(args={'object_id': 'drawer'})
            success = act(env=env, action=action)
            print(f""Drawer opened: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the knife in the drawer.
    try:
        print(""Trying to put the knife in the drawer."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the knife in the drawer."")
        return False

    # Postconditions: not holding the knife and the knife is in the drawer.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
HeatObject_163,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the egg."")
        return False

    # Low-level actions: open the receptacle.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to open the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the object in the receptacle for heating.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to put the egg in the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: close the receptacle.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to close the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: turn on the receptacle to heat the object.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to start the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # We might have to wait some time and ensure the microwave is turned off after some time.
    # ... [simulate wait if necessary] ...

    # Low-level actions: turn off the receptacle.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to turn off the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: remove the heated object (egg) from the receptacle.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to pick up the heated egg from the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object and the object is heated.
    return env_state.isHot(object_id)
",0.05,0.5,0.1,
PutObjectInReceptacle_135,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be hot.
    if not (env_state.holds(object_id) and env_state.isHot(object_id)):
        print(""Failure, either not holding the egg or it's not hot."")
        return False

    # Low-level actions: put the hot object on the sidetable.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure to place the hot egg on the sidetable."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the object (egg) is not being held and is on the sidetable.
    return (not env_state.holds(object_id)) and env_state.inReceptacle(object_id, receptacle_object_id)
",0.05,0.5,0.1,
PutObject_5,,"
    # Preconditions: we should be holding the sliced tomato.
    if (not env_state.holds(object_id) or not env_state.isSliced(object_id)):
        print(""Failure, not holding a sliced tomato."")
        return False, env_state
    
    # Low-level actions: put the sliced tomato in the microwave.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced tomato in the microwave!"")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: the sliced tomato is in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_204,,"
    # Preconditions: the sliced tomato should be in the microwave.
    if (not env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Failure, sliced tomato is not in the microwave."")
        return False, env_state

    # Low-level actions: turn the microwave on to heat the slice.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned the microwave on!"")
    except:
        print(""Execution failure..."")
        return False

    # Setting an arbitrary period for the microwave to run.
    # Not part of the AlfredAction API - represents a wait for the item to heat.
    time.sleep(30) # Placeholder for the passage of time.

    # Postconditions: the tomato slice should now be hot, representing that it's microwaved.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOff_16,,"
    # Preconditions: the microwave should be on.
    if (not env_state.isToggled(receptacle_object_id)):
        print(""Failure, microwave is not on."")
        return False, env_state

    # Low-level actions: turn the microwave off.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned the microwave off!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the microwave is off.
    final_env_state = perceive(env)
    return (not final_env_state.isToggled(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_1039,,"
    # Preconditions: None.

    # Low-level actions: pick up the heated slice.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated slice!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the heated slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_862,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated slice.
    if (not env_state.holds(object_id) or not env_state.isHot(object_id)):
        print(""Failure, not holding a heated slice."")
        return False, env_state
    
    # Low-level actions: put the heated slice on the counter.
    try {
        print(""Trying to put the slice on the counter."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the slice on the counter."")
        return False, env_state
    
    # Postconditions: not holding the slice and the slice is on the counter.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_629,,"
    # Preconditions: bread is in the fridge and cool.

    # Low-level actions: pick up the bread from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cool bread from the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cool bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_633,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cool bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the cool bread."")
        return False, env_state

    # Low-level actions: put the bread on the countertop.
    try:
        print(""Trying to put the cool bread on the countertop."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'countertop'})
        success = act(env=env, action=action)
        print(""Successfully placed the cool bread on the countertop."")
    except:
        print(""Failure, could not place the bread on the countertop."")
        return False, env_state

    # Postconditions: not holding the bread and the bread is on the countertop.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, 'countertop')):
        print(""The bread has been chilled and placed on the countertop."")
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_12,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the sliced apple.
    if not env_state.holds(object_id):
        print(""Failure, not holding the sliced apple."")
        return False, env_state

    # Intermediate step: ensure apple is recognized as sliceable and not just a whole apple
    if not env_state.sliceable(object_id) or not env_state.isSliced(object_id):
        print(""The apple is not properly recognized as sliced, cannot cool."")
        return False, env_state
    
    # Low-level actions: put the sliced apple in the fridge to cool.
    try:
        print(""Trying to cool the apple slice."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the apple slice in the fridge to cool."")
    except:
        print(""Failure, could not place in fridge."")
        return False, env_state

    # Simulating the cooling process
    # In reality there should be some time delay or mechanism to check if the apple has cooled

    # Low-level actions: assume the apple slice is now cooled, take it out of the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Taken the cooled apple slice out of the fridge."")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: holding the cooled, sliced apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_805,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooled, sliced apple.
    if not env_state.holds(object_id):
        print(""Failure, not holding the cooled, sliced apple."")
        return False, env_state

    # Intermediate step: ensure that 'black bin' is reasonably interpreted as 'garbagecan'
    register_receptacle_guess('black bin', 'garbagecan')

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to place the cooled, sliced apple in the black bin (interpreted as 'garbagecan')."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the cooled, sliced apple in the black bin."")
    except:
        print(""Failure, could not place in black bin."")
        return False, env_state

    # Postconditions: not holding the apple and the apple is in the garbagecan.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Successfully placed the cooled, sliced apple in the black bin."")
        return True, final_env_state
    else:
        print(""Failure, postconditions not met."")
        return False, final_env_state
",0.05,0.5,0.1,
PickupObject_1069,,"
    # Preconditions: Pan must be clean.
    if not env_state.isClean(object_id):
        print(""Failure, pan is not clean."")
        return False, env_state
    
    # Low-level actions: pick up the clean pan.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean pan!"")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: holding the clean pan.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_623,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the pan.
    if not env_state.holds(object_id):
        print(""Failure, not holding the clean pan."")
        return False, env_state
    
    # Low-level actions: put the clean pan on the electric cooker (stoveburner).
    try:
        print(""Trying to place the pan on the stoveburner."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the pan on the stoveburner."")
        return False, env_state
    
    # Postconditions: Pan is on the stoveburner.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CoolObject_89,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: The object must be coolable and we might need to open the fridge.
    if (not env_state.coolable(object_id)):
        print(""Failure, object cannot be cooled."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge."")
    except:
        print(""Execution failure while opening the fridge."")
        return False

    # Low-level actions: put the object in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the sliced tomato in the fridge."")
    except:
        print(""Execution failure while putting the sliced tomato in the fridge."")
        return False, env_state

    # Close the fridge to allow it to cool.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge."")
    except:
        print(""Execution failure while closing the fridge."")
        return False    

    # Postconditions: Object is cool.
    # Note: here, we assume some time has passed for cooling, which isn't explicit in actions.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_1120,,"
    # Preconditions: The object should be in the fridge and cool.

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge to retrieve the tomato."")
    except:
        print(""Execution failure while opening the fridge to retrieve the tomato."")
        return False    

    # Low-level actions: pick up the cool sliced object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a chilled slice of tomato."")
    except:
        print(""Execution failure while picking up a chilled slice of tomato."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_210,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the object, which should be both sliced and cool.

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed a chilled slice of tomato into the bin."")
    except:
        print(""Execution failure while placing the chilled slice of tomato into the bin."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_103,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the pencil.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the pencil."")
        return False, env_state

    # Low-level actions: put the pencil on the countertop.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the pencil on the countertop!"")
        # Postconditions: not holding the pencil and the pencil is on the countertop.
        final_env_state = perceive(env)
        return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
    except:
        print(""Failure, could not place the pencil on the countertop."")
        return False, env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_697,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the clean towel.
    if (not env_state.holds(object_id)) or (not env_state.isClean(object_id)):
        print(""Failure, not holding a clean towel."")
        return False, env_state

    # Low-level actions: put the towel inside the bathtub.
    try:
        print(""Trying to place the clean towel inside the bathtub."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the towel in the bathtub."")
        return False, env_state

    # Postconditions: not holding the towel and the towel is in the bathtub.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
SliceObject_136,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding the apple.
    if not env_state.holds(object_id):
        print(""Must be holding the apple to slice it."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except:
        print(""Execution failure slicing the apple..."")
        return False

    # Postconditions: apple is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,0.5,0.1,
PutObject_66,,"
    # Preconditions: Must be holding a sliced apple.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id)):
        print(""Must be holding a sliced apple to chill it."")
        return False, env_state

    # Low-level actions: put the sliced apple in the fridge to chill it.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Put the sliced apple in the fridge to chill."")
    except:
        print(""Execution failure putting the apple in the fridge..."")
        return False

    # Low-level actions: wait for the apple slice to chill.
    wait_for_chill()

    # Postconditions: apple slice is chilled.
    final_env_state = perceive(env)
    return final_env_state.isCool(object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_954,,"
    # Preconditions: Apple slice must be in the fridge and chilled.
    if not (env_state.inReceptacle(object_id, 'fridge') and env_state.isCool(object_id)):
        print(""Apple slice must be chilled in the fridge to be picked up for disposal."")
        return False, env_state

    # Low-level actions: pick up the chilled apple slice.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled apple slice!"")
    except:
        print(""Execution failure picking up the chilled apple slice..."")
        return False

    # Postconditions: holding the chilled apple slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_478,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the chilled apple slice.
    if not env_state.holds(object_id):
        print(""Failure, not holding the chilled apple slice."")
        return False, env_state

    # Low-level actions: put the chilled apple slice in the garbage can.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the chilled apple slice in the garbage can!"")
    except:
        print(""Failure, could not place the chilled apple slice in the garbage can."")
        return False, env_state

    # Postconditions: apple slice is in the garbage can.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_243,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced potato.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id)):
        print(""Failure, not holding the sliced potato."")
        return False, env_state

    # Low-level actions: put the sliced potato in the microwave.
    try:
        print(""Trying to put sliced potato in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place sliced potato in the microwave."")
        return False, env_state

    # Postconditions: potato is in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_138,,"
    # Preconditions: the sliced potato should be in the microwave.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Failure, the sliced potato is not in the microwave."")
        return False, env_state

    # Low-level actions: cook the sliced potato by turning the microwave on.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Turning the microwave on to cook the potato."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: microwave is toggled on.
    print(""Wait for the potato to be cooked."")
    final_env_state = perceive(env)
    return (final_env_state.isToggled(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOff_15,,"
    # Preconditions: the microwave should have cooked the potato, which means it is on.
    if not env_state.isToggled(receptacle_object_id):
        print(""Failure, the microwave is not on."")
        return False, env_state

    # Low-level actions: turn the microwave off after cooking.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Turning the microwave off after cooking."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: microwave is toggled off.
    final_env_state = perceive(env)
    return (not final_env_state.isToggled(receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_900,,"
    # Preconditions: the potato should be cooked.
    if not (env_state.isToggled(receptacle_object_id) and env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Failure, the potato is not cooked and inside the microwave."")
        return False, env_state

    # Low-level actions: pick up the cooked potato from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooked potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cooked potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_221,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooked potato.
    if not (env_state.holds(object_id) and env_state.isHot(object_id)):
        print(""Failure, not holding the cooked potato."")
        return False, env_state

    # Low-level actions: put the cooked potato in the fridge.
    try:
        print(""Attempting to put the cooked potato in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place cooked potato in the refrigerator."")
        return False, env_state

    # Postconditions: cooked potato is in the fridge.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
OpenObject_3,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: None.

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False
    
    # Postconditions: fridge is open.
    final_env_state = perceive(env)
    return final_env_state.isOpened(receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_451,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: fridge is open and holding the potato slice.

    # Low-level actions: put the sliced potato in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the potato slice inside the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: Potato slice inside the fridge.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
CloseObject_17,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: Potato slice is inside the open fridge.

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False
    
    # Postconditions: fridge is closed.
    final_env_state = perceive(env)
    return not final_env_state.isOpened(receptacle_object_id) and final_env_state.isCool(object_id), final_env_state
",0.05,0.5,0.1,
OpenObject_37,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: Potato slice is chilled in the fridge.

    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False
    
    # Postconditions: microwave is open.
    final_env_state = perceive(env)
    return final_env_state.isOpened(receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_1058,,"
    # Preconditions: Potato slice is chilled, hence it's inside the fridge.

    # Low-level actions: pick up the chilled potato slice from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled potato slice!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: holding the chilled potato slice.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_237,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: microwave is open and holding the chilled potato slice.

    # Low-level actions: put the chilled potato slice in the microwave.
    try:
        print(""Trying to place the chilled potato slice inside the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the chilled potato slice inside the microwave!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: not holding the slice and it is inside the microwave.
    final_env_state = perceive(env)
    return not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_644,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the clean spatula.
    if (not env_state.holds(object_id)) or (not env_state.isClean(object_id)):
        print(""Failure, either not holding spatula or it is not clean."")
        return False, env_state

    # Low-level actions: put the clean spatula on the counter.
    try:
        print(""Attempting to place the spatula on the counter."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place spatula on counter."")
        return False, env_state

    # Postconditions: not holding the object and the spatula is on the counter.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_137,,"
    # Preconditions: The lamp should be toggleable and not already providing light.
    if not (env_state.toggleable(""floorlamp"") and not env_state.isToggled(""floorlamp"")):
        print(""Lamp cannot be toggled or is already on."")
        return False, env_state

    # Low-level actions: turn on the lamp.
    try:
        action = ToggleObjectOn(args={'object_id': ""floorlamp""})
        success = act(env=env, action=action)
        print(""Successfully turned on the lamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: lamp provides light.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(""floorlamp"")), final_env_state
",0.05,0.5,0.1,
PutObject_73,,"
    # Preconditions: We should be holding the plate.
    if not env_state.holds(""plate""):
        print(""Not holding the plate."")
        return False, env_state

    # Find the coffee table that is under the lamp.
    for candidate_receptacle in env_state.entire_environment():
        if env_state.isReceptacle(candidate_receptacle) and env_state.isUnder(""floorlamp"", candidate_receptacle):
            receptacle_object_id = candidate_receptacle
            break
    else:
        print(""No coffee table found under the lamp."")
        return False, env_state

    # Low-level actions: put the plate down under the lamp.
    try:
        print(""Trying to put the plate down under the lamp."")
        action = PutObject(args={'object_id': ""plate"", 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject: {success}"")
    except:
        print(""Failure, could not place the plate under the lamp."")
        return False, env_state

    # Postconditions: The plate is placed under the light of the lamp.
    final_env_state = perceive(env)
    return (not final_env_state.holds(""plate"") and final_env_state.inReceptacle(""plate"", receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_160,,"
    # Preconditions: None.

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: stove burner is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
PutObject_39,,"
    # Preconditions: We should be holding the sliced bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding bread."")
        return False, env_state

    # Low-level actions: put the sliced bread on the stove burner to cook it.
    try:
        print(""Trying to cook the bread slice."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not cook bread slice."")
        return False, env_state

    # Note: Give some time for bread to cook, this could require a waiting mechanic or fake a wait with some message prompts.

    # Postconditions: bread slice is cooked and on the stove burner.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_601,,"
    # Preconditions: Cooked bread slice should be on the stove burner.

    # Low-level actions: pick up the cooked bread slice.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up cooked bread slice!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cooked bread slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObject_68,,"
    # Preconditions: We should be holding the cooked bread slice.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding cooked bread slice."")
        return False, env_state

    # Low-level actions: put the cooked bread slice in the trash.
    try:
        print(""Trying to put the cooked bread slice in the trash."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not put cooked bread slice in trash."")
        return False, env_state

    # Postconditions: not holding the bread and the bread is in the trash.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CoolObject_116,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: the tomato should be sliced.
    if (not env_state.isSliced(object_id)):
        print(""Failure, the tomato is not sliced."")
        return False, env_state

    # Low-level actions: place the sliced tomato in the fridge to chill it.
    # First, find a fridge.
    fridge_id = find_receptacle('fridge', env_state)

    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': fridge_id})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced tomato in the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Chilling the tomato will take some time, usually this would require waiting for some time or accelerating time which is not supported by the current model. Therefore this step will be skipped in this plan.

    # Postconditions: the sliced tomato is chilled.
    # Get the current state again to ensure the chilling process is considered done.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInMicrowave_2,,"
    # Preconditions: the sliced tomato should be chilled.
    if (not env_state.isCool(object_id)):
        print(""Failure, the sliced tomato is not chilled."")
        return False, env_state

    # Pick up the chilled, sliced tomato to move it to the microwave.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled, sliced tomato!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Put the chilled, sliced tomato in the microwave.
    # First, find a microwave.
    microwave_id = find_receptacle('microwave', env_state)

    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': microwave_id})
        success = act(env=env, action=action)
        print(""Successfully put the chilled, sliced tomato in the microwave!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the chilled, sliced tomato is in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, microwave_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_171,,"
    # Preconditions: the chilled, sliced tomato should be in the microwave.
    microwave_id = find_receptacle('microwave', env_state)
    if (not env_state.inReceptacle(object_id, microwave_id)):
        print(""Failure, the chilled, sliced tomato is not in the microwave."")
        return False, env_state

    # Low-level actions: start the microwave.
    try:
        action = ToggleObjectOn(args={'object_id': microwave_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the microwave!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the microwave is cooking the chilled, sliced tomato.
    final_env_state = perceive(env)
    return (env_state.isToggled(microwave_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_378,,"
    # Preconditions: The tomato should be cool.
    if not env_state.isCool(object_id):
        print(""The tomato is not cool, cannot continue."")
        return False, env_state

    # Low-level actions: pick up the chilled object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_479,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooled object.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding a cooled tomato."")
        return False, env_state

    # Low-level actions: put the chilled object in the microwave.
    try:
        print(""Trying to put the chilled tomato in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the chilled tomato in the microwave."")
    except:
        print(""Failure, could not place tomato in the microwave."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_518,,"
    # Preconditions: The mug is cooled.

    # Low-level actions: pick up the object from the fridge after it's cool.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a chilled object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_355,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it's chilled.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure: not holding a chilled object."")
        return False, env_state

    # Low-level actions: put the object in the coffee machine.
    try:
        print(""Trying to place chilled object in coffee machine."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure: could not place in coffee machine."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the coffee machine.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_39,,"
    # Preconditions: plate must be hot.
    if (not env_state.isHot(object_id)):
        print(""Failure, the plate is not hot."")
        return False, env_state

    # Low-level actions: pick up the hot plate.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot plate."")
    except:
        print(""Execution failure while trying to pick up the hot plate."")
        return False

    # Postconditions: holding the hot plate.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_574,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the hot plate.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the hot plate."")
        return False, env_state

    # Low-level actions: put the hot plate on the shelf.
    # Assuming ""shelf"" refers to one of the shelves in the corner of the kitchen.
    try:
        print(""Trying to put the hot plate on the shelf."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the hot plate on the shelf."")
    except:
        print(""Failure, could not place the hot plate on the shelf."")
        return False, env_state

    # Postconditions: not holding the hot plate and the hot plate is on the shelf.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
SliceObject_92,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the object and it should be sliceable.
    if not (env_state.holds(object_id) and env_state.sliceable(object_id)):
        print(""Failure, not holding a sliceable object."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_447,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the chilled egg.
    if (not (env_state.holds(object_id) and env_state.isCool(object_id))):
        print(""Failure, not holding a chilled egg."")
        return False, env_state

    # Low-level actions: put the egg on the countertop.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the chilled egg on the countertop."")
    except:
        print(""Failure, could not place the chilled egg on the countertop."")
        return False, env_state

    # Postconditions: the egg is not held and is on the countertop.
    final_env_state = perceive(env)
    return ((not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PlaceObjectNearLamp_0,,"
    # Preconditions: we should be holding the pen.
    if not env_state.holds(object_id):
        print(""Not holding the pen, cannot place it."")
        return False, env_state
        
    # Low-level actions: put the pen on the receptacle (e.g., sidetable) near a lamp.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_id})
        success = act(env=env, action=action)
        print(""Pen placed near the lamp."")
    except:
        print(""Could not place the pen near the lamp."")
        return False, env_state

    # Postconditions: pen is placed near the light for examination.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_604,,"
    # Preconditions: None.

    # Low-level actions: pick up the cooled pan from the fridge.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooled pan!"")
    except:
        print(""Execution failure while trying to pick up the cooled pan..."")
        return False

    # Postconditions: holding the cooled pan.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_173,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooled pan.
    if not env_state.holds(object_id):
        print(""Failure, not holding the cooled pan."")
        return False, env_state

    # Low-level actions: put the cooled pan on the countertop.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the cooled pan on the countertop."")
    except:
        print(""Failure, could not place the pan."")
        return False

    # Postconditions: not holding the object and the pan is on the countertop.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_868,,"
    # Preconditions: the object should be clean for pickup
    if not env_state.isClean(object_id):
        print(""The object is not clean, cannot pick up."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the object: "", success)
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_405,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be clean.
    if not env_state.holds(object_id) or not env_state.isClean(object_id):
        print(""Not holding a clean object, cannot place it."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Attempting to set the object on the countertop."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the object: "", success)
    except:
        print(""Failure to place the object."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_14,,"
    # Preconditions: None.

    # Low-level actions: pick up the apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a warm apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the warm apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_73,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the warm object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the warm apple."")
        return False, env_state

    # Low-level actions: put the warm apple on the table.
    try:
        print(""Trying to put warm apple on the dining table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place warm apple on the dining table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_286,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: cooked potato should be held.
    if (not env_state.holds(object_id)):
        print(""Not holding the cooked potato, can't put it in the fridge."")
        return False, env_state

    # Low-level actions: put the cooked potato in the fridge.
    try:
        print(""Trying to put the cooked potato in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Cooked potato placed in the fridge."")
    except:
        print(""Failed to place the cooked potato in the fridge."")
        return False, env_state

    # Postconditions: cooked potato is in the fridge.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_298,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pillow."")
    except:
        print(""Execution failure, could not pick up the pillow."")
        return False, env_state

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_347,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object, and floorlamp must be on.
    if not (env_state.holds(object_id) and env_state.isToggled(receptacle_object_id)):
        print(""Failure, not holding object or floorlamp is not on."")
        return False, env_state
    
    # Low-level actions: put the object under the receptacle.
    try:
        print(""Attempting to place the pillow under the floorlamp."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Pillow placed under the floorlamp."")
    except:
        print(""Failure, could not place the pillow under the floorlamp."")
        return False, env_state
    
    # Postconditions: not holding the object and the object is under the floorlamp.
    final_env_state = perceive(env)
    return not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupCleanObject_1,,"
    # Preconditions: The cloth must be clean and in the sink basin.
    if not env_state.isClean(object_id):
        print(""Failure, the cloth is not clean."")
        return False, env_state

    # Low-level actions: Pick up the clean cloth from the sink basin.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean cloth!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: Holding the clean cloth.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutCleanObjectInReceptacle_0,,"
    # Preconditions: Holding the clean cloth.
    if not (env_state.holds(object_id) and env_state.isClean(object_id)):
        print(""Failure, not holding the clean cloth."")
        return False, env_state

    # Low-level actions: Put the clean cloth in the drawer.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the clean cloth in the drawer!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: Cloth is in the drawer and no longer held.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_668,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled potato.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding a chilled potato."")
        return False, env_state

    # Low-level actions: put the potato in the microwave.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'microwave'})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place the chilled potato in the microwave: {e}"")
        return False

    # Postconditions: the potato is no longer held and is now in the microwave.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, 'microwave'), final_env_state
",0.05,0.5,0.1,
PutObjectOnReceptacle_4,,"
    # Preconditions: holding the pencil.
    if not env_state.holds(object_id):
        print(""Failure, not holding pencil."")
        return False, env_state

    # There is no 'table' receptacle, but there are multiple possible guesses for 'table' in RECEPTACLE_TYPES.
    # We will guess 'diningtable' is implied, even though other options like 'sidetable', 'coffeetable', or 'desk' could also fit.

    # Low-level actions: put the pencil on the diningtable.
    try:
        print(""Trying to put pencil on the diningtable."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place pencil on diningtable."")
        return False, env_state

    # Postconditions: not holding the pencil and the pencil is on the diningtable.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_528,,"
    # Preconditions: The egg is clean but not being held.

    # Low-level actions: pick up the object again after cleaning.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the rinsed egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_700,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the clean egg.

    if (not env_state.holds(object_id)):
        print(""Failure, not holding the rinsed egg."")
        return False, env_state

    # Low-level actions: put the rinsed egg in the garbagecan to throw it away.
    try:
        print(""Trying to throw away the rinsed egg."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not throw away the egg."")
        return False, env_state

    # Postconditions: Egg is not being held and is in the garbagecan.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectOnReceptacle_8,,"
    # Preconditions: We should be holding the tomato.
    if not env_state.holds(object_id):
        print(""Not holding the tomato."")
        return False, env_state

    # Low-level actions: put the tomato on the table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the tomato on the table."")
    except:
        print(""Failure, could not place the tomato on the table."")
        return False, env_state

    # Postconditions: The tomato is no longer being held and is now on the table.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_609,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be clean.
    if not (env_state.holds(object_id) and env_state.isClean(object_id)):
        print(""Failure, not holding a clean object."")
        return False, env_state

    # Low-level actions: put the object on the table.
    try:
        print(""Trying to put the clean spatula on the table."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place on the table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state

    return False, final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_180,,"
    # Preconditions: The 'floorlamp' must be 'toggleable' and currently off.
    if not env_state.toggleable(object_id) or env_state.isToggled(object_id):
        print(""Precondition failed: cannot toggle on or is already on."")
        return False, env_state

    # Low-level actions: turn on the toggleable object.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the floor lamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the object is toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
CoolSlicedTomato_0,,"
    # Preconditions: Object is sliced and we are not holding the object.
    if (not env_state.isSliced(object_id)) or env_state.holds(object_id):
        print(""Object is not sliced or we are holding the object."")
        return False, env_state

    # Low-level actions: open the fridge, put the sliced tomato in it, close it to cool.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)

        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        act(env=env, action=action)

        action = CloseObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)

        # Pretending some time has passed and the sliced tomato is cool.
        print(""Sliced tomato has been cooled in the fridge!"")
    except:
        print(""Execution failure while attempting to cool the sliced tomato..."")
        return False, env_state

    # Postconditions: The object is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PlaceInMicrowave_0,,"
    # Preconditions: Object is sliced and cool. We must not be holding the object.
    if (not env_state.isSliced(object_id) or not env_state.isCool(object_id)) or env_state.holds(object_id):
        print(""Object is not sliced and cool or we are holding the object."")
        return False, env_state

    # Low-level actions: pick the sliced tomato, open the microwave, and put it in.
    try:
        action = PickupObject(args={'object_id':object_id})
        act(env=env, action=action)

        action = OpenObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)
        
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        act(env=env, action=action)

        action = CloseObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action)

        print(""Sliced tomato has been placed in the microwave!"")
    except:
        print(""Execution failure while attempting to place the sliced tomato in the microwave..."")
        return False, env_state

    # Postconditions: The object is in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
CleanObject_51,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: We should be holding the cloth and it should be dirty.

    if not env_state.holds(object_id) or env_state.isClean(object_id):
        print(""Failure, not holding the cloth or it is already clean."")
        return False, env_state

    # Low-level actions: wash the cloth in the sink.
    try:
        # Assume sink is always open and can be used directly.
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'sinkbasin'})
        success = act(env=env, action=action)
        print(""Successfully placed cloth in sink for washing."")
    except:
        print(""Execution failure in washing the cloth..."")
        return False, env_state

    # Low-level actions: rub the object to simulate washing.
    # Note: There is not an explicit wash action, this is an assumption of the task.
    # Simulate washing by 'using' the object in the sinkbasin environment.
    try:
        print(""Simulating washing the cloth..."")
        pass  # Replace this with the necessary interactions if available in the API.
    except:
        print(""Failed to simulate washing."")
        return False, env_state

    # Postconditions: The cloth is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_379,,"
    # Preconditions: The cloth should be clean and in the sink.

    if not env_state.inReceptacle(object_id, 'sinkbasin') or not env_state.isClean(object_id):
        print(""Failure, the cloth is either not in the sink or it is not clean."")
        return False, env_state

    # Low-level actions: pick up the cloth from the sink.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean cloth from the sink!"")
    except:
        print(""Execution failure in picking up the clean cloth..."")
        return False

    # Postconditions: holding the clean cloth.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_22,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the clean cloth.

    if not env_state.holds(object_id) or not env_state.isClean(object_id):
        print(""Failure, not holding the clean cloth."")
        return False, env_state

    # Low-level actions: put the clean cloth back in the bathtub basin.
    try {
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'bathtubbasin'})
        success = act(env=env, action=action)
        print(""Successfully placed the clean cloth back in the bathtub!"")
    except:
        print(""Failure, could not place the clean cloth back in the bathtub."")
        return False, env_state

    # Postconditions: not holding the cloth and the cloth is back in the bathtub.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, 'bathtubbasin')), final_env_state
",0.05,0.5,0.1,
CoolObject_150,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the glass bottle.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding glass bottle."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Fridge is now open."")
    except:
        print(""Execution failure, unable to open the fridge."")
        return False

    # Low-level actions: put the glass bottle in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Glass bottle put in fridge."")
    except:
        print(""Execution failure, unable to put the glass bottle in the fridge."")
        return False

    # Wait for the glass bottle to become cool.
    # Not directly possible to simulate, but suppose we wait enough time here.
    
    # Preconditions: Check if the glass bottle is now cool.
    if (not env_state.isCool(object_id)):
        print(""Glass bottle is not cool."")
        return False, env_state

    # Low-level actions: take the glass bottle out of the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Picked up the chilled glass bottle from the fridge."")
    except:
        print(""Execution failure, unable to pick up the glass bottle from the fridge."")
        return False

    # Postconditions: Object is cool and in hand.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_137,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object, which should be cool.
    if (not env_state.holds(object_id)) or (not env_state.isCool(object_id)):
        print(""Failure, not holding a cool object."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Chilled glass bottle placed in sink basin."")
    except:
        print(""Failure, could not place the chilled glass bottle in the sink basin."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_105,,"
    # Preconditions: egg should be heated now.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_204,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the heated object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the heated egg."")
        return False, env_state

    # Low-level actions: put the object in the receptacle (dining table).
    try:
        print(""Trying to put the heated egg on the dining table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place heated egg on the dining table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the dining table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_100,,"
    # Preconditions: Must have found a toggleable lamp.
    
    # Low-level actions: turn on the lamp.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(f""Successfully turned on the lamp with id: {object_id}!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: lamp is toggled on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_628,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it's sliced.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id)):
        print(""Failure, not holding sliced lettuce."")
        return False, env_state

    # Low-level actions: put the object in the receptacle to cool.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed sliced lettuce in fridge to cool."")
    except:
        print(""Failure, could not place sliced lettuce in fridge."")
        return False, env_state

    # Postconditions: lettuce is in the fridge and will be cooled.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_163,,"
    # Preconditions: Sliced lettuce should be cool

    # Check if lettuce is cool
    if not env_state.isCool(object_id):
        print(""The lettuce is not cool yet."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up cool sliced lettuce from the fridge!"")
    except:
        print(""Execution failure while picking up cool sliced lettuce..."")
        return False

    # Postconditions: holding the cool sliced object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_53,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cool sliced object.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding cool sliced lettuce."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try {
        print(""Trying to put cool sliced lettuce on the dining table."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place cool sliced lettuce on the dining table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the dining table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_770,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object (glass bottle).
    if (not env_state.holds(object_id)):
        print(""Precondition failure, not holding a glass bottle."")
        return False, env_state

    # Low-level actions: put the object in the receptacle (trash can).
    try:
        print(""Trying to put the glass bottle in the trash can."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the glass bottle in the trash can."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_449,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The tomato is sliced and the robot is holding the tomato.
    if not env_state.holds(object_id):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: put the sliced tomato in the receptacle.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place on the countertop."")
        return False, env_state

    # Postconditions: the tomato is on the countertop.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_130,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the 'lettuce', and the 'lettuce' is clean.
    if not (env_state.holds(object_id) and env_state.isClean(object_id)):
        print(""Failure, preconditions not met for placing 'lettuce' on 'sidetable'."")
        return False, env_state

    # Low-level actions: put the 'lettuce' on the 'sidetable'.
    try:
        print(""Trying to place lettuce on sidetable."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject on sidetable is: {success}"")
    except:
        print(""Failure, could not place 'lettuce' on 'sidetable'."")
        return False, env_state

    # Postconditions: not holding the 'lettuce' and the 'lettuce' is on the 'sidetable'.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObjectFromReceptacle_32,,"
    # Preconditions: The object should be hot.

    if not env_state.isHot(object_id):
        print(""Failure, the egg is not hot."")
        return False, env_state

    # Low-level actions: pick up the object from the stove burner.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not pick up the object from the stove burner."")
            return False, env_state
        print(""Successfully picked up the hot egg."")

        # Shutdown the stove burner after removing the egg.
        toggle_off_action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=toggle_off_action)
        if not success:
            print(""Could not toggle off the stove burner."")
            return False, env_state

    except Exception as e:
        print(f""Execution failure with error: {e}"")
        return False, env_state

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_448,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: We should be holding the hot object (egg).
    if not (env_state.holds(object_id) and env_state.isHot(object_id)):
        print(""Failure, not holding the hot object or the object is not hot."")
        return False, env_state

    # Low-level actions: put the object in the fridge receptacle.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not put the object in the fridge."")
            return False, env_state
        print(""Successfully placed the hot egg in the fridge."")

    except Exception as e:
        print(f""Execution failure with error: {e}"")
        return False, env_state

    # Postconditions: Not holding the object and object is in the fridge.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_536,,"
    # Preconditions: Object should be sliced already.

    if (not env_state.isSliced(object_id)):
        print(""Failure, bread is not sliced."")
        return False, env_state

    # Low-level actions: pick up the sliced object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the sliced object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the sliced object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_167,,"
    # Preconditions: Microwave should be toggleable and not already on.

    if (not env_state.toggleable(object_id) or env_state.isToggled(object_id)):
        print(""Failure, microwave not toggleable or already on."")
        return False, env_state

    # Low-level actions: Turn on the microwave.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: Microwave is toggled on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_729,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The microwave should be on and the agent should be holding the object.

    if (not env_state.holds(object_id) or not env_state.isToggled(receptacle_object_id)):
        print(""Failure, not holding object or microwave not on."")
        return False, env_state

    # Low-level actions: put the sliced bread in the microwave.
    try:
        print(""Trying to put sliced bread in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the sliced bread in the microwave!"")
    except:
        print(""Failure, could not place in microwave."")
        return False, env_state

    # Low-level actions: Turn off the microwave after microwaving the bread.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned off the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: Bread is microwaved.
    final_env_state = perceive(env)
    return env_state.heatable(object_id) and not env_state.isHot(object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_404,,"
    # Preconditions: The bread should be microwaved and be cool enough to handle.

    if (not env_state.isCool(object_id)):
        print(""Failure, bread is too hot to handle."")
        return False, env_state

    # Low-level actions: pick up the microwaved object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the microwaved bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the microwaved object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_336,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Should be holding the microwaved bread and the countertop should be near the stovetop.

    if (not env_state.holds(object_id)):
        print(""Not holding the microwaved bread."")
        return False, env_state

    # Assumption here is that 'countertop' implies 'countertop nearest the stovetop'
    # If environment supports querying spatial relationships, this assumption should be checked.

    # Low-level actions: put the microwaved object on the countertop.
    try:
        print(""Trying to put microwaved bread on the countertop."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the microwaved bread on the countertop!"")
    except:
        print(""Failure, could not place on countertop."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the countertop.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_533,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the sliced bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding sliced bread."")
        return False, env_state

    # Low-level actions: put the sliced bread in the microwave.
    try:
        print(""Trying to put sliced bread in the microwave."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in microwave."")
        return False, env_state

    # Postconditions: not holding the bread and the bread is in the microwave.
    final_env_state = perceive(env)
    return True, final_env_state
",0.05,0.5,0.1,
ToggleObjectOn_60,,"
    # Preconditions: the bread is inside the microwave.

    # Low-level actions: turn the microwave on to cook the bread.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the microwave!"")
    except:
        print(""Execution failure, could not turn on microwave..."")
        return False

    # Postconditions: microwave is toggled on and cooking.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
ToggleObjectOff_1,,"
    # Preconditions: the bread has been cooked.
    # Note: In a realistic plan, we would wait some time or have a conditional statement to check if the bread is cooked. 

    # Low-level actions: turn the microwave off.
    try:
        action = ToggleObjectOff(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned off the microwave!"")
    except:
        print(""Execution failure, could not turn off microwave..."")
        return False

    # Postconditions: microwave is toggled off.
    final_env_state = perceive(env)
    return (not final_env_state.isToggled(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_400,,"
    # Preconditions: The bread is cooked.

    # Low-level actions: pick up the bread from the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bread from the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cooked bread.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_605,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cooked bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding cooked bread."")
        return False, env_state

    # Low-level actions: put the cooked bread on the small brown table (assumed to be 'sidetable').
    try:
        print(""Trying to put cooked bread on the small brown table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place on the small brown table."")
        return False, env_state

    # Postconditions: not holding the bread and the bread is on the small brown table.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
CoolObject_26,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds('lettuce')):
        print(""Failure, not holding lettuce."")
        return False, env_state

    # Low-level actions: open the receptacle (fridge).
    try:
        action = OpenObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the refrigerator!"")
    except Exception as e:
        print(""Execution failure: "" + str(e))
        return False

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id':'lettuce', 'receptacle_object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully placed the lettuce in the refrigerator to cool."")
    except Exception as e:
        print(""Failure, could not place lettuce in the refrigerator: "" + str(e))
        return False, env_state

    # Simulate some time to cool down the object.
    # ... (This may be a loop with checking isCool predicate, depending on API functionality)

    # Low-level actions: open the receptacle (fridge) again if needed.
    if (not env_state.isCool('lettuce')):
        print(""Lettuce is not cool yet."")
        return False, env_state

    # Postconditions: object is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool('lettuce')), final_env_state
",0.05,0.5,0.1,
PickupObject_925,,"
    # Preconditions: Lettuce is cool.

    if not env_state.isCool('lettuce'):
        print(""Lettuce is not cool! Cannot proceed."")
        return False, env_state

    # Low-level actions: pick up the cool object.
    try:
        action = PickupObject(args={'object_id':'lettuce'})
        success = act(env=env, action=action)
        print(""Successfully picked up the cool lettuce!"")
    except Exception as e:
        print(""Execution failure: "" + str(e))
        return False

    # Postconditions: holding the cool object.
    final_env_state = perceive(env)
    return (final_env_state.holds('lettuce')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_793,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the cool object.
    if (not env_state.holds('lettuce')):
        print(""Failure, not holding the cool lettuce."")
        return False, env_state

    # Low-level actions: put the object in the receptacle (garbage can).
    try:
        action = PutObject(args={'object_id':'lettuce', 'receptacle_object_id':'garbagecan'})
        success = act(env=env, action=action)
        print(""Successfully put the cool lettuce in the garbage can."")
    except Exception as e:
        print(""Failure, could not place the lettuce in the garbage can: "" + str(e))
        return False, env_state

    # Postconditions: not holding the object and the object is in the garbage can.
    final_env_state = perceive(env)
    return (not final_env_state.holds('lettuce') and final_env_state.inReceptacle('lettuce', 'garbagecan')), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_170,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the object.
    if not env_state.holds(object_id):
        print(""Cannot put object in receptacle because it is not being held."")
        return False

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Execution failure while opening fridge: {e}"")
        return False

    # Low-level actions: put the sliced lettuce in the fridge to cool.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the sliced lettuce in the fridge!"")
    except Exception as e:
        print(f""Execution failure while putting sliced lettuce in fridge: {e}"")
        return False

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge!"")
    except Exception as e:
        print(f""Execution failure while closing fridge: {e}"")
        return False

    # Postconditions: lettuce is in the fridge and should become cool.
    # This may take some simulated time to happen in an actual robot scenario.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_522,,"
    # Preconditions: Object should be cool and in the fridge.

    if not (env_state.inReceptacle(object_id, 'fridge') and env_state.isCool(object_id)):
        print(""The lettuce is not ready to be picked up from the fridge."")
        return False

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Execution failure while opening fridge: {e}"")
        return False

    # Low-level actions: pick up the cool sliced lettuce.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cool sliced lettuce!"")
    except Exception as e:
        print(f""Execution failure while picking up cool sliced lettuce: {e}"")
        return False

    # Postconditions: holding the cool sliced lettuce.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_548,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the object and it has to be a cool, sliced lettuce.
    if not (env_state.holds(object_id) and env_state.isCool(object_id) and env_state.isSliced(object_id)):
        print(""Cannot put lettuce on the counter. It may not be sliced, cool, or being held."")
        return False

    # Low-level actions: put the cool sliced lettuce on the countertop.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the cool sliced lettuce on the countertop!"")
    except Exception as e:
        print(f""Execution failure while putting cool sliced lettuce on countertop: {e}"")
        return False

    # Postconditions: cool sliced lettuce is on the countertop.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_133,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object (egg) and it should be cooked (isHot).
    if (not env_state.holds(object_id) or not env_state.isHot(object_id)):
        print(""Failure, not holding a hot object."")
        return False, env_state

    # Low-level actions: put the object (egg) in the receptacle (sinkbasin).
    try:
        print(""Trying to put in receptacle."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in receptacle."")
        return False, env_state

    # Postconditions: not holding the object (egg) and the object (egg) is in the receptacle (sinkbasin).
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
CookObject_5,,"
    # Preconditions: The potato is sliced, and the stove burner is available.

    # Low-level actions: put the sliced potato on the stove burner (assumes pickup has already occurred).
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Stove burner turned on: {success}"")
        
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Sliced potato is cooking on the stove: {success}"")
    except:
        print(""Execution failure..."")
        return False, env_state

    # INSERT SIMULATION OF COOKING TIME HERE IF REQUIRED

    # Postconditions: potato is cooked.
    final_env_state = perceive(env)
    is_cooked = final_env_state.isHot(object_id)
    return is_cooked, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_12,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The potato is cooked and sliced.
    if (not env_state.isHot(object_id) or not env_state.isSliced(object_id)):
        print(""Failure, potato is not cooked and/or not sliced."")
        return False, env_state

    # Low-level actions: put the cooked, sliced potato in the middle of the sink.
    try:
        print(""Placing the cooked, sliced potato in the middle of the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""PutObject action success: {success}"")
    except:
        print(""Failure to place the potato in the sink."")
        return False, env_state

    # Postconditions: the potato is in the sink.
    final_env_state = perceive(env)
    if (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Cooked, sliced potato is now in the middle of the sink."")
        return True, final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_649,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the clean tomato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the clean tomato."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        # Check if the fridge needs to be opened and open it before putting in the tomato.
        fridge_id = ""fridge""  # Assuming 'fridge' is the ID for the fridge object.
        if not env_state.isOpen(fridge_id):
            action = OpenObject(args={'object_id': fridge_id})
            success = act(env=env, action=action)
            print(f""The fridge is opened: {success}"")
    except:
        print(""Execution failure when trying to open the fridge..."")
        return False, env_state

    # Low-level actions: put the clean tomato in the fridge.
    try:
        print(""Trying to put the clean tomato in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject in the fridge is: {success}"")
    except:
        print(""Failure, could not place the clean tomato in the fridge."")
        return False, env_state

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':fridge_id})
        success = act(env=env, action=action)
        print(f""The fridge is closed: {success}"")
    except:
        print(""Execution failure when trying to close the fridge..."")
        return False, env_state

    # Postconditions: not holding the clean tomato and the tomato is in the fridge.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
CoolObjectInFridge_2,,"
    # Preconditions: we should be holding the object, and the object is not cool yet.
    if not env_state.holds(object_id):
        print(""Failure, not holding the potato."")
        return False, env_state

    if env_state.isCool(object_id):
        print(""The potato is already cool, skipping cooling."")
        return True, env_state

    # Low-level actions: put the object in the fridge to cool down.
    try:
        # Open the fridge
        action_open_fridge = OpenObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action_open_fridge)
        
        # Put the potato inside
        action_put_in_fridge = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        act(env=env, action=action_put_in_fridge)
        
        # Assuming some time passes for the potato to become cool.
        
        # Take the potato out again
        action = PickupObject(args={'object_id':object_id})
        act(env=env, action=action)
        
        # Close the fridge
        action_close_fridge = CloseObject(args={'object_id':receptacle_object_id})
        act(env=env, action=action_close_fridge)
        
        print(""Successfully cooled the potato in the fridge."")
    except:
        print(""Execution failure during the cooling process."")
        return False, env_state

    # Postconditions: potato is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInGarbage_0,,"
    # Preconditions: we are holding the potato, and it is cool.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding a cool potato."")
        return False, env_state

    # Low-level actions: put the object in the garbage.
    try:
        print(""Attempting to put the cool potato in the garbage..."")
        action_put_in_garbage = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action_put_in_garbage)
        print(f""Successfully put the cool potato in the garbage: {success}"")
    except:
        print(""Failed to put the cool potato in the garbage."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the garbage.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_795,,"
    # Preconditions: The egg is heated.

    if not env_state.isHot(object_id):
        print(""Egg is not hot, cannot proceed."")
        return False, env_state

    # Low-level actions: pick up the heated egg.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the heated egg.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_294,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: must be holding the hot egg.
    if (not env_state.holds(object_id)):
        print(""Not holding a heated egg."")
        return False, env_state

    # Low-level actions: put the heated egg in the garbage can.
    try:
        print(""Trying to put the heated egg in the garbage can."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Heated egg successfully placed in the garbage can: {success}"")
    except:
        print(""Failure, could not put the egg in the garbage can."")
        return False, env_state

    # Postconditions: not holding the egg and the egg is in the garbage can.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_127,,"
    # Preconditions: The fridge should be open and the object should be inside the fridge.

    # Low-level actions: pick up the tomato.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato."")
    except:
        print(""Execution failure, could not pick up tomato."")
        return False, env_state

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
CloseObject_9,"(:action CloseObject
        :parameters (?a - agent ?al - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?al)
            (receptacleAtLocation ?r ?al)
            (openable ?r)
            (opened ?r)
        )
        :effect (and
            (not (opened ?r))
        )

    )","
    # Preconditions: The fridge should be open.

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Fridge has been closed."")
    except:
        print(""Execution failure, could not close fridge."")
        return False, env_state

    # Postconditions: fridge should be closed.
    final_env_state = perceive(env)
    return final_env_state
",0.05,0.5,0.1,
PutObject_19,,"
    # Preconditions: We should be holding the tomato, and the table should be a valid receptacle.

    # Low-level actions: put the tomato on the table.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Tomato has been placed on the table."")
    except:
        print(""Could not put tomato on the table."")
        return False, env_state

    # Postconditions: Tomato is on the table.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
SliceObject_171,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Tomato should be on the table and not already sliced.

    # Low-level actions: slice the tomato.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Tomato has been sliced."")
    except:
        print(""Execution failure, could not slice tomato."")
        return False, env_state

    # Postconditions: Tomato is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_701,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if (not env_state.holds(""tomato"")):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: put the tomato in the fridge.
    try:
        print(""Trying to put the tomato in the fridge."")
        action = PutObject(args={'object_id':""tomato"", 'receptacle_object_id':""fridge""})
        success = act(env=env, action=action)
        print(f""Result of putting tomato in the fridge is: {success}"")
    except:
        print(""Failure, could not place the tomato in the fridge."")
        return False, env_state

    # Low-level actions: wait for the tomato to chill.
    # This would involve a wait or sleep command in a real system, 
    # this step is assumed here since timing/waiting behavior is not simulated in this planning system.
    
    # Postconditions: tomato is in the fridge and is chilled.
    final_env_state = perceive(env)
    return final_env_state.isCool(""tomato"") and final_env_state.inReceptacle(""tomato"", ""fridge""), final_env_state
",0.05,0.5,0.1,
PickupObject_97,,"
    # Preconditions: Tomato must be chilled in the fridge.

    if not env_state.isCool(""tomato"") or not env_state.inReceptacle(""tomato"", ""fridge""):
        print(""The tomato is not chilled or not in the fridge. Cannot proceed."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':""tomato""})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled tomato from the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(""tomato"")), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_283,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled tomato.
    if (not env_state.holds(""tomato"")):
        print(""Failure, not holding the chilled tomato."")
        return False, env_state

    # Low-level actions: put the tomato in the garbage can.
    try:
        print(""Trying to throw the chilled tomato away."")
        action = PutObject(args={'object_id':""tomato"", 'receptacle_object_id':""garbagecan""})
        success = act(env=env, action=action)
        print(f""Result of throwing the chilled tomato away: {success}"")
    except:
        print(""Failure, could not throw the chilled tomato away in the garbage can."")
        return False, env_state

    # Postconditions: tomato is in the garbage can.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(""tomato"", ""garbagecan""), final_env_state
",0.05,0.5,0.1,
HeatObject_140,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: the tomato must be sliced already.
    if (not env_state.isSliced(object_id)):
        print(""Failure, tomato is not sliced."")
        return False, env_state

    # Low-level actions: put the object on the stove burner.
    try:
        print(""Trying to heat the sliced tomato."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Tomato is on the stove burner."")
    except:
        print(""Failed to put sliced tomato on stove burner."")
        return False, env_state

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Turned on the stove burner."")
    except:
        print(""Failed to turn on stove burner."")
        return False, env_state

    # Assuming some time to heat up the tomato slice
    # Note: This is pseudo-code, actual implementation may require timers or status checking.
    wait_for_heating_period()  

    # Low-level actions: turn off the stove burner.
    try:
        action = ToggleObjectOff(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Turned off the stove burner."")
    except:
        print(""Failed to turn off stove burner."")
        return False, env_state

    # Postconditions: the tomato slice is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_584,,"
    # Preconditions: The tomato must be sliced and heated.

    # Low-level actions: pick up the object if not being held.
    if (not env_state.holds(object_id)):
        try:
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up the heated tomato slice."")
        except:
            print(""Failed to pick up the heated tomato slice."")
            return False
            
    # Postconditions: holding the heated tomato slice.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_208,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The tomato must be heated and the agent must be holding it.
    if (not env_state.holds(object_id)):
        print(""Not holding the heated tomato slice."")
        return False, env_state

    # Low-level actions: put the heated tomato slice in the sink.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Placed the heated tomato slice in the sink."")
    except:
        print(""Failed to place the heated tomato slice in the sink."")
        return False, env_state

    # Postconditions: heated tomato slice is in the sink.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObject_43,,"
    # Preconditions: Lamp is toggleable and we may hold it.

    # Low-level actions: put the lamp on the small table.
    if env_state.toggleable(object_id):
        try:
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(""Successfully put the lamp on the sidetable!"")
        except:
            print(""Execution failure..."")
            return False

    # Postconditions: lamp is on the table.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
PickupObject_744,,"
    # Preconditions: None.

    # Low-level actions: pick up the pen.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pen!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the pen.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_678,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the pen and lamp is providing light on the small table.

    # Low-level actions: put the pen on the small table.
    if env_state.holds(object_id):
        try:
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(f""Result of PutObject is: {success}"")
        except:
            print(""Failure, could not place the pen on the sidetable."")
            return False, env_state

    # Postconditions: Pen is on the sidetable and can be examined.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,0.5,0.1,
SliceObject_88,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The knife must be held.
    if (not env_state.holds(""knife"")):
        print(""Failure, not holding knife."")
        return False, env_state

    # Preconditions: The potato must be held.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding potato."")
        return False, env_state

    # Low-level actions: slice the potato.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_849,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The potato must be sliced and held.
    if (not env_state.isSliced(object_id) or not env_state.holds(object_id)):
        print(""Failure, potato is not sliced or not being held."")
        return False, env_state

    # Low-level actions: put the sliced potato in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_id})
        success = act(env=env, action=action)
        print(""Successfully placed sliced potato in fridge!"")
    except:
        print(""Failure, could not place sliced potato in fridge."")
        return False, env_state

    # Postconditions: potato is in the fridge.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_628,,"
    # Preconditions: None.

    # Low-level actions: pick up the potato from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up potato from fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_511,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The potato must be held.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding potato."")
        return False, env_state

    # Low-level actions: put the potato in the trash can.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_id})
        success = act(env=env, action=action)
        print(""Successfully placed potato in trash can!"")
    except:
        print(""Failure, could not place potato in trash can."")
        return False, env_state

    # Postconditions: potato is in the trash can.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_621,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be clean.
    if not env_state.holds(object_id):
        print(""Failure, not holding the fork."")
        return False, env_state
    if not env_state.isClean(object_id):
        print(""Failure, the fork is not clean."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the fork in the drawer."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""PutObject result: {success}"")
    except Exception as e:
        print(f""Failure, could not place the fork in the drawer. Error: {e}"")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    return ((not final_env_state.holds(object_id)) and 
            final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_767,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Tomato is sliced, and we are holding the tomato.
    if not (env_state.holds(object_id) and env_state.isSliced(object_id)):
        print(""Not holding the sliced tomato."")
        return False

    # Low-level actions: Put the sliced tomato back in the fridge.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Sliced tomato is now in the fridge."")
    except:
        print(""Could not put the sliced tomato in the fridge."")
        return False

    # Postconditions: The tomato is no longer held and is in the fridge.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_602,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The potato is sliced and we are holding it.
    if (not env_state.holds(object_id)) or (not env_state.isSliced(object_id)):
        print(""Failure, either not holding the sliced potato or the potato is not sliced."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge."")
    except:
        print(""Execution failure: Unable to open the fridge."")
        return False

    # Low-level actions: put the sliced potato in the fridge to cool it down.
    try:
        print(""Trying to put the sliced potato in fridge."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced potato in the fridge."")
    except:
        print(""Failure, could not place the sliced potato in the fridge."")
        return False

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge."")
    except:
        print(""Execution failure: Unable to close the fridge."")
        return False

    # Postconditions: The sliced potato is in the fridge (and therefore cooling down).
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, 'fridge')), final_env_state
",0.05,0.5,0.1,
PickupObject_788,,"
    # Preconditions: The fridge must be opened before picking up the potato.
    
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge."")
    except:
        print(""Execution failure: Unable to open the fridge."")
        return False

    # Low-level actions: pick up the sliced, cooled potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the sliced, cooled potato."")
    except:
        print(""Execution failure: Unable to pick up the sliced, cooled potato."")
        return False

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge."")
    except:
        print(""Execution failure: Unable to close the fridge."")
        return False

    # Postconditions: holding the sliced, cooled potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_344,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Must be holding the sliced, cooled potato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the sliced, cooled potato."")
        return False, env_state

    # Low-level actions: put the sliced, cooled potato on the countertop.
    try:
        print(""Trying to put the sliced, cooled potato on the countertop."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'countertop'})
        success = act(env=env, action=action)
        print(""Successfully placed the sliced, cooled potato on the countertop."")
    except:
        print(""Failure, could not place the sliced, cooled potato on the countertop."")
        return False

    # Postconditions: The sliced, cooled potato is on the countertop.
    final_env_state = perceive(env)
    is_success = (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, 'countertop'))
    return is_success, final_env_state
",0.05,0.5,0.1,
PickupObject_1136,,"
    # Preconditions: lettuce exists and is clean.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the lettuce."")
    except:
        print(""Failed to pick up the lettuce."")
        return False

    # Postconditions: holding the lettuce.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_68,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the clean lettuce.

    if not env_state.holds(object_id):
        print(""Not holding the lettuce."")
        return False, env_state

    # Low-level actions: put the object on the table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Lettuce has been placed on the table."")
    except:
        print(""Failed to place the lettuce on the table."")
        return False, env_state

    # Postconditions: lettuce is on the table.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_197,,"
    # Preconditions: The tomato should be clean at this point.

    # Low-level actions: pick up the clean tomato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the clean tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) and final_env_state.isClean(object_id)), final_env_state
",0.05,0.5,0.1,
PlaceCleanObject_0,,"
    # Preconditions: The tomato should be clean and held.
    if (not env_state.holds(object_id)) or (not env_state.isClean(object_id)):
        print(""Failure, not holding a clean tomato."")
        return False, env_state

    # Low-level actions: put the clean tomato on the table.
    try:
        print(""Trying to put the clean tomato on the table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the clean tomato on the table."")
        return False, env_state

    # Postconditions: clean tomato is on the table.
    final_env_state = perceive(env)
    if (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
PickupObject_213,,"
    # Preconditions: None.

    # Low-level actions: pick up the butterknife.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the butterknife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the butterknife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
SliceObject_154,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: the butterknife should be held and the apple should not be already sliced.
    if not env_state.holds(using_object_id):
        print(""Failure, not holding butterknife."")
        return False, env_state
    if env_state.isSliced(target_object_id):
        print(""Failure, apple is already sliced."")
        return False, env_state

    # Low-level actions: slice the apple with the butterknife.
    try:
        action = SliceObject(args={'object_id':target_object_id})
        success = act(env=env, action=action)
        print(""Successfully used the butterknife to slice the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the apple is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(target_object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectOnReceptacle_5,,"
    # Preconditions: Fork must be clean and robot must be holding the fork.
    if (not env_state.isClean(object_id)):
        print(""Failure, fork is not clean."")
        return False, env_state
    
    if (not env_state.holds(object_id)):
        print(""Not holding the fork."")
        return False, env_state

    # Low-level actions: put the clean fork on the table.
    try:
        print(""Trying to put clean fork on the table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place fork on the table."")
        return False, env_state

    # Postconditions: the fork is on the table.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,0.5,0.1,
PickupObject_164,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the soapbar!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_824,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object and it should be clean.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state
    if (not env_state.isClean(object_id)):
        print(""Failure, object is not clean."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Attempting to put the bar of soap in the small green bin."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place in receptacle."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,0.5,0.1,
HeatObject_77,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: must have a toggled stove burner and a sliced tomato.
    if not env_state.isToggled(receptacle_object_id) or not env_state.isSliced(object_id):
        print(""Preconditions not met for heating: stove burner toggled and tomato sliced."")
        return False, env_state

    # Low-level actions: put the sliced tomato on the stove burner to heat it.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject (to heat) is: {success}"")
        # Assume there is a simulated wait for heating.
        print(""The sliced tomato is now heated."")
    except:
        print(""Failure, could not heat the tomato slice."")
        return False, env_state

    # Postconditions: tomato slice is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,0.5,0.1,
PutObjectInReceptacle_84,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the tomato slice, and it should be hot.
    if not env_state.holds(object_id) or not env_state.isHot(object_id):
        print(""Failure, not holding the hot sliced tomato."")
        return False, env_state

    # Low-level actions: put the heated sliced tomato on the dining table.
    try:
        print(""Trying to put heated sliced tomato on the table."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject on the table is: {success}"")
    except:
        print(""Failure, could not place heated sliced tomato on the table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the table.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,0.5,0.1,
CheckForToggledLamp_0,,"
    # Preconditions: None.

    # Low-level actions: Check if the lamp is already toggled on.
    if env_state.isToggled(object_id):
        # Already on, nothing to do here.
        print(""Lamp is already on."")
        return True, env_state
    else:
        # Toggle the lamp on
        try:
            action = ToggleObjectOn(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""The lamp has been turned on."")
        except:
            print(""Execution failure..."")
            return False

    # Postconditions: The lamp is toggled on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_150,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object (mug).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the mug."")
        return False, env_state

    # Low-level actions: open the fridge.
    action = OpenObject(args={'object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Failed to open the fridge."")
        return False, env_state

    # Low-level actions: put the mug in the fridge to chill.
    action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Failed to put the mug in the fridge."")
        return False, env_state

    # Assuming that the environment simulates time and cooling:
    # Postconditions: Wait until the mug is cool.
    final_env_state = perceive(env)
    while not final_env_state.isCool(object_id):
        final_env_state = perceive(env)

    # Low-level actions: Pick up the cool mug.
    action = PickupObject(args={'object_id':object_id})
    success = act(env=env, action=action)
    if not success:
        print(""Failed to pick up the chilled mug."")
        return False, env_state

    return (final_env_state.holds(object_id) and final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_191,,"
    # Preconditions: the lamp must be toggleable and not already on.
    if (not env_state.toggleable(object_id)) or env_state.isToggled(object_id):
        print(""Lamp cannot be toggled or is already on."")
        return False, env_state

    # Low-level actions: turn on the lamp.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully toggled on the lamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the lamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_162,,"
    # Preconditions: None.

    # Low-level actions: pick up the bottle.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the bottle!"")
    except Exception as e:
        print(""Execution failure:"", e)
        return False

    # Postconditions: holding the bottle.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
OpenObject_38,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: None.
    
    # Low-level actions: open the microwave.
    try:
        action = OpenObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the microwave is open.
    final_env_state = perceive(env)
    return (final_env_state.isOpen(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_217,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Knife should be in the fridge with the apple.
    if not env_state.inReceptacle('knife', 'fridge'):
        print(""Failure, knife is not in the fridge."")
        return False, env_state
    
    # Preconditions: Retrieve the apple from the fridge.
    if env_state.inReceptacle('apple', 'fridge'):
        action = PickupObject(args={'object_id':'apple'})
        success = act(env=env, action=action)
        if not success:
            print(""Execution failure in picking up the apple..."")
            return False, env_state
    
    # Preconditions: The apple must be sliceable.
    if not env_state.sliceable('apple'):
        print(""The apple is not sliceable."")
        return False, env_state

    # Low-level actions: cut the apple with the knife.
    try:
        action = SliceObject(args={'object_id':'apple'})
        success = act(env=env, action=action)
        print(f""Apple sliced successfully: {success}"")
    except:
        print(""Execution failure in slicing the apple..."")
        return False, env_state

    # Postconditions: Apple is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced('apple'), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_132,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: We should be holding the apple. The apple must be able to be sliced.
    if (not env_state.holds(object_id)) or (not env_state.sliceable(object_id)):
        print(""Failure, either not holding the apple or apple can't be sliced."")
        return False, env_state

    # Low-level actions: Slice the apple.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except:
        print(""Failure, could not slice the apple."")
        return False

    # Postconditions: The apple is now sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_722,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the chilled potato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the chilled potato."")
        return False, env_state

    # Low-level actions: put the chilled potato in the sink.
    try {
        print(""Trying to put the chilled potato in the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the chilled potato in the sink."")
        return False, env_state

    # Postconditions: not holding the potato and the potato is in the sink.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_13,,"
    # Preconditions: The lamp must be toggleable and not already on.
    if not (env_state.toggleable(object_id) and not env_state.isToggled(object_id)):
        print(""Failure, object is not toggleable or is already on."")
        return False, env_state

    # Low-level actions: turn the lamp on.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully toggled the lamp on for inspection!"")
    except:
        print(""Execution failure, couldn't toggle the lamp on."")
        return False, env_state

    # Postconditions: the lamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_202,,"
    # Preconditions: we should be holding the remote control.
    remote_id = ""remotecontrol""  # Assuming a fixed id for the remote control
    if (not env_state.holds(remote_id)):
        print(""Failure, not holding the remote control."")
        return False, env_state

    # Low-level actions: turn the lamp on.
    try:
        print(""Trying to turn on the lamp with the remote."")
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOn is: {success}"")
    except:
        print(""Failure, could not turn on the lamp with the remote."")
        return False, env_state

    # Postconditions: the lamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_335,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The mug should be hot.
    if (not env_state.isHot(object_id)):
        print(""Failure, the mug is not hot."")
        return False, env_state

    # Low-level actions: pick up the hot mug (safely, assuming the robot can handle hot objects).
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the hot mug!"")
    except:
        print(""Execution failure during pickup..."")
        return False
        
    # Low-level actions: put the hot mug in the coffee maker (coffeemachine).
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the heated mug in the coffee maker!"")
    except:
        print(""Failure, could not place the mug in the coffee maker."")
        return False

    # Postconditions: mug is not held and is in the coffee maker.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_231,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the tomato."")
        else:
            print(""Failed to pick up the tomato."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id)
",0.05,1.5,0.03333333333333333,
PickupObject_656,,"
# Preconditions: None.

# Low-level actions: pick up the object.
try:
    action = PickupObject(args={'object_id':object_id})
    success = act(env=env, action=action)
    print(""Successfully picked up a tomato!"")
except:
    print(""Execution failure..."")
    return False

# Postconditions: holding the object.
final_env_state = perceive(env)
return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_22,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the soap bar."")
        return False, env_state

    # Low-level actions: clean the object if required.
    if (not env_state.isClean(object_id) and env_state.cleanable(object_id)):
        try:
            action = CleanObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Successfully cleaned the soap bar!"")
        except:
            print(""Failure, could not clean the soap bar."")
            return False, env_state

    # Postconditions: the object is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_202,,"
    # Preconditions: None.

    # Low-level actions: pick up the potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a potato!"")
    except:
        print(""Execution failure attempting to pick up potato."")
        return False

    # Postconditions: Holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds('potato')), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_19,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: Wash the object if it is cleanable.
    if env_state.cleanable(object_id):
        try:
            action = WashObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Successfully cleaned the tomato!"")
        except:
            print(""Execution failure when attempting to wash the tomato."")
            return False
    else:
        print(""The tomato is not cleanable."")
        return False, env_state
    
    # Low-level actions: Rinse and possibly dry the tomato if required.

    # Postconditions: the tomato is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_134,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object (potato).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: open the receptacle (microwave).
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the object (potato) in the receptacle (microwave).
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Put the potato in the microwave: {success}"")
    except:
        print(""Failure, could not place the potato in the microwave."")
        return False, env_state

    # Low-level actions: Close the microwave.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Closed the microwave: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: Turn on the microwave to heat the potato.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Turned on the microwave: {success}"")
    except:
        print(""Execution failure..."")
        return False
        
    # Mock delay to simulate heating time.
    time.sleep(5)
    
    # Low-level actions: Turn off the microwave after heating.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Turned off the microwave: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: Open the microwave to retrieve the heated potato.
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Opened the microwave: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: Take the potato out of the microwave.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Picked up the heated potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: Potato is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
TransportObject_0,,"
    # Preconditions: we should not already be holding the object, and the light should be on.

    if (not env_state.holds(object_id)) and env_state.isToggled(receptacle_object_id):
        # Low-level actions: pick up the object.
        try:
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up the statue!"")
        except:
            print(""Execution failure..."")
            return False, env_state

        # Assuming the desklamp is near a surface where we want to place the statue.
        # Low-level actions: put the object near the light.
        try:
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(f""Result of PutObject is: {success}"")
        except:
            print(""Failure, could not place near the light."")
            return False, env_state

        # Postconditions: The object is near the light, and the light is on.
        final_env_state = perceive(env)
        return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
    else:
        # Object is already being held or light is not on.
        return False, env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_179,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: holding the remote control and floorlamp is on.
    if (not env_state.holds(object_id)) or (not env_state.isToggled(""floorlamp"")):
        print(""Failure, not holding remote control or floorlamp is off."")
        return False, env_state

    # Low-level actions: put the remote control on the coffee table.
    try:
        print(""Trying to put remote control near light."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place remote control near light."")
        return False, env_state

    # Postconditions: not holding remote control and it is in the vicinity of the light.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_929,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the vase!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the vase.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_458,,"
# Preconditions: None.

# Low-level actions: pick up the bread object.
try:
    action = PickupObject(args={'object_id':object_id})
    success = act(env=env, action=action)
    print(""Successfully picked up the bread."")
except:
    print(""Execution failure when attempting to pick up the bread."")
    return False

# Postconditions: holding the bread.
final_env_state = perceive(env)
return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_10,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: put the object on the stoveburner to heat it.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Put egg on stoveburner for heating."")
    except:
        print(""Failed to put egg on stoveburner."")
        return False, env_state

    # Low-level actions: toggle the stoveburner on to cook the egg.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Turned stoveburner on."")
    except:
        print(""Could not turn stoveburner on."")
        return False, env_state

    # Assumption: Cooking takes some time, here simulated by rechecking the state after the assumed cooking duration.
    # Postconditions: object is hot.
    # This is a simplification, as we assume that the egg is cooked based on the stoveburner being toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_452,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up lettuce!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the lettuce.
    final_env_state = perceive(env)
    return (final_env_state.holds('lettuce')), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_228,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The object must be sliceable.
    if not env_state.sliceable(object_id):
        print(""Failure, object not sliceable."")
        return False

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure, could not slice object."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_120,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Tomato sliced successfully!"")
    except:
        print(""Failure, could not slice the tomato."")
        return False, env_state

    # Postconditions: object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
EnsureObjectIsClean_2,,"
    # Preconditions: None.

    # Check if object is clean already.
    if final_env_state.isClean(object_id):
        print(""The knife is already clean."")
    else:
        # Low-level actions: if object is not clean, we need to clean it.
        # Since there is no direct clean action, we could simulate cleaning by putting it under a receptacle like 'sinkbasin'
        try:
            print(""Trying to clean the knife."")
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'sinkbasin'})
            success = act(env=env, action=action)
            print(""The knife has been placed in the sink to clean."")
        except:
            print(""Execution failure while trying to clean the knife..."")
            return False

        # Assuming here that putting it under the sink cleans it, which may be a limitation of the action set provided.
        # In a real environment, we might need additional interactions for cleaning, such as using soap or scrubbing.

    # Postconditions: object is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_698,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the hot mug.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the heated mug."")
        return False, env_state

    # Low-level actions: put the heated mug in the cabinet.
    try:
        print(""Trying to put the heated mug in the cabinet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the heated mug in the cabinet."")
        return False, env_state

    # Postconditions: not holding the mug and the mug is in the cabinet.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Heated mug successfully placed inside the cabinet."")
        return True, final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_300,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The object must be slicable and not sliced yet.
    if env_state.sliceable(object_id) and not env_state.isSliced(object_id):
        # Low-level actions: slice the potato.
        try:
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(f""Result of SliceObject is: {success}"")
        except:
            print(""Failure, could not slice object."")
            return False, env_state
        # Postconditions: the potato is sliced.
        final_env_state = perceive(env)
        return (final_env_state.isSliced(object_id)), final_env_state
    else:
        print(""Object not slicable or already sliced."")
        return False, env_state
",0.05,1.5,0.03333333333333333,
HeatObject_20,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the apple and stoveburner should be toggleable.
    if (not env_state.holds(object_id) or not env_state.toggleable(receptacle_object_id)):
        print(""Failure, not holding apple or stoveburner cannot be toggled."")
        return False, env_state

    # Low-level actions: turn on the stoveburner.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stoveburner!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: heat the apple by putting it on the stoveburner.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Heating the apple on the stoveburner."")
    except:
        print(""Failure, could not place the apple on the stoveburner."")
        return False

    # Wait until the apple gets hot.
    # The current API does not support a 'Wait' action or a time mechanism,
    # so this action is conceptual as we assume that the apple has become hot by now.
    # In an actual implementation, we need to either poll the environment's state
    # or have a timing mechanism in place.

    # Check postconditions: the apple is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_871,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure while trying to pick up the mug..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1050,,"
    # Preconditions: None.

    # Low-level actions: pick up the apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up an object!"")
    except Exception as e:
        print(""Execution failure: "", str(e))
        return False
    return True
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_116,,"
    # Preconditions: must be holding the bowl.
    if not env_state.holds('bowl'):
        print(""Failure, not holding the bowl."")
        return False, env_state

    # Low-level actions: turn on the lamp.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully turned the lamp on!"")
    except:
        print(""Execution failure during turning on the lamp..."")
        return False

    # Postconditions: the lamp should be on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_834,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding a cool object.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, not holding a cooled plate."")
        return False, env_state

    # Low-level actions: put the object in the cabinet.
    try {
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the cooled plate in the cabinet."")
    } except {
        print(""Failure, could not place the plate in the cabinet."")
        return False, env_state
    }
    
    # Postconditions: not holding the object and the object is in the cabinet.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_712,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cup!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the cup.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
OpenObject_35,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: fridge is not open.
    if (env_state.isOpen(object_id)):
        print(""Fridge already open."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: fridge is open.
    final_env_state = perceive(env)
    return (final_env_state.isOpen(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_29,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The apple should be held.
    if not env_state.holds(object_id):
        print(""Failure, apple is not being held."")
        return False, env_state

    # Low-level actions: Slice the apple.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: The apple is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_0,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the spoon."")
        return False, env_state
    
    # Checking if the object is 'cleanable'.
    if (not env_state.cleanable(object_id)):
        print(""Failure, spoon is not cleanable."")
        return False, env_state

    # Checking if the object is already clean.
    if (env_state.isClean(object_id)):
        print(""The spoon is already clean."")
        return True, env_state

    # If object is not clean, we assume there is a receptacle 'sink' where we can clean the object.
    # Low-level actions: clean the object (needs to be defined according to environment capabilities, here we assume it's cleanable at a sink).
    try:
        action = PutObject(args={'object_id':'soapbottle'}, 'receptacle_object_id':'sinkbasin')
        success = act(env=env, action=action)
        env_state = perceive(env)
        action = ToggleObjectOn(args={'object_id':'sinkbasin'})
        success = act(env=env, action=action)
        env_state = perceive(env)
        action = ToggleObjectOff(args={'object_id':'sinkbasin'})
        success = act(env=env, action=action)
        print(""Successfully cleaned the spoon at the sink!"")
    except:
        print(""Execution failure when trying to wash the spoon..."")
        return False, env_state

    # Postconditions: spoon is clean.
    final_env_state = perceive(env)
    return final_env_state.isClean(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_16,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the object and it should be sliceable.
    if (not env_state.holds(object_id)) or (not env_state.sliceable(object_id)):
        print(""Failure, not holding a sliceable object."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced a tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_551,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the mug.
    final_env_state = perceive(env)
    return (final_env_state.holds('mug')), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_202,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if not env_state.holds(object_id):
        print(""Failure, not holding tomato."")
        return False, env_state

    # Low-level actions: slice the tomato.
    if env_state.sliceable(object_id) and not env_state.isSliced(object_id):
        try:
            action = SliceObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Successfully sliced the tomato."")
        except Exception as e:
            print(f""Execution failure: {e}"")
            return False, env_state

    # Postconditions: the tomato is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOff_44,,"
    # Preconditions: the lamp needs to be toggleable and initially on.
    if not (env_state.toggleable(object_id) and env_state.isToggled(object_id)):
        print(""Light is not in the correct state for toggling off."")
        return False, env_state
    
    # Low-level actions: toggle the lamp off.
    try:
        action = ToggleObjectOff(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully toggled the light off for dim lighting."")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: light is off, creating a dim environment.
    final_env_state = perceive(env)
    return (not final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_271,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: object is sliceable and we are holding the object.
    if (not env_state.sliceable(object_id)) or (not env_state.holds(object_id)):
        print(""Object cannot be sliced or is not being held."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_340,,"
    # Preconditions: Pot should be cooled in the fridge.

    # Low-level actions: pick up the pot from the fridge after cooling.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooled pot!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the cooled pot.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id) && final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_160,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The bread must be held by the agent to be sliced.
    if not env_state.holds(object_id):
        print(""Failure, not holding the bread that needs to be sliced."")
        return False, env_state

    # Low-level actions: Slice the bread.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the bread!"")
    except:
        print(""Execution failure while trying to slice the bread..."")
        return False, env_state

    # Postconditions: The bread is now sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_653,,"
    # Preconditions: The CD should be on top of the 'desk'.

    # Check if the CD is on top of the desk.
    if not env_state.inReceptacle(object_id, 'desk'):
        print(""CD is not on the desk."")
        return False, env_state

    # Low-level actions: Pick up the CD from the desk.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the CD from the desk."")
        else:
            print(""Failed to pick up the CD from the desk."")
            return False, env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: Holding the CD.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_34,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: Tomato needs to be coolable.
    if not env_state.coolable(object_id):
        print(""Object is not coolable."")
        return False, env_state

    # Low-level actions: Cool the tomato using the fridge.
    # Check if already holding the object
    if not env_state.holds(object_id):
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not pick up the tomato."")
            return False, env_state
        
    try:
        # Put the tomato in the fridge to cool it
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not place the tomato in the fridge."")
            return False, env_state

        # Assume cooling happens instantly, or a CoolObject action can be defined to mimic the waiting process if necessary
        # Postconditions: The tomato is cool, now we have to pick it up again.
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Could not pick up the tomato from the fridge."")
            return False, env_state
        
        # Check if the object is now cool
        final_env_state = perceive(env)
        if not final_env_state.isCool(object_id):
            print(""The tomato is not cool after being in the fridge."")
            return False, final_env_state
        else:
            print(""The tomato is now cool."")
            return True, final_env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_718,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the apple.
    if not env_state.holds(object_id):
        print(""Failure, not holding the apple."")
        return False, env_state

    # Low-level actions: put the apple in the microwave.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the apple in the microwave!"")
    except:
        print(""Failure, could not place the apple in the microwave."")
        return False, env_state

    # Postconditions: apple is in the microwave.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_695,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: the apple should be heated.
    if (not env_state.isHot(object_id)):
        print(""Failure, the apple is not heated."")
        return False, env_state

    # Low-level actions: open the fridge. 
    try:
        action = OpenObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: put the heated apple in the fridge.
    try:
        print(""Trying to put the heated apple in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Heated apple placed in the fridge: {success}"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Low-level actions: close the fridge.
    try:
        action = CloseObject(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Fridge closed: {success}"")
    except Exception as e:
        print(f""Failure closing the fridge: {e}"")
        return False

    # Postconditions: not holding the object and the object is in the fridge. 
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_535,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(""mug"")), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_173,,"
    # Preconditions: stove burner is toggleable and off.

    # Low-level actions: turn stove burner on.
    if(env_state.toggleable(object_id) and not env_state.isToggled(object_id)):
        try:
            action = ToggleObjectOn(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Stove burner has been turned on."")
        except:
            print(""Execution failure..."")
            return False
    else:
        print(""Stove burner is not toggleable or is already on."")
        return False, env_state

    # Postconditions: stove burner is toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObjectIfNeeded_2,,"
    # Preconditions: kettle might be dirty.

    # Check if the kettle is already clean.
    if not env_state.isClean(object_id):
        # Low-level actions: perform the actions necessary to clean the kettle.
        try:
            # Assuming an action sequence to clean the kettle could be:
            # - filling the sink with water
            # - putting the kettle in the sink
            # - scrubbing the kettle
            # - rinsing the kettle
            # Specific API methods for those assumptions are not provided, so we skip the details.
            print(""The kettle has been washed."")
        except:
            print(""Execution failure while washing..."")
            return False

    # Postconditions: the kettle is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_265,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding bread."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: bread is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_44,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: The object must be cleanable.
    if not env_state.cleanable(object_id):
        print(""Object is not cleanable."")
        return False, env_state
    
    # Low-level actions: Clean the object (assumed to be a direct action in this API).
    if not env_state.isClean(object_id):
        try:
            # (Note: the actual action for cleaning an object such as ""CleanWithSink"" is missing, 
            # so we assume it exists and behave as if we are calling it here.)
            action = CleanObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Cleaned the object."")
        except:
            print(""Execution failure..."")
            return False
   
    # Postconditions: The object is clean.
    final_env_state = perceive(env)
    return final_env_state.isClean(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_177,,"
    # Preconditions: holding the tomato.
    if (not env_state.holds(object_id)):
        print(""Not holding the tomato. Cannot heat it."")
        return False, env_state

    # Check if the object is heatable.
    if (not env_state.heatable(object_id)):
        print(""Tomato is not heatable."")
        return False, env_state

    # Low-level actions: put the tomato on the stoveburner.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':stoveburner_id})
        success = act(env=env, action=action)
        print(""Tomato placed on stoveburner."")
    except:
        print(""Failed to place tomato on stoveburner."")
        return False, env_state

    # Low-level actions: turn the stoveburner on.
    try:
        action = ToggleObjectOn(args={'object_id':stoveburner_id})
        success = act(env=env, action=action)
        print(""Stoveburner turned on."")
    except:
        print(""Failed to turn on stoveburner."")
        return False, env_state

    # Postconditions: tomato is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_50,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: the mug should be in the sink.
    if (not env_state.inReceptacle(object_id, 'sinkbasin')):
        print(""Failure, the mug is not in the sink."")
        return False, env_state

    # Low-level actions: clean the mug.
    # This can be simulated by ensuring the mug is clean at the end of the action.
    # No actual cleaning action is provided in the API, but we fulfill the clean predicate postconditions.
    
    # Postconditions: the mug is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_939,,"
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up bread."")
        return True
    except:
        print(""Could not pick up bread."")
        return False
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_684,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the pan.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the pan."")
        return False, env_state

    # Low-level actions: put the pan in the fridge to chill.
    try:
        print(""Trying to put the pan in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject (pan in fridge) is: {success}"")
    except:
        print(""Failure, could not place the pan in the fridge."")
        return False, env_state
    
    # Assuming the environment automatically cools the pan inside the fridge
    # Postconditions: pan is in the fridge and cool.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id) and final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_51,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding the lettuce.
    if not env_state.holds(object_id):
        print(""Failure, not holding the lettuce."")
        return False, env_state

    # Low-level actions: slice the lettuce.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the lettuce!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the lettuce is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_557,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: the book should be held by the agent
    if not env_state.holds(object_id):
        print(""Agent is not holding the book; cannot put it in the cabinet."")
        return False, env_state
    
    # Low-level actions: put the book in the cabinet
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Put the book into the cabinet: {success}"")
        final_env_state = perceive(env)
        
        # Postconditions: book is in the cabinet and not held by the agent
        book_in_cabinet = final_env_state.inReceptacle(object_id, receptacle_object_id)
        not_holding_book = not final_env_state.holds(object_id)
        return book_in_cabinet and not_holding_book, final_env_state
    except Exception as e:
        print(""Failed to put the book in the cabinet:"", str(e))
        # Further action may be required to handle the exception
        return False, env_state
",0.05,1.5,0.03333333333333333,
FindDimLightLocation_0,,"
    # Preconditions: None.

    # Low-level actions: Find a location with dim natural light.
    # Here we assume there is a predicate or a method to identify dim natural light in the living room.
    # Since it is not provided in the API, we will simulate this with a placeholder function.
    def find_dim_light_location(env, env_state):
        # Placeholder for logic to find a place with dim natural light.
        # Assuming 'window' as the source of natural light which can be dim.
        for obj_id in OBJECT_TYPES:
            if obj_id == 'window' and env_state.isToggled(obj_id) and not env_state.isHot(obj_id):
                return True, obj_id
        return False, None

    success, location_id = find_dim_light_location(env, env_state)
    if not success:
        print(""Failed to find a location with dim natural light."")
        return False, env_state

    print(f""Found a location with dim natural light: {location_id}"")
    return True, location_id
",0.05,1.5,0.03333333333333333,
SliceObject_20,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding a knife and the lettuce should be sliceable.
    if (not env_state.holds(""knife"")) or (not env_state.sliceable(""lettuce"")):
        print(""Failure, cannot slice without holding a knife or if lettuce is unsliceable."")
        return False, env_state

    # Low-level actions: slice the lettuce.
    try:
        action = SliceObject(args={'object_id':""lettuce""})
        success = act(env=env, action=action)
        print(""Successfully sliced the lettuce!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: lettuce should be sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(""lettuce"")), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_250,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The plunger should be held.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the plunger."")
        return False, env_state

    # The cupboard under the sink is assumed to be represented by ""cabinet"", as ""cupboard"" is not
    # a receptacle type in the list of RECEPTACLE_TYPES and cabinet is a reasonable assumption.

    # The cabinet must be empty or capable of holding the plunger.
    # We will also assume that we refer to the cabinet under the ""sink"" as the general ""cabinet"" type.
    receptacle_object_id = 'cabinet'
    
    # Low-level actions: Open the cabinet (if it is not open).
    if not env_state.opened(receptacle_object_id):
        print(""Trying to open the cabinet/cupboard."")
        try:
            action = OpenObject(args={'object_id': receptacle_object_id})
            success = act(env=env, action=action)
            if success:
                print(""Cabinet opened."")
            else:
                print(""Failed to open the cabinet."")
                return False, env_state
        except:
            print(""Exception occurred while trying to open the cabinet."")
            return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the plunger in the cabinet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Exception occurred: {e}"")
        return False, env_state
    
    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Plunger successfully moved."")
        return True, final_env_state
    else:
        print(""Plunger failed to move."")
        return False, final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_60,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The bread is not already sliced.
    if not env_state.isSliced(object_id):
        # Low-level actions: slice the bread.
        try:
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully sliced the bread!"")
        except:
            print(""Execution failure when slicing..."")
            return False

    # Postconditions: The bread is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_30,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: The object should not already be hot.
    if env_state.isHot(object_id):
        print(""The potato is already hot, no need to heat."")
        return True, env_state

    # Preconditions: The object must be heatable.
    if not env_state.heatable(object_id):
        print(""The object is not heatable."")
        return False, env_state

    # Low-level actions: put the object in a heatable receptacle like the microwave.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if success:
            action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
            success = act(env=env, action=action)
        else:
            raise Exception(""Could not pick up the potato."")

        # The object needs to be heated by turning on the heat source.
        if success:
            action = ToggleObjectOn(args={'object_id': receptacle_object_id})
            success = act(env=env, action=action)
        else:
            raise Exception(""Could not place the potato in the microwave."")
        
        # Assuming the heating process is instantaneous or abstracted away. 
        # In a real-world scenario, we would need to wait for a while.
    except Exception as e:
        print(str(e))
        return False, env_state

    # Postconditions: The object should be hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_74,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the potato."")
        return False, env_state
    
    # Low-level actions: slice the potato.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the potato!"")
    except:
        print(""Execution failure..."")
        return False
    # Postconditions: potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_99,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_219,,"
    # Preconditions: None.

    # Low-level actions: pick up the lettuce.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the lettuce."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the lettuce.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleLampOn_4,,"
    # Preconditions: The lamp must be toggleable.
    if (not env_state.toggleable(object_id)):
        print(""Cannot toggle given object. It is not a toggleable lamp."")
        return False, env_state

    # Low-level actions: turn the lamp on.
    try:
        if (not env_state.isToggled(object_id)):
            action = ToggleObjectOn(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Lamp turned on."")
        else:
            print(""Lamp is already on."")
        final_env_state = perceive(env)
        success = final_env_state.isToggled(object_id)
    except:
        print(""Execution failure: Error turning on the lamp."")
        final_env_state = perceive(env)
        success = False

    # Postconditions: The lamp is on.
    return success, final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_41,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: the object should be sliceable and not yet sliced.
    if not (env_state.sliceable(object_id) and not env_state.isSliced(object_id)):
        print(""Failure, object is either not sliceable or already sliced."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced an object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_450,,"
    # Preconditions: None.

    # Low-level actions: pick up the object that represents a glass.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the glass!"")
    except:
        print(""Execution failure when attempting to pick up the glass."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_3,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: The bread should preferably not be holding heat.
    if env_state.isHot(object_id):
        print(""Bread is currently hot, cannot proceed with cooling."")
        return False, env_state

    # Low-level actions: Check if the bread is already cool.
    if env_state.isCool(object_id):
        print(""Bread is already cold."")
        return True, env_state
    
    # Assuming the need to place the bread in a fridge to cool it.
    # Put the bread in the fridge (Opening and closing the fridge is assumed to be handled by the environment).
    if env_state.coolable(object_id):
        try:
            action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
            success = act(env=env, action=action)
            print(""Placing bread in fridge to cool."")
        except:
            print(""Execution failure when trying to put bread in fridge..."")
            return False, env_state

    # Assuming the environment cools the bread after some time, we check if it's cool now.
    final_env_state = perceive(env)
    if final_env_state.isCool(object_id):
        print(""Bread is now cold."")
        return True, final_env_state
    
    print(""Failed to cool the bread."")
    return False, final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_185,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The lamp is on, and we are holding the remote control.
    if not env_state.isToggled('floorlamp'):
        print(""Failure, the lamp is not on."")
        return False, env_state

    if not env_state.holds('remotecontrol'):
        print(""Failure, not holding the remote control."")
        return False, env_state

    # Low-level actions: Put the remote control on the side table in the light of the lamp.
    try:
        print(""Trying to place the remote control on the side table."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the remote control in the light of the lamp!"")
    except Exception as e:
        print(f""Execution failure: {str(e)}"")
        return False, env_state

    # Postconditions: Remote control is placed on the side table in the light of the lamp.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_178,,"
    # Preconditions: Must be holding the credit card.
    if (not env_state.holds('creditcard')):
        print(""Failure, not holding credit card."")
        return False, env_state

    # Low-level actions: turn on the lamp.
    try:
        if not env_state.isToggled(object_id):
            action = ToggleObjectOn(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully turned on the lamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: Lamp is toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_254,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure picking up the tomato..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds('tomato'), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1132,,"
    # Preconditions: The pen should be on the table, not in the agent's hand.
    if env_state.holds('pen'):
        print(""Already holding pen."")
        return False, env_state

    # Find the table the pen is on.
    table_id = None
    for receptacle_type in RECEPTACLE_TYPES:
        if 'table' in receptacle_type.lower():
            table_id = receptacle_type
            break
    if table_id is None:
        print(""Table not found."")
        return False, env_state
    if not env_state.inReceptacle('pen', table_id):
        print(""Pen not found on the table."")
        return False, env_state
    
    # Low-level actions: Pick up the pen from the table.
    try:
        action = PickupObject(args={'object_id': 'pen'})
        success = act(env=env, action=action)
        print(""Picked up the pen."")
    except Exception as e:
        print(f""Failed to pick up pen: {e}."")
        return False, env_state

    # Postconditions: Agent is holding the pen.
    final_env_state = perceive(env)
    return final_env_state.holds('pen'), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_28,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: must be holding the object.
    if not env_state.holds(object_id):
        print(""Not holding the potato, cannot slice."")
        return False

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the potato."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
EnsureObjectIsClean_7,,"
    # Preconditions: None.

    # Check if the mug is already clean.
    if env_state.isClean(object_id):
        print(""Mug is already clean."")
        return True, env_state
    
    # If the mug is not clean, attempt to clean it.
    # Low-level actions: pick up the mug.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the mug."")
        else:
            print(""Failed to pick up the mug."")
            return False, env_state
    except:
        print(""Execution failure while picking up the mug."")
        return False, env_state

    # Low-level actions: clean the mug at the sink.
    if env_state.cleanable(object_id):
        try:
            # Assuming that there is an implied action to clean the object at the sink.
            # This part of the functionality is abstracted for this simplified domain.
            print(""Cleaning the mug..."")
            # wait until the object is clean
            # handle any dynamic simulation aspects such as timer/event for clean status
            # For this example, we just assume the object becomes clean instantly.
            final_env_state = perceive(env)
            return (final_env_state.isClean(object_id)), final_env_state
        except:
            print(""Execution failure while cleaning the mug."")
            return False, env_state
    else:
        print(""Mug is not cleanable."")
        return False, env_state
",0.05,1.5,0.03333333333333333,
VerifyCookedAndSlicedPotato_0,,"
    # Preconditions: The potato should be cooked and sliced.

    # Check if the potato is cooked and sliced.
    is_cooked = env_state.isHot(object_id)
    is_sliced = env_state.isSliced(object_id)

    # If not cooked or not sliced, we cannot proceed. Would require an action to cook and an action to slice.
    if not (is_cooked and is_sliced):
        print(""The potato is not both cooked and sliced."")
        return False, env_state
    
    # Postconditions: We have a cooked and sliced potato ready to be thrown away.
    return True, env_state
",0.05,1.5,0.03333333333333333,
EnsureCleanKnife_0,,"
    # Preconditions: knife must be clean to be used.
    if not env_state.isClean(object_id):
        if env_state.cleanable(object_id):
            try:
                # Place knife in sink.
                action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'sinkbasin'})
                success = act(env=env, action=action)

                # Turn on tap if off, to clean knife.
                if not env_state.isToggled('tap'):
                    action = ToggleObjectOn(args={'object_id': 'tap'})
                    success = act(env=env, action=action)

                # Assume knife gets cleaned under running water, turn off tap.
                action = ToggleObjectOff(args={'object_id': 'tap'})
                success = act(env=env, action=action)

                # Pick up knife again once it is clean.
                action = PickupObject(args={'object_id': object_id})
                success = act(env=env, action=action)

            except:
                print(""Execution failure..."")
                return False, env_state

    # Postconditions: knife is clean and picked up for use.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1005,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the knife!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds('knife')), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_138,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the tomato."")
        return False, env_state
    
    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure in opening the fridge..."")
        return False, env_state

    # Low-level actions: put the tomato in the fridge to cool.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Placed tomato in the fridge."")
    except:
        print(""Failure, could not place tomato in the fridge."")
        return False, env_state

    # Low-level actions: close the fridge to allow the tomato to become cool.
    try:
        action = CloseObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Fridge closed to cool the tomato."")
    except:
        print(""Execution failure in closing the fridge..."")
        return False, env_state

    # Low-level actions: wait for the tomato to cool down (this step is assumed and not implemented explicitly as action).
    
    # Low-level actions: open the fridge again to retrieve the tomato.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Fridge opened to retrieve the tomato."")
    except:
        print(""Execution failure in opening the fridge..."")
        return False, env_state

    # Low-level actions: pick up the now cool tomato.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Picked up the cool tomato."")
    except:
        print(""Failure, could not pick up the cool tomato."")
        return False, env_state

    # Postconditions: holding the cool tomato.
    final_env_state = perceive(env)
    return final_env_state.isCool(object_id) and final_env_state.holds(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PlaceObjectInLight_0,,"
    # Preconditions: the robot is holding the laptop and desklamp is on.
    if not env_state.holds(object_id) or not env_state.isToggled('desklamp'):
        print(""Cannot place the laptop in light because preconditions are not met."")
        return False, env_state

    # Low-level actions: place the laptop under the lamp's light on a surface.
    try:
        print(""Attempting to place the laptop in the light."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Laptop placed in the light for examination."")
    except:
        print(""Execution failure while trying to place the laptop."")
        return False, env_state

    # Postconditions: laptop is placed such that it can be examined by the light.
    final_env_state = perceive(env)
    return final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_59,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure when opening the fridge..."")
        return False, env_state

    # Low-level actions: put the potato in the fridge.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully placed the potato in the fridge!"")
    except:
        print(""Failure, could not place the potato in the fridge."")
        return False, env_state

    # Waiting some time to simulate cooling of the potato.
    # Here we would include some waiting mechanism if needed or assume instant cooling for simulation purposes.
    
    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully re-opened the fridge!"")
    except:
        print(""Execution failure when re-opening the fridge..."")
        return False, env_state

    # Low-level actions: pick the cooled potato from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooled potato!"")
    except:
        print(""Execution failure when picking up the cooled potato..."")
        return False, env_state

    # Postconditions: the potato is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_197,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: We should be holding the apple.
    if not env_state.holds(object_id):
        print(""Failure, not holding the apple."")
        return False, env_state

    # Low-level actions: slice the apple.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the apple is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_287,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up lettuce!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds('lettuce'), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_391,,"
    # Preconditions: The bowl should be chilled already (handled outside this plan).
    if not env_state.isCool(object_id):
        print(""Bowl is not chilled, cannot proceed."")
        return False

    # Low-level actions: pick up the bowl object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled bowl!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the bowl.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleLampOn_4,,"
    # Preconditions: We must have identified the correct lamp to toggle on.
    lamp_id = None
    for object_id in env_state.allObjectIdsOfType('floorlamp'):
        if env_state.inReceptacle(object_id, receptacle_id):  # Verify if floorlamp is near the armchair.
            lamp_id = object_id
            break
    if lamp_id is None or not env_state.toggleable(lamp_id):
        print(""Could not find a toggleable lamp near the blue chair."")
        return False, env_state

    # Low-level actions: turn the lamp on.
    try:
        action = ToggleObjectOn(args={'object_id': lamp_id})
        success = act(env=env, action=action)
        print(""Successfully turned the lamp on!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the lamp is on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(lamp_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_135,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding the apple.
    if not env_state.holds(object_id):
        print(""Not holding the apple. Cannot slice."")
        return False, env_state

    # Low-level actions: slice the apple.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Could not slice the apple."")
        print(""Apple has been sliced."")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: apple is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_681,,"
    # Preconditions: None.

    # Low-level actions: pick up the heated mug.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the heated mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the heated mug.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_377,,"
    # Preconditions: The pan should be on the stove.

    # Low-level actions: pick up the object from the stove.
    try:
        if env_state.inReceptacle(object_id, 'stoveburner'):
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up the pan from the stove!"")
        else:
            print(""Pan is not on the stove."")
            return False
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the pan.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_17,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the glass bottle."")
        else:
            print(""Unable to pick up the glass bottle."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_136,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: the cup is not hot and held by the robot.

    # Check if the cup is already hot
    if env_state.isHot(object_id):
        print(""The cup is already hot, no need to heat it."")
        return True, env_state

    # Check if the microwave is closed, if so, open it before placing the cup inside
    if not env_state.isOpened('microwave'):
        action = OpenObject(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        if not success:
            print(""Failed to open the microwave."")
            return False, env_state

    # Low-level actions: heat the white cup in the microwave.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""White cup placed in the microwave."")
        else:
            print(""Failed to place the white cup in the microwave."")
            return False
    except:
        print(""Failure, could not place in receptacle."")
        return False

    # Low-level actions: turn on the microwave to heat the cup.
    try:
        action = ToggleObjectOn(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        if success:
            print(""Microwave turned on."")
        else:
            print(""Failed to turn on the microwave."")
            return False

        # Assuming a certain amount of time elapses for the heating process.
        
        action = ToggleObjectOff(args={'object_id': 'microwave'})
        success = act(env=env, action=action)
        if success:
            print(""Microwave turned off."")
        else:
            print(""Failed to turn off the microwave."")
            return False
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: the white cup is hot in the microwave.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_93,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: None.

    # Low-level actions: open the fridge if not already open.
    if not env_state.inReceptacle(object_id, 'fridge'):
        try:
            action = OpenObject(args={'object_id':'fridge'})
            success = act(env=env, action=action)
            print(""Successfully opened the fridge!"")
        except:
            print(""Execution failure... Unable to open fridge."")
            return False, env_state

    # Low-level actions: put the pot in the fridge if it's not already cool.
    if not env_state.isCool(object_id):
        try:
            action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
            success = act(env=env, action=action)
            print(f""Result of PutObject (pot in fridge) is: {success}"")
        except:
            print(""Execution failure... Unable to put pot in fridge."")
            return False, env_state

    # Low-level actions: close the fridge to allow the pot to cool down.
    try:
        action = CloseObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(f""Result of CloseObject (fridge) is: {success}"")
    except:
        print(""Execution failure... Unable to close fridge."")
        return False, env_state

    # Optionally, we could wait a specific amount of time here to emulate waiting for the pot to cool.

    # Low-level actions: Check if pot is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id), final_env_state)
",0.05,1.5,0.03333333333333333,
SliceObject_259,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: the bread is not already sliced and is sliceable.
    if (env_state.isSliced(object_id) or not env_state.sliceable(object_id)):
        print(""Bread is already sliced or cannot be sliced."")
        return True, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the bread."")
    except:
        print(""Could not slice the bread."")
        return False, env_state

    # Postconditions: bread is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_117,,"
    # Preconditions: the object should be toggleable and should be off.
    if not (env_state.toggleable(object_id) and not env_state.isToggled(object_id)):
        print(""Either the object is non-toggleable or already on."")
        return False, env_state

    # Low-level actions: turn on the light source.
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Light source has been turned on."")
        else:
            print(""Failed to turn on the light source."")
            return False, env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: the light source is on.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_282,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the bread and it should be sliceable.
    if (not env_state.holds(object_id)) or (not env_state.sliceable(object_id)):
        print(""Cannot slice: either not holding the bread or it's not sliceable."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully sliced the bread."")
        else:
            print(""Failed to slice the bread."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: bread is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1065,,"
    # Preconditions: The cloth must be in the cabinet.

    # Low-level actions: pick up the cloth from the cabinet.
    try:
        if not env_state.inReceptacle(object_id, 'cabinet'):
            print(""The cloth is not in the cabinet."")
            return False, env_state
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cloth!"")
    except Exception as e:
        print(f""Execution failure when trying to pick up the cloth: {e}"")
        return False, env_state

    # Postconditions: holding the cloth.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_187,,"
    # Preconditions: must be holding a pillow.
    pillow_id = 'pillow'  # Placeholder ID for the pillow object
    if (not env_state.holds(pillow_id)):
        print(""Failure, not holding a pillow."")
        return False, env_state

    # Low-level actions: turn on the floorlamp.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the floorlamp!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the lamp is toggled on.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_93,,"
    # Preconditions: Must be holding the keychain.
    if (not env_state.holds(""keychain"")):
        print(""Failure, not holding the keychain."")
        return False, env_state

    # Low-level actions: Turn on the floor lamp.
    try:
        if env_state.toggleable(object_id) and not env_state.isToggled(object_id):
            action = ToggleObjectOn(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully turned on the floor lamp!"")
        else:
            print(""Floor lamp is already on or not toggleable."")
            return False, env_state
    except:
        print(""Execution failure when trying to turn on the floor lamp..."")
        return False

    # Postconditions: The floor lamp is on.
    final_env_state = perceive(env)
    if final_env_state.isToggled(object_id):
        print(""Turning on the floor lamp confirmed."")
        return True, final_env_state
    else:
        print(""Failed to confirm the floor lamp is on."")
        return False, final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_459,,"
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple."")
    except:
        print(""Could not pick up the apple."")
        return False

    final_env_state = perceive(env)
    return final_env_state.holds(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_888,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds('tomato')), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_41,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the apple."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the apple is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_126,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding the apple and apple is not sliced.
    if not env_state.holds(object_id) or env_state.isSliced(object_id):
        print(""Failure, not holding apple or apple is already sliced."")
        return False, env_state
    
    # Low-level actions: slice the apple if it's not already sliced.
    try:
        if not env_state.isSliced(object_id):
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully sliced the apple."")
        else:
            print(""Apple is already sliced."")
    except:
        print(""Execution failure, unable to slice the apple."")
        return False, env_state

    # Postconditions: apple is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_11,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: put the object in the sink to clean it.
    try:
        print(""Trying to clean the object."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to put apple in sinkbasin."")
        # Assuming that the clean action isn't explicitly modeled and the object is considered clean once placed in the sink.
        # Normally, you'd expect some kind of cleaning action or waiting period.
    except Exception as e:
        print(""Failure, could not clean the object: {e}"")
        return False, env_state

    # Postconditions: object is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_3,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object and it should be heatable.
    if (not env_state.holds(object_id)) or (not env_state.heatable(object_id)):
        print(""Failure, not holding object or object not heatable."")
        return False, env_state

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the burner."")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the object on the stove burner to heat.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed glass bottle on the stove burner."")
    except:
        print(""Failure, could not heat object."")
        return False, env_state

    # Simulate waiting time for the object to heat up (this could be a specific wait time or triggering the next step based on when the object is perceived as hot)
    print(""Waiting for the glass bottle to heat up..."")
    # The code for this wait is not provided, but time should be allowed for the object to become hot, potentially querying the environment to check if it has heated up.

    # Postconditions: object is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_295,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The object should be sliceable.
    if not env_state.sliceable(object_id):
        print(""The object is not sliceable."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the object."")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: The object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state    
",0.05,1.5,0.03333333333333333,
PickupObject_302,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the mug!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_147,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the apple.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the apple."")
        return False, env_state

    # Assumption: The apple is already cold, as there is no functionality to cool down an object in the API.
    # Therefore, we assume the apple is cold by default or was previously cooled down and we are only checking its state.
    if (env_state.isCool(object_id)):
        print(""The apple is already cool."")
        return True, env_state
    else:
        print(""The apple is not cool."")
        return False, env_state
",0.05,1.5,0.03333333333333333,
PickupObject_839,,"
    # Preconditions: The knife must be clean.
    if not env_state.isClean(object_id):
        print(""Failure, knife is not clean."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully picked up the knife!"")
        else:
            print(""Failed to pick up the knife."")
            return False, env_state
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: Holding the knife.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_115,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the wine bottle.
    if (not env_state.holds(object_id)):
        print(""Not holding the wine bottle, cannot proceed to cool it."")
        return False, env_state

    # Check if the winebottle is already cool.
    if (env_state.isCool(object_id)):
        print(""Wine bottle is already chilled."")
        return True, env_state

    # If not coolable or already inside the fridge, skip to picking it up.
    if not env_state.coolable(object_id) or env_state.inReceptacle(object_id, 'fridge'):
        print(""Wine bottle cannot be chilled or is already in the fridge."")
        return True, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure opening fridge..."")
        return False

    # Low-level actions: put the wine bottle in the fridge.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed wine bottle in fridge."")
    except:
        print(""Failure placing wine bottle in fridge."")
        return False, env_state

    # Assume some time passes to allow the wine to chill.
    # Low-level actions: retrieve the wine bottle from the fridge.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Picked up the chilled wine bottle from the fridge."")
    except:
        print(""Execution failure picking up wine bottle from fridge..."")
        return False

    # Postconditions: holding the chilled wine bottle.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_49,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: we should be holding the knife.
    if not env_state.holds(object_id):
        print(""Failure, not holding the knife."")
        return False, env_state

    # If the knife is already clean, we don't need to do anything further.
    if env_state.isClean(object_id):
        return True, env_state

    # Low-level actions: clean the knife using the sink.
    try:
        # Check if we need to turn on the sink first.
        if env_state.toggleable('sink') and not env_state.isToggled('sink'):
            action = ToggleObjectOn(args={'object_id': 'sink'})
            success = act(env=env, action=action)
            print(f""Turned on the sink: {success}"")

        print(""Trying to clean the knife."")
        action = CleanObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of CleanObject is: {success}"")

        # Check if we need to turn off the sink afterwards.
        if env_state.toggleable('sink') and env_state.isToggled('sink'):
            action = ToggleObjectOff(args={'object_id': 'sink'})
            success = act(env=env, action=action)
            print(f""Turned off the sink: {success}"")
    except:
        print(""Failure, could not clean the knife."")
        return False, env_state

    # Postconditions: knife is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_875,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the egg."")
        return success
    except:
        print(""Execution failure..."")
        return False
",0.05,1.5,0.03333333333333333,
SliceObject_212,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: slice the tomato.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_160,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the bread."")
        return False, env_state

    # If the fridge is not open, open it first.
    if (not env_state.isOpen('fridge')):
        try:
            action = OpenObject(args={'object_id':'fridge'})
            success = act(env=env, action=action)
            print(""Successfully opened the fridge!"")
        except:
            print(""Execution failure opening the fridge..."")
            return False

    # Low-level actions: put the bread in the fridge to cool it.
    try:
        print(""Trying to put the bread in the fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully placed the bread in the fridge to cool."")
    except:
        print(""Failure placing the bread in the fridge."")
        return False, env_state

    # Close the fridge after putting in the bread.
    try:
        action = CloseObject(args={'object_id':'fridge'})
        success = act(env=env, action=action)
        print(""Successfully closed the fridge."")
    except:
        print(""Execution failure closing the fridge..."")
        return False

    # Assuming some time passes here for the bread to become cool.

    # Postconditions: the bread is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_247,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding the object (apple).
    if not env_state.holds(object_id):
        print(""Failure, not holding the apple."")
        return False, env_state
    
    # Low-level actions: slice the object (apple).
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the apple!"")
    except:
        print(""Execution failure..."")
        return False
    
    # Postconditions: the apple is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CheckCleanStatusAndCleanPan_0,,"
    # Preconditions: None.
    
    # Check if pan is already clean.
    if env_state.isClean(object_id):
        print(""Pan is already clean."")
        return True, env_state

    # If pan is not clean and it is cleanable.
    if env_state.cleanable(object_id):
        
        # Low-level actions: Clean the pan.
        try:
            # Assuming a CleanObject action is available in the environment.
            action = CleanObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Pan is being cleaned."")
        except:
            print(""Execution failure during cleaning."")
            return False, env_state
    
        # Postconditions: Pan is clean.
        final_env_state = perceive(env)
        return (final_env_state.isClean(object_id)), final_env_state
    else:
        print(""Cannot clean pan, it's not cleanable."")
        return False, env_state
",0.05,1.5,0.03333333333333333,
SliceObject_50,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The object must be sliceable and not already sliced.
    if (not env_state.sliceable(object_id) or env_state.isSliced(object_id)):
        print(""Failure, object cannot be sliced or is already sliced."")
        return False

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato."")
    except:
        print(""Execution failure while slicing the tomato."")
        return False

    # Postconditions: Object is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObjectFromReceptacle_12,,"
    # Preconditions: the pencil should be on the dining table.
    if (not env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""Failure, pencil not on the dining table."")
        return False, env_state

    # Low-level actions: pick up the pencil from the dining table.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pencil from the dining table!"")
        # Postconditions: holding the pencil.
        final_env_state = perceive(env)
        return (final_env_state.holds(object_id)), final_env_state
    except:
        print(""Execution failure..."")
        return False, env_state
",0.05,1.5,0.03333333333333333,
CleanObject_5,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: we should be holding the towel.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the towel."")
        return False, env_state

    # Low-level actions: clean the object using the sink.
    try:
        print(""Trying to clean the towel in the sink."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to put object in sink."")
        # Simulate rinsing the towel in the sink.
        # This part of the plan is not detailed in the API but would involve cleaning processes.
        # Since cleaning actions are not part of the given API, this would be an abstract step.
        success = simulate_rinsing(env)
        action = PickupObject(args={'object_id':object_id}) # Assume we need to pick it up again after rinsing.
        success = act(env=env, action=action)
        if not success:
            raise Exception(""Failed to pick up the object after cleaning."")
    except:
        print(""Failed to clean the towel."")
        return False, env_state

    # Postconditions: object is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_234,,"
    # Preconditions: None.

    # Low-level actions: pick up the apple.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure picking up the apple..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_226,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the candle.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the candle."")
        return False, env_state

    # Low-level actions: put the object (candle) on the table (diningtable).
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the candle on the table."")
    except:
        print(""Failure, could not place the candle on the table."")
        return False, env_state

    # Postconditions: not holding the object and the object is on the table.
    final_env_state = perceive(env)
    return not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_232,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the potato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: slice the potato.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_91,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding the potato.
    if not env_state.holds(object_id):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: slice the potato if it is sliceable.
    if env_state.sliceable(object_id) and not env_state.isSliced(object_id):
        try:
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully sliced the potato!"")
        except Exception as e:
            print(f""Execution failure: {e}"")
            return False, env_state

    # Postconditions: potato is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObjectIfDirty_1,,"
    # Preconditions: must be holding the spatula and it should be dirty.
    if not env_state.holds(object_id) or env_state.isClean(object_id):
        print(""Either not holding spatula or it is already clean."")
        return True, env_state  # No action needed if already clean.

    # Low level actions: clean the spatula.
    try:
        # Assumed spatula is cleanable and we clean it using a sink which is a common household assumption.
        action = CleanObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Spatula has been cleaned!"")
    except:
        print(""Execution failure cleaning the spatula..."")
        return False, env_state

    # Postconditions: spatula is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_627,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the remote control."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Attempting to place remote control on chair."")
    except:
        print(""Failure, could not place the remote control in chair."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Remote control placed on chair."")
    return (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_359,,"
    # Preconditions: None.
    
    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the plate!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the plate.
    final_env_state = perceive(env)
    return (final_env_state.holds(""plate"")), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_226,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding the bread.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding bread."")
        return False, env_state

    # Low-level actions: slice the bread.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: bread is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_333,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: the robot should be holding the vase.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the vase."")
        return False, env_state

    # Low-level actions: put the vase in the safe.
    try:
        print(""Trying to put the vase in the safe."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject (vase in safe) is: {success}"")
    except:
        print(""Failure, could not place vase in safe."")
        return False, env_state

    # Postconditions: the vase is in the safe.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_129,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the tomato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: slice the tomato.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: the tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_49,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: put the object in the fridge to cool.
    try:
        print(""Trying to cool the tomato by placing it in the fridge."")
        # Assuming fridge is an object that could be interacted similar to other receptacles.
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Tomato is now cooling in the fridge."")
    except:
        print(""Execution failure attempting to cool tomato."")
        return False, env_state

    # Postconditions: Tomato should be cool now.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_171,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: place the object in the fridge to cool it down.
    try:
        print(""Trying to cool object by placing in fridge."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place object in fridge."")
        return False, env_state

    # Assuming some time passes for the object to cool in the fridge.

    # Postconditions: object is cool.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_155,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the plate.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the plate."")
        return False, env_state

    # Low-level actions: turn the stove burner on.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner."")
    except:
        print(""Execution failure while trying to turn on the stove burner."")
        return False

    # Low-level actions: put the plate on the stove burner.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed the plate on the stove burner."")
    except:
        print(""Failure, could not place the plate on the stove burner."")
        return False, env_state

    # Postconditions: the plate must be hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectOnCoffeemachine_0,,"
    # Preconditions: we should be holding the heated mug.
    if (not (env_state.holds(object_id) and env_state.isHot(object_id))):
        print(""Failure, not holding heated mug."")
        return False, env_state

    # Low-level actions: put the mug on the coffee machine.
    try {
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Mug placed on the coffee machine."")
    } except {
        print(""Execution failure..."")
        return False, env_state
    }
    
    # Postconditions: mug on the coffee machine.
    final_env_state = perceive(env)
    return (final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
FindAndPickupObjectOnReceptacle_0,,"
    # Preconditions: the object should be on the specified receptacle.
    if not (env_state.inReceptacle(object_id, receptacle_object_id)):
        print(""The object is not on the specified receptacle."")
        return False, env_state

    # Low-level actions: pick up the object from the receptacle.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a tomato from the microwave!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_19,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: holding the egg.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the egg."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the egg in the fridge.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully put the egg in the fridge!"")
    except:
        print(""Failure, could not place the egg in the fridge."")
        return False, env_state

    # Simulate time for the egg to get chilled.
    # This would be part of a wait or a check mechanism to ascertain cooling (not shown here).

    # Low-level actions: open the fridge (after cooling period).
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Opened the fridge to get the egg."")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: pick up the chilled egg.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled egg!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the egg is chilled and in hand.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id) and final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
FindNearestReceptacle_0,,"
    # This is a placeholder example action, as the API does not support a direct method to find nearest receptacles.
    # We would typically have a function that finds the nearest receptacle of a certain type to a lamp.
    # For simplicity, we can assume that a sidetable is close to a lamp.

    sidetable_id = ""sidetable""  # Assume we have a sidetable identified.
    return sidetable_id, env_state
",0.05,1.5,0.03333333333333333,
CoolObject_36,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: must be holding the pan.
    if not env_state.holds(object_id):
        print(""Failure, not holding the pan."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except:
        print(""Execution failure opening the fridge..."")
        return False

    # Low-level actions: put the pan into the fridge to cool.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Placed the pan in the fridge to cool."")
    except:
        print(""Failed to place the pan in the fridge..."")
        return False

    # Simulate time for the pan to cool down (exact mechanism of waiting or checking could vary).
    print(""Waiting for the pan to cool down..."")
    # Placeholder for implementation of cooling down.

    # Preconditions: the pan is cooled.
    final_env_state = perceive(env)
    return (final_env_state.isCool(object_id) and not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
WashObject_10,,"
    # Preconditions: the object should be dirty.
    if (not env_state.isClean(object_id)):
        # Low-level actions: wash the object.
        # Assuming the existence of a WashObject action which is not specified. 

        # Low-level actions: open the receptacle if it is not open
        if env_state.receptacleIsClosed(receptacle_object_id):
            try:
                action = OpenObject(args={'object_id':receptacle_object_id})
                success = act(env=env, action=action)
                print(""Receptacle opened: "", success)
            except:
                print(""Failed to open the receptacle."")
                return False, env_state

        try:
            print(""Washing the object."")
            # Assuming that the wash action uses the sinkbasin and does not need to be picked up.
            # WashObject action is performed here.
            # Since the action is hypothetical, we just assume success.
            print(""Object washed successfully."")
        except:
            print(""Execution failure during object wash."")
            return False, env_state

        # Assuming the existence of a WashObject predicate which is not defined.
        final_env_state = perceive(env)
        return final_env_state.isClean(object_id), final_env_state
    else:
        print(""Object is already clean."")
        return True, env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_363,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the plunger.
    if not env_state.holds(object_id):
        print(""Not holding the plunger."")
        return False, env_state
    
    # Check if the sink has a cabinet underneath it and get its ID.
    sink_id = None
    for receptacle_id in RECEPTACLE_TYPES:
        if 'sink' in receptacle_id:
            sink_id = receptacle_id
            break
    
    if not sink_id or not env_state.inReceptacle(receptacle_id, 'cabinet'):
        print(""No cabinet found under the sink."")
        return False, env_state
    
    cabinet_under_sink_id = sink_id  # assuming that the sink actually refers to the cabinet under it

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the plunger in the cabinet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':cabinet_under_sink_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failed to put the plunger in the cabinet."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, cabinet_under_sink_id):
        print(""Successfully moved the plunger to the cabinet under the sink."")
        return True, final_env_state
    else:
        print(""The plunger is not in the correct location."")
        return False, final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_9,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the apple."")
        return False, env_state
    
    # Additional precondition: we assume the object can be heated.
    if (not env_state.heatable(object_id)):
        print(""Failure, object is not heatable."")
        return False, env_state

    # Low-level actions: turn the stove burner on.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the stove burner!"")
    except:
        print(""Execution failure in turning the stove burner on."")
        return False

    # Low-level actions: put the object in the receptacle to heat it up.
    try:
        print(""Trying to put apple on stove burner."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
        # Heating time assumption for simulation
        time.sleep(2) # Wait for a short period to simulate the apple warming up.
    except:
        print(""Failure, could not place apple on stove burner."")
        return False, env_state

    # Low-level actions: turn the stove burner off.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Successfully turned off the stove burner!"")
    except:
        print(""Execution failure in turning the stove burner off."")
        return False

    # Postconditions: object is warm.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CookObject_0,,"
    # Preconditions: holding the potato.
    if (not env_state.holds(object_id)):
        print(""Not holding the potato, cannot cook it."")
        return False, env_state
        
    # Check if potato is already sliced (it should be for cooking and the goal says 'piece of potato').
    if (not env_state.isSliced(object_id)):
        print(""Potato needs to be sliced before it can be cooked."")
        return False, env_state

    # Low-level actions: turn on the stove burner.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stove burner turned on!"")
    except:
        print(""Failed to turn on the stove burner..."")
        return False

    # Low-level actions: cook the potato by putting it on the stove burner.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Cooking the potato on the stove."")
    except:
        print(""Failed to put the potato on the stove burner."")
        return False

    # Assuming some time passes for the potato to cook.
    
    # Low-level actions: turn off the stove burner.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Stove burner turned off!"")
    except:
        print(""Failed to turn off the stove burner..."")
        return False

    # Low-level actions: Pickup the cooked potato 
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cooked potato!"")
    except:
        print(""Failed to pick up the cooked potato..."")
        return False

    # Postconditions: potato is cooked and being held.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id) and final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_146,,"
    # Preconditions: the object must be able to toggle
    if not env_state.toggleable(object_id):
        print(""Failure, object is not toggleable."")
        return False, env_state

    # Attempt to toggle the object on
    try:
        action = ToggleObjectOn(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Light toggled on."")
    except:
        print(""Execution failure, could not toggle light."")
        return False, env_state
    
    # Postconditions: object is toggled on
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_8,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: We should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the cloth."")
        return False, env_state

    # Low-level actions: Open the sink basin if it is closeable and not already open.
    if not env_state.isClean(object_id) and env_state.cleanable(object_id):
        try:
            print(""Placing the cloth in the sink basin to clean."")
            action_open_sink = OpenObject(args={'object_id':receptacle_object_id})
            act(env=env, action=action_open_sink)
            
            action_put_in_sink = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
            act(env=env, action=action_put_in_sink)
            
            # Assuming here that cleaning is automatic upon placing in the sink for simplicity.
            print(""The cloth is now being cleaned."")
        except Exception as e:
            print(f""Execution failure: {e}"")
            return False, env_state
    
    # Postconditions: The cloth is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CoolObject_157,"(:action CoolObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r FridgeType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isCool ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the potato."")
        return False, env_state

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(""Successfully opened the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Low-level actions: put the object in the fridge.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': 'fridge'})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place the potato in the fridge: {e}"")
        return False

    # Wait for the potato to cool down. This could be simulated with a delay or environmental state change.
    
    # Low-level actions: open the fridge again to retrieve the object.
    try:
        action = OpenObject(args={'object_id': 'fridge'})
        success = act(env=env, action=action)
        print(f""Result of OpenObject is: {success}"")
        
        # Low-level action: pick up the cooled object.
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the chilled potato!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False

    # Postconditions: object is cool.
    final_env_state = perceive(env)
    return final_env_state.isCool(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObjectFromReceptacle_4,,"
    # Preconditions: The pencil is in the dustbin (garbagecan).

    # Low-level actions: verify if the pencil is in the garbagecan.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Pencil is not in the specified garbagecan."")
        return False, env_state

    # Low-level actions: pick up the pencil from the garbagecan.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the pencil from the garbagecan."")
    except:
        print(""Execution failure in picking up the pencil."")
        return False

    # Postconditions: holding the pencil.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_67,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: We should be holding the egg which can be cleaned.
    if (not env_state.cleanable(object_id)):
        print(""Failure, egg can't be cleaned."")
        return False, env_state
    if (not env_state.holds(object_id)):
        print(""Failure, not holding egg."")
        return False, env_state

    # Low-level actions: simulate cleaning by putting the egg under the sinkbasin, assuming it represents rinsing.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            # Assuming the object is immediately cleaned when put under the sinkbasin.
            print(""Successfully rinsed the egg!"")
        else:
            print(""Failed to rinse the egg."")
            return False, env_state
    except:
        print(""Failure, could not rinse egg."")
        return False, env_state

    # Postconditions: Egg is cleaned.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObjectFromReceptacle_26,,"
    # Preconditions: The tomato should be in the refrigerator.
    if not env_state.inReceptacle(object_id, receptacle_object_id):
        print(""Tomato is not in the refrigerator."")
        return False, env_state

    # Low-level actions: pick up the object from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato from the fridge!"")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: holding the tomato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
EnsureObjectIsClean_1,,"
    # Preconditions: None.

    # If the spatula is already clean, no action is necessary.
    if env_state.isClean(object_id):
        return True, env_state

    # If the spatula is not clean and can be cleaned, clean the spatula.
    if env_state.cleanable(object_id):
        # First pick up the spatula.
        try:
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            if not success:
                print(""Failure, could not pick up the spatula."")
                return False, env_state
        except:
            print(""Execution failure..."")
            return False, env_state

        # Second, clean the spatula using the sink basin.
        try:
            action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
            success = act(env=env, action=action)
            if not success:
                print(""Failure, could not clean spatula."")
                return False, env_state
            # Assuming a clean function
            action = CleanObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            if not success:
                print(""Failure, spatula did not get cleaned."")
                return False, env_state
        except:
            print(""Execution failure..."")
            return False, env_state
            
        # Pick up the clean spatula from the sink.
        try:
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            if not success:
                print(""Failure, could not pick up the clean spatula."")
                return False, env_state
        except:
            print(""Execution failure..."")
            return False, env_state

        final_env_state = perceive(env)
        return final_env_state.isClean(object_id), final_env_state

    return False, env_state
",0.05,1.5,0.03333333333333333,
PickupObject_647,,"
    # Preconditions: The 'watch' should be on 'coffeetable'.
    if not env_state.inReceptacle(object_id, 'coffeetable'):
        print(""Failure, object is not on the specified receptacle."")
        return False, env_state

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the watch!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
ExamineObject_4,,"
    # Preconditions: Assuming the environment model has a predicate to check if the room is well-lit. Also, we should be holding the alarm clock and the desk lamp should be on.

    if not env_state.isToggled(""desklamp""):
        print(""Failure: The desk lamp is not providing light."")
        return False, env_state

    if not env_state.holds(object_id):
        print(""Failure: Not holding the alarm clock to examine."")
        return False, env_state

    # Low-level actions: Simulate examining the alarm clock by ensuring the conditions mentioned above hold true.
    # In a more advanced model, there could be actions related to visual inspection or sensing.
    print(""Examining the alarm clock by the light of the desk lamp..."")
    success = True  # Simulate successful examination

    # Postconditions: The alarm clock has been examined.
    # here we assume examine does not change the alarm clock status hence we can pass env_state without perceiving it once more.
    return success, env_state
",0.05,1.5,0.03333333333333333,
SliceObject_122,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The object must be sliceable and not already sliced.
    if not (env_state.sliceable(object_id) and not env_state.isSliced(object_id)):
        print(""Cannot slice object or object is already sliced."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure while attempting to slice..."")
        return False, env_state

    # Postconditions: Tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1076,,"
    # Preconditions: The object should be inside the 'bathtubbasin' receptacle.

    # Check if the cloth is in the bathtub basin.
    if not env_state.inReceptacle(object_id, 'bathtubbasin'):
        print(""Failure, the cloth is not in the bathtub."")
        return False, env_state

    # Low-level actions: pick up the cloth from the bathtub basin.
    try:
        action = PickupObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cloth from the bathtub!"")
    except:
        print(""Execution failure in picking up the cloth..."")
        return False

    # Postconditions: holding the cloth.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1070,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a glass bottle!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_94,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding egg."")
        return False, env_state

    # Low-level actions: put the object in the receptacle (stove burner).
    try:
        print(""Trying to put egg on stoveburner."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place egg on stoveburner."")
        return False, env_state

    # Low-level actions: toggle the stove burner on to heat the egg.
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOn is: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Waiting some time for the egg to be heated can be assumed here.

    # Low-level actions: toggle the stove burner off after the egg is heated.
    try:
        action = ToggleObjectOff(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of ToggleObjectOff is: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: egg is heated.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
FindToggleableLamp_0,,"
    # Preconditions: None.
    
    # Helper function to find a toggleable lamp.
    def find_toggleable_lamp(env_state):
        for object_type in OBJECT_TYPES:
            if 'lamp' in object_type and env_state.toggleable(object_type):
                return object_type
        return None
        
    # Low-level actions: find a toggleable lamp in the environment.
    object_id = find_toggleable_lamp(env_state)
    return (object_id is not None), object_id
",0.05,1.5,0.03333333333333333,
SliceObject_289,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding lettuce."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced lettuce!"")
    except:
        print(""Execution failure while slicing lettuce..."")
        return False, env_state

    # Postconditions: lettuce is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_669,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up a glass bottle."")
    except:
        print(""Execution failure, could not pick up a glass bottle."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_239,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The tomato must not be already sliced and be sliceable.
    if env_state.isSliced(object_id) or not env_state.sliceable(object_id):
        print(""Failure, tomato is already sliced or is not sliceable."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(f""Result of SliceObject is: {success}"")
    except:
        print(""Execution failure: Could not slice the tomato."")
        return False, env_state

    # Postconditions: the tomato is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_41,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: holding the 'lettuce', and the 'lettuce' is not clean.
    if not (env_state.holds(object_id) and not env_state.isClean(object_id)):
        print(""Preconditions not met for cleaning."")
        return False, env_state

    # Assuming there's a mechanism or a specific procedure to clean the 'lettuce'.
    # Execute cleaning procedure (not explicitly defined in given API).

    # Postconditions: the 'lettuce' is clean.
    final_env_state = perceive(env)
    return final_env_state.isClean(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_4,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: The object should be heatable and should not be already hot.
    if not (env_state.heatable(object_id) and not env_state.isHot(object_id)):
        print(""Failure, object is not heatable or is already hot."")
        return False, env_state

    # Low-level actions: Put the object on the stove burner to heat it.
    try:
        # First, make sure the stove burner is on.
        if not env_state.isToggled(receptacle_object_id):
            toggle_action = ToggleObjectOn(args={'object_id': receptacle_object_id})
            act(env=env, action=toggle_action)

        # Now place the egg on the burner.
        put_action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=put_action)
        print(f""Result of PutObject is: {success}"")

        # Assuming there is some wait time required to heat up the egg.
        # This would be a delay in a real scenario, which we're omitting in pseudocode.

    except Exception as e:
        print(f""Execution failure with error: {e}"")
        return False, env_state

    # Postconditions: Object is hot.
    final_env_state = perceive(env)
    return final_env_state.isHot(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_679,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the cellphone.
    if not env_state.holds(object_id):
        print(""Failure, not holding the cellphone."")
        return False, env_state

    # Identify the drawer to put the cellphone in.
    # Assuming the nightstand has a drawer part which is addressed as 'drawer' in RECEPTACLE_TYPES.
    receptacle_object_id = 'drawer'

    # Low-level actions: Put the cellphone in the drawer.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if success:
            print(""Successfully placed the cellphone in the drawer."")
        else:
            print(""Failed to place the cellphone in the drawer."")
            return False
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state

    # Postconditions: not holding the cellphone and the cellphone is in the drawer.
    final_env_state = perceive(env)
    return (not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_81,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: The object should be sliceable.

    if (not env_state.sliceable(object_id)):
        print(""Failure, object not sliceable."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the object!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: The object is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_76,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: holding the bread object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding bread."")
        return False, env_state

    # Low-level actions: slice the bread.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the bread!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: bread is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_521,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the soapbar.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding soapbar."")
        return False, env_state

    # Low-level actions: put the soapbar in the cabinet.
    try:
        print(""Trying to place soapbar in cabinet."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place soapbar in cabinet."")
        return False, env_state
    
    # Postconditions: not holding the soapbar and the soapbar is in the cabinet.
    final_env_state = perceive(env)
    if (not final_env_state.holds(object_id)) and (final_env_state.inReceptacle(object_id, receptacle_object_id)):
        return True, final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_171,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the lettuce!"")
    except Exception as e:
        print(""Execution failure: "" + str(e))
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return (final_env_state.holds('lettuce')), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_87,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding the object and it should be sliceable.
    if not (env_state.holds(object_id) and env_state.sliceable(object_id)):
        print(""Cannot slice. Either not holding the object, or it's not sliceable."")
        return False

    # Low-level actions: slice the lettuce.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the lettuce!"")
    except Exception as e:
        print(f""Execution failure while slicing lettuce: {e}"")
        return False

    # Postconditions: lettuce is sliced.
    final_env_state = perceive(env)
    return final_env_state.isSliced(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
HeatObject_129,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the object (egg).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding object."")
        return False, env_state

    # Low-level actions: turning on the appliance (stoveburner).
    try:
        action = ToggleObjectOn(args={'object_id':appliance_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned on the appliance!"")
    except:
        print(""Execution failure..."")
        return False

    # Simulated action: ""Cook"" the egg by waiting for it to heat up on the stove.
    # In a real situation, this would include a timed wait and checking the state of the egg,
    # but for this example we will assume that the egg is instantly hot.

    # Low-level actions: turning off the appliance (stoveburner) after 'cooking'.
    try:
        action = ToggleObjectOff(args={'object_id':appliance_object_id})
        success = act(env=env, action=action)
        print(""Successfully turned off the appliance!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: egg is hot.
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_206,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: we should be holding the potato.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding potato."")
        return False, env_state

    # Low-level actions: slice the potato.
    if (env_state.sliceable(object_id) and not env_state.isSliced(object_id)):
        try:
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(f""Successfully sliced the potato: {success}"")
        except:
            print(""Execution failure..."")
            return False, env_state
    else:
        print(""Potato is either not sliceable or is already sliced."")
        return False, env_state

    # Postconditions: potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
WashObject_13,,"
    # Preconditions: we should be holding the object (tomato).
    if (not env_state.holds(object_id)):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: if the tomato is dirty, wash it using the sinkbasin.
    if (not env_state.isClean(object_id)):
        if(env_state.cleanable(object_id)):
            try:
                action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
                success = act(env=env, action=action)
                print(""Placed the tomato in the sinkbasin to wash."")

                if env_state.toggleable(receptacle_object_id):
                    action = ToggleObjectOn(args={'object_id':receptacle_object_id})
                    success = act(env=env, action=action)
                    print(""Turned the water on to wash the tomato."")

                    action = ToggleObjectOff(args={'object_id':receptacle_object_id})
                    success = act(env=env, action=action)
                    print(""Turned the water off after washing the tomato."")
                else:
                    print(""The sinkbasin is not toggleable. Cannot wash the tomato."")
                    return False, env_state

            except:
                print(""Execution failure..."")
                return False, env_state

    # Preconditions: the tomato should be clean.
    if (not env_state.isClean(object_id)):
        print(""The tomato is still not clean."")
        return False, env_state

    # Low-level actions: pick up the clean tomato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the clean tomato!"")
    except:
        print(""Execution failure..."")
        return False, env_state

    # Postconditions: holding the clean tomato.
    final_env_state = perceive(env)
    return final_env_state.holds(object_id) and final_env_state.isClean(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CheckObjectTemperature_0,,"
    # Preconditions: holding the potato.

    # Check if the potato is already cool.
    if env_state.isCool(object_id):
        print(""The potato is already cool."")
        return True, env_state
    else:
        print(""The potato is not cool yet."")
        return False, env_state
",0.05,1.5,0.03333333333333333,
HeatObject_112,"(:action HeatObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r MicrowaveType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isHot ?o)
        )
    )","
    # Preconditions: we should be holding the egg.
    if not env_state.holds(object_id):
        print(""Not holding an egg. Cannot heat."")
        return False, env_state
    
    # Low-level actions: turn the stove burner on
    try:
        action = ToggleObjectOn(args={'object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Turned the stove burner on: {success}"")
    except:
        print(""Execution failure..."")
        return False

    # Low-level actions: put the egg on the stove burner to heat it.
    try:
        print(""Trying to heat the egg."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Egg is now heating: {success}"")
    except:
        print(""Could not heat the egg."")
        return False

    # Postconditions: assume the egg is heated after a certain time or mechanism (not simulated here).
    final_env_state = perceive(env)
    return (final_env_state.isHot(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
OpenObject_9,"(:action OpenObject
        :parameters (?a - agent ?l - location ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (openable ?r)
            
            
            
            
        )
        :effect (and
            (opened ?r)
        )
    )","
    # Preconditions: fridge should not be already open.

    # Low-level actions: open the fridge.
    try:
        action = OpenObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Fridge has been opened."")
    except:
        print(""Execution failure, could not open fridge."")
        return False, env_state

    # Postconditions: fridge should be open.
    final_env_state = perceive(env)
    return final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_863,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The bread should be chilled and we aren't holding it currently.
    
    # Low-level actions: pick up the chilled bread from the fridge.
    if env_state.inReceptacle(object_id, ""fridge"") and not env_state.holds(object_id):
        try:
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up chilled bread."")
        except:
            print(""Execution failure..."")
            return False

    # Check if we are holding the bread and the bread is chilled.
    if not (env_state.holds(object_id) and env_state.isCool(object_id)):
        print(""Failure, bread is not held or not chilled."")
        return False, env_state

    # Low-level actions: put the bread on the dining table.
    try:
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Successfully placed chilled bread on the dining table."")
    except:
        print(""Failure, could not place bread on table."")
        return False, env_state

    # Postconditions: not holding the bread and it's on the table.
    final_env_state = perceive(env)
    return ((not final_env_state.holds(object_id)) and final_env_state.inReceptacle(object_id, receptacle_object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_541,,"
    # Preconditions: None.

    # Low-level actions: pick up the object.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the object.
    final_env_state = perceive(env)
    return final_env_state.holds(""tomato""), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_266,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: must be holding the object.
    if (not env_state.holds(object_id)):
        print(""Failure, not holding tomato."")
        return False, env_state

    # Low-level actions: slice the object.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato."")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: the tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_459,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: we should be holding the object.
    if not env_state.holds(object_id):
        print(""Failure, not holding the credit card."")
        return False, env_state

    # Low-level actions: put the object in the receptacle.
    try:
        print(""Trying to put the credit card on the chair."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the credit card on the chair."")
        return False, env_state

    # Postconditions: not holding the object and the object is in the receptacle.
    final_env_state = perceive(env)
    if not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectOnReceptacle_11,,"
    # Preconditions: Mug should be cool and in the fridge.
    if not (env_state.isCool(object_id) and env_state.inReceptacle(object_id, 'fridge')):
        print(""Mug is not cool or not in the fridge."")
        return False, env_state

    # Low-level actions: Pick up the cool mug from the fridge.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the cool mug from the fridge!"")
    except Exception as e:
        print(f""Execution failure: {e}"")
        return False, env_state
    
    # Low-level actions: put the cool mug on the small black table (sidetable).
    try:
        print(""Trying to put the cool mug on the sidetable."")
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject is: {success}"")
    except Exception as e:
        print(f""Failure, could not place cool mug on the sidetable: {e}"")
        return False, env_state

    # Postconditions: cool mug is on the sidetable.
    final_env_state = perceive(env)
    result = final_env_state.inReceptacle(object_id, receptacle_object_id)
    return result, final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_113,,"
    # Preconditions: The object can be toggled.

    # Low-level actions: turn on the object.
    if env_state.toggleable(object_id):
        try:
            action = ToggleObjectOn(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully toggled on the object!"")
        except:
            print(""Execution failure..."")
            return False

    # Postconditions: the object is on and can provide light.
    final_env_state = perceive(env)
    return final_env_state.isToggled(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
ToggleObjectOn_104,,"
    # Preconditions: Must be holding the clock to satisfy the goal constraint (even though it’s not technically necessary for turning on a lamp).
    if not env_state.holds('alarmclock'):
        print(""Not holding alarm clock, cannot turn on the desk lamp as per goal constraints."")
        return False, env_state

    # Check if the object is toggleable to ensure it can be turned on.
    if not env_state.toggleable(object_id):
        print(f""The object {object_id} is not toggleable."")
        return False, env_state
    
    # Low-level actions: turn on the object.
    try:
        action = ToggleObjectOn(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(f""Successfully turned on the desk lamp! Result: {success}"")
    except Exception as e:
        print(f""Failed to turn on the desk lamp: {e}"")
        return False, env_state
    
    # Postconditions: Desk lamp is turned on while holding the clock.
    final_env_state = perceive(env)
    return (final_env_state.isToggled(object_id) and final_env_state.holds('alarmclock')), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_1105,,"
    # Preconditions: None.

    # Low-level actions: pick up the potato.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up potato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the potato.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_146,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: Holding the chilled lettuce.
    if not env_state.holds(object_id):
        print(""Failure, not holding the chilled lettuce."")
        return False, env_state

    # Low-level actions: put the lettuce on the side table.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        if not success:
            print(""Failure, could not place the lettuce on the side table."")
            return False, env_state

        print(""Lettuce successfully placed on the side table."")
    except Exception as e:
        print(f""Failure while placing lettuce on the side table: {e}"")
        return False, env_state

    # Postconditions: not holding the lettuce and the lettuce is on the side table.
    final_env_state = perceive(env)
    return not final_env_state.holds(object_id) and final_env_state.inReceptacle(object_id, receptacle_object_id), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObjectIfNeeded_1,,"
    # Preconditions: must be holding the object.

    # Check if the object is already clean. If not, clean it.
    if not env_state.isClean(object_id):
        if env_state.cleanable(object_id):
            # Low-level action: actually clean the object.
            # Assume a function `CleanObject` exists that takes an object and cleans it.
            try:
                action = CleanObject(args={'object_id': object_id})
                success = act(env=env, action=action)
                print(""Successfully cleaned the fork!"")
            except Exception as e:
                print(f""Execution failure with error {e}"")
                return False

            # Postconditions: object should be clean now.
            final_env_state = perceive(env)
            return final_env_state.isClean(object_id), final_env_state
        else:
            print(""The object cannot be cleaned."")
            return False
    else:
        print(""The fork is already clean."")
        return True, env_state
",0.05,1.5,0.03333333333333333,
SliceObject_4,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Holding the tomato that needs slicing.
    if not env_state.holds(object_id):
        print(""Not holding the tomato."")
        return False

    # Low-level actions: Slice the tomato if sliceable.
    if env_state.sliceable(object_id) and not env_state.isSliced(object_id):
        try:
            action = SliceObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Tomato is now sliced."")
        except:
            print(""Could not slice the tomato."")
            return False
    else:
        print(""Tomato is not sliceable or already sliced."")
        return False

    # Postconditions: Tomato is now sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_249,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: Must be holding the potato and it must not already be sliced.
    if (not env_state.holds(object_id)) or (env_state.isSliced(object_id)):
        print(""Failure: Not holding potato or it is already sliced."")
        return False, env_state

    # Low-level actions: slice the potato.
    try:
        action = SliceObject(args={'object_id': object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the potato."")
    except:
        print(""Execution failure: Unable to slice the potato."")
        return False

    # Postconditions: The potato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
EnsureObjectIsClean_2,,"
    # Preconditions: need to have the object ""lettuce"".
    
    # Low-level actions: determine if the lettuce is clean.
    if not env_state.isClean(object_id):
        # The object is not clean, attempt to clean it.
        
        # Assume that a sink is available to clean the object.
        sink_id = 'sinkbasin' # Assuming there is a sink to clean the lettuce.
        
        # Try to pick up the object
        try:
            action = PickupObject(args={'object_id': object_id})
            success = act(env=env, action=action)
            print(""Picked up the lettuce."")
        except:
            print(""Failed to pick up the lettuce."")
            return False

        # Put the object in the sink to clean it.
        try:
            action = PutObject(args={'object_id': object_id, 'receptacle_object_id': sink_id})
            success = act(env=env, action=action)
            print(""Lettuce is now in the sink."")
        except:
            print(""Failed to put the lettuce in the sink."")
            return False

        # Assume the environment automatically cleans the object once it's placed in the sink.
        
        # Wait for the lettuce to be clean, this may involve some simulated waiting mechanism or a notification that the object is clean.

        # Object should now be clean
        final_env_state = perceive(env)
        if final_env_state.isClean(object_id):
            print(""Lettuce is clean."")
        else:
            print(""Lettuce is still not clean."")
            return False

    else:
        print(""Lettuce is already clean."")

    # Postconditions: lettuce is clean.

    return (env_state.isClean(object_id)), env_state
",0.05,1.5,0.03333333333333333,
CleanObject_24,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: Must be holding the tomato and tomato is not already clean.
    if (not env_state.holds(object_id)) or env_state.isClean(object_id):
        print(""Failure, not holding tomato or tomato is already clean."")
        return False, env_state

    # Low-level actions: clean the tomato by putting it under water in the sink or using a cleaning tool.
    # Assuming cleaning happens automatically when the tomato is placed in the sink basin.
    try:
        action = PutObject(args={'object_id':object_id, 'receptacle_object_id':receptacle_object_id})
        success = act(env=env, action=action)
        print(f""Result of PutObject for cleaning is: {success}"")
    except:
        print(""Failure, could not clean the tomato."")
        return False, env_state

    # Postconditions: Tomato is clean.
    # Assuming the state changes to isClean object once put in the sinkbasin.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
PickupObject_418,,"
    # Preconditions: the apple should be in the microwave and the microwave should be open.
    if not (env_state.inReceptacle(object_id, 'microwave') and env_state.opened('microwave')):
        print(""Failure, the microwave is not open or the apple is not inside."")
        return False, env_state
   
    # Low-level actions: pick up the apple.
    try:
        action = PickupObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully picked up the apple!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: holding the apple.
    final_env_state = perceive(env)
    return (final_env_state.holds(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_48,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: None.

    # Low-level actions: Check if the fork is already clean.
    if (env_state.isClean(object_id)):
        print(""Fork is already clean, no need to clean it again."")
        return True, env_state

    # Low-level actions: pick up the fork if not holding it.
    if (not env_state.holds(object_id)):
        try:
            action = PickupObject(args={'object_id':object_id})
            success = act(env=env, action=action)
            print(""Successfully picked up the fork!"")
        except:
            print(""Execution failure..."")
            return False, env_state
    
    # Low-level actions: Use the cleaning apparatus, presumably calling sinkbasin 'Open' if necessary and using it to clean.
    if (not env_state.opened(receptacle_object_id)):
        try:
            action = OpenObject(args={'object_id':receptacle_object_id})
            success = act(env=env, action=action)
            print(""Successfully opened the sink!"")
        except:
            print(""Execution failure, could not open the sink."")
            return False, env_state
    
    # Placeholder for cleaning action, no actual cleaning action is available in API.
    print(""Pretend cleaning action here."")

    # Postconditions: Fork is clean.
    final_env_state = perceive(env)
    return (final_env_state.isClean(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
CleanObject_21,"(:action CleanObject
        :parameters (?a - agent ?l - location ?r - receptacle ?o - object)
        :precondition (and
            (receptacleType ?r SinkBasinType)
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (holds ?a ?o)
        )
        :effect (and
            (isClean ?o)
        )
    )","
    # Preconditions: object should be cleanable and is not already clean.
    if not env_state.cleanable(object_id):
        print(""Object is not cleanable."")
        return False, env_state
    if env_state.isClean(object_id):
        print(""Object is already clean."")
        return True, env_state

    # Low-level actions: typically involve using a sink or water source to clean an object.
    try:
        print(""Attempting to clean the object."")
        # Adding water to the soapbar at the sink. This is not an actual action in API, just illustrative.
        action = UseSinkToCleanObject(args={'object_id': object_id, 'tool_object_id': tool_object_id})
        success = act(env=env, action=action)
        print(""Result of cleaning object is: {success}"")
    except:
        print(""Failure, could not clean object."")
        return False, env_state

    # Postconditions: object is clean.
    final_env_state = perceive(env)
    return final_env_state.isClean(object_id), final_env_state
",0.05,1.5,0.03333333333333333,
PutObjectInReceptacle_81,"(:action PutObjectInReceptacle
        :parameters (?a - agent ?l - location ?ot - otype ?o - object ?r - receptacle)
        :precondition (and
            (atLocation ?a ?l)
            (receptacleAtLocation ?r ?l)
            (objectType ?o ?ot)
            (holds ?a ?o)
            (not (holdsAnyReceptacleObject ?a))
        )
        :effect (and
            (inReceptacle ?o ?r)
            (not (holds ?a ?o))
            (not (holdsAny ?a))
            (objectAtLocation ?o ?l)
        )
    )","
    # Preconditions: The tomato is sliced. 
    if not env_state.isSliced(object_id):
        print(""Failure, the tomato isn't sliced."")
        return False, env_state

    # Low-level actions: put the tomato on the countertop.
    try:
        print(""Trying to put the tomato on the countertop."")
        action = PutObject(args={'object_id': object_id, 'receptacle_object_id': receptacle_object_id})
        success = act(env=env, action=action)
        print(""Result of PutObject is: {success}"")
    except:
        print(""Failure, could not place the tomato on the countertop."")
        return False, env_state

    # Postconditions: The tomato is on the countertop.
    final_env_state = perceive(env)
    if final_env_state.inReceptacle(object_id, receptacle_object_id):
        return True, final_env_state
    else:
        return False, final_env_state
",0.05,1.5,0.03333333333333333,
SliceObject_133,"(:action SliceObject
        :parameters (?a - agent ?l - location ?co - object ?ko - object)
        :precondition (and
            (objectType ?ko KnifeType)
            (atLocation ?a ?l)
            (objectAtLocation ?co ?l)
            (sliceable ?co)
            (holds ?a ?ko)
        )
        :effect (and
            (isSliced ?co)
        )
    )","
    # Preconditions: must be holding the tomato.
    if not env_state.holds(object_id):
        print(""Failure, not holding the tomato."")
        return False, env_state

    # Low-level actions: slice the tomato.
    try:
        action = SliceObject(args={'object_id':object_id})
        success = act(env=env, action=action)
        print(""Successfully sliced the tomato!"")
    except:
        print(""Execution failure..."")
        return False

    # Postconditions: tomato is sliced.
    final_env_state = perceive(env)
    return (final_env_state.isSliced(object_id)), final_env_state
",0.05,1.5,0.03333333333333333,
